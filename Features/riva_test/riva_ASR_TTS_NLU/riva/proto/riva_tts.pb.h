// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: riva/proto/riva_tts.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_riva_2fproto_2friva_5ftts_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_riva_2fproto_2friva_5ftts_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
#include "riva/proto/riva_audio.pb.h"
#include "riva/proto/riva_common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_riva_2fproto_2friva_5ftts_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_riva_2fproto_2friva_5ftts_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_riva_2fproto_2friva_5ftts_2eproto;
namespace nvidia {
namespace riva {
namespace tts {
class RivaSynthesisConfigRequest;
struct RivaSynthesisConfigRequestDefaultTypeInternal;
extern RivaSynthesisConfigRequestDefaultTypeInternal _RivaSynthesisConfigRequest_default_instance_;
class RivaSynthesisConfigResponse;
struct RivaSynthesisConfigResponseDefaultTypeInternal;
extern RivaSynthesisConfigResponseDefaultTypeInternal _RivaSynthesisConfigResponse_default_instance_;
class RivaSynthesisConfigResponse_Config;
struct RivaSynthesisConfigResponse_ConfigDefaultTypeInternal;
extern RivaSynthesisConfigResponse_ConfigDefaultTypeInternal _RivaSynthesisConfigResponse_Config_default_instance_;
class RivaSynthesisConfigResponse_Config_ParametersEntry_DoNotUse;
struct RivaSynthesisConfigResponse_Config_ParametersEntry_DoNotUseDefaultTypeInternal;
extern RivaSynthesisConfigResponse_Config_ParametersEntry_DoNotUseDefaultTypeInternal _RivaSynthesisConfigResponse_Config_ParametersEntry_DoNotUse_default_instance_;
class SynthesizeSpeechRequest;
struct SynthesizeSpeechRequestDefaultTypeInternal;
extern SynthesizeSpeechRequestDefaultTypeInternal _SynthesizeSpeechRequest_default_instance_;
class SynthesizeSpeechResponse;
struct SynthesizeSpeechResponseDefaultTypeInternal;
extern SynthesizeSpeechResponseDefaultTypeInternal _SynthesizeSpeechResponse_default_instance_;
class SynthesizeSpeechResponseMetadata;
struct SynthesizeSpeechResponseMetadataDefaultTypeInternal;
extern SynthesizeSpeechResponseMetadataDefaultTypeInternal _SynthesizeSpeechResponseMetadata_default_instance_;
class ZeroShotData;
struct ZeroShotDataDefaultTypeInternal;
extern ZeroShotDataDefaultTypeInternal _ZeroShotData_default_instance_;
}  // namespace tts
}  // namespace riva
}  // namespace nvidia
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace nvidia {
namespace riva {
namespace tts {

// ===================================================================


// -------------------------------------------------------------------

class ZeroShotData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.tts.ZeroShotData) */ {
 public:
  inline ZeroShotData() : ZeroShotData(nullptr) {}
  ~ZeroShotData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ZeroShotData(::google::protobuf::internal::ConstantInitialized);

  inline ZeroShotData(const ZeroShotData& from)
      : ZeroShotData(nullptr, from) {}
  ZeroShotData(ZeroShotData&& from) noexcept
    : ZeroShotData() {
    *this = ::std::move(from);
  }

  inline ZeroShotData& operator=(const ZeroShotData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZeroShotData& operator=(ZeroShotData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZeroShotData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZeroShotData* internal_default_instance() {
    return reinterpret_cast<const ZeroShotData*>(
               &_ZeroShotData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ZeroShotData& a, ZeroShotData& b) {
    a.Swap(&b);
  }
  inline void Swap(ZeroShotData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZeroShotData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZeroShotData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZeroShotData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ZeroShotData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ZeroShotData& from) {
    ZeroShotData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ZeroShotData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.tts.ZeroShotData";
  }
  protected:
  explicit ZeroShotData(::google::protobuf::Arena* arena);
  ZeroShotData(::google::protobuf::Arena* arena, const ZeroShotData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioPromptFieldNumber = 1,
    kTranscriptFieldNumber = 5,
    kSampleRateHzFieldNumber = 2,
    kEncodingFieldNumber = 3,
    kQualityFieldNumber = 4,
  };
  // bytes audio_prompt = 1;
  void clear_audio_prompt() ;
  const std::string& audio_prompt() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_audio_prompt(Arg_&& arg, Args_... args);
  std::string* mutable_audio_prompt();
  PROTOBUF_NODISCARD std::string* release_audio_prompt();
  void set_allocated_audio_prompt(std::string* value);

  private:
  const std::string& _internal_audio_prompt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_prompt(
      const std::string& value);
  std::string* _internal_mutable_audio_prompt();

  public:
  // string transcript = 5;
  void clear_transcript() ;
  const std::string& transcript() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transcript(Arg_&& arg, Args_... args);
  std::string* mutable_transcript();
  PROTOBUF_NODISCARD std::string* release_transcript();
  void set_allocated_transcript(std::string* value);

  private:
  const std::string& _internal_transcript() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transcript(
      const std::string& value);
  std::string* _internal_mutable_transcript();

  public:
  // int32 sample_rate_hz = 2;
  void clear_sample_rate_hz() ;
  ::int32_t sample_rate_hz() const;
  void set_sample_rate_hz(::int32_t value);

  private:
  ::int32_t _internal_sample_rate_hz() const;
  void _internal_set_sample_rate_hz(::int32_t value);

  public:
  // .nvidia.riva.AudioEncoding encoding = 3;
  void clear_encoding() ;
  ::nvidia::riva::AudioEncoding encoding() const;
  void set_encoding(::nvidia::riva::AudioEncoding value);

  private:
  ::nvidia::riva::AudioEncoding _internal_encoding() const;
  void _internal_set_encoding(::nvidia::riva::AudioEncoding value);

  public:
  // int32 quality = 4;
  void clear_quality() ;
  ::int32_t quality() const;
  void set_quality(::int32_t value);

  private:
  ::int32_t _internal_quality() const;
  void _internal_set_quality(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.tts.ZeroShotData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr audio_prompt_;
    ::google::protobuf::internal::ArenaStringPtr transcript_;
    ::int32_t sample_rate_hz_;
    int encoding_;
    ::int32_t quality_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5ftts_2eproto;
};// -------------------------------------------------------------------

class SynthesizeSpeechResponseMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.tts.SynthesizeSpeechResponseMetadata) */ {
 public:
  inline SynthesizeSpeechResponseMetadata() : SynthesizeSpeechResponseMetadata(nullptr) {}
  ~SynthesizeSpeechResponseMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SynthesizeSpeechResponseMetadata(::google::protobuf::internal::ConstantInitialized);

  inline SynthesizeSpeechResponseMetadata(const SynthesizeSpeechResponseMetadata& from)
      : SynthesizeSpeechResponseMetadata(nullptr, from) {}
  SynthesizeSpeechResponseMetadata(SynthesizeSpeechResponseMetadata&& from) noexcept
    : SynthesizeSpeechResponseMetadata() {
    *this = ::std::move(from);
  }

  inline SynthesizeSpeechResponseMetadata& operator=(const SynthesizeSpeechResponseMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline SynthesizeSpeechResponseMetadata& operator=(SynthesizeSpeechResponseMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SynthesizeSpeechResponseMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const SynthesizeSpeechResponseMetadata* internal_default_instance() {
    return reinterpret_cast<const SynthesizeSpeechResponseMetadata*>(
               &_SynthesizeSpeechResponseMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SynthesizeSpeechResponseMetadata& a, SynthesizeSpeechResponseMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(SynthesizeSpeechResponseMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SynthesizeSpeechResponseMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SynthesizeSpeechResponseMetadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SynthesizeSpeechResponseMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SynthesizeSpeechResponseMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SynthesizeSpeechResponseMetadata& from) {
    SynthesizeSpeechResponseMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SynthesizeSpeechResponseMetadata* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.tts.SynthesizeSpeechResponseMetadata";
  }
  protected:
  explicit SynthesizeSpeechResponseMetadata(::google::protobuf::Arena* arena);
  SynthesizeSpeechResponseMetadata(::google::protobuf::Arena* arena, const SynthesizeSpeechResponseMetadata& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPredictedDurationsFieldNumber = 8,
    kTextFieldNumber = 1,
    kProcessedTextFieldNumber = 2,
  };
  // repeated float predicted_durations = 8;
  int predicted_durations_size() const;
  private:
  int _internal_predicted_durations_size() const;

  public:
  void clear_predicted_durations() ;
  float predicted_durations(int index) const;
  void set_predicted_durations(int index, float value);
  void add_predicted_durations(float value);
  const ::google::protobuf::RepeatedField<float>& predicted_durations() const;
  ::google::protobuf::RepeatedField<float>* mutable_predicted_durations();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_predicted_durations() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_predicted_durations();

  public:
  // string text = 1;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // string processed_text = 2;
  void clear_processed_text() ;
  const std::string& processed_text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_processed_text(Arg_&& arg, Args_... args);
  std::string* mutable_processed_text();
  PROTOBUF_NODISCARD std::string* release_processed_text();
  void set_allocated_processed_text(std::string* value);

  private:
  const std::string& _internal_processed_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processed_text(
      const std::string& value);
  std::string* _internal_mutable_processed_text();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.tts.SynthesizeSpeechResponseMetadata)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      75, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> predicted_durations_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::google::protobuf::internal::ArenaStringPtr processed_text_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5ftts_2eproto;
};// -------------------------------------------------------------------

class RivaSynthesisConfigResponse_Config_ParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          RivaSynthesisConfigResponse_Config_ParametersEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      RivaSynthesisConfigResponse_Config_ParametersEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  RivaSynthesisConfigResponse_Config_ParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RivaSynthesisConfigResponse_Config_ParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit RivaSynthesisConfigResponse_Config_ParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const RivaSynthesisConfigResponse_Config_ParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const RivaSynthesisConfigResponse_Config_ParametersEntry_DoNotUse*>(
        &_RivaSynthesisConfigResponse_Config_ParametersEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "nvidia.riva.tts.RivaSynthesisConfigResponse.Config.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "nvidia.riva.tts.RivaSynthesisConfigResponse.Config.ParametersEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_riva_2fproto_2friva_5ftts_2eproto;
};
// -------------------------------------------------------------------

class RivaSynthesisConfigRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.tts.RivaSynthesisConfigRequest) */ {
 public:
  inline RivaSynthesisConfigRequest() : RivaSynthesisConfigRequest(nullptr) {}
  ~RivaSynthesisConfigRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RivaSynthesisConfigRequest(::google::protobuf::internal::ConstantInitialized);

  inline RivaSynthesisConfigRequest(const RivaSynthesisConfigRequest& from)
      : RivaSynthesisConfigRequest(nullptr, from) {}
  RivaSynthesisConfigRequest(RivaSynthesisConfigRequest&& from) noexcept
    : RivaSynthesisConfigRequest() {
    *this = ::std::move(from);
  }

  inline RivaSynthesisConfigRequest& operator=(const RivaSynthesisConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RivaSynthesisConfigRequest& operator=(RivaSynthesisConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RivaSynthesisConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RivaSynthesisConfigRequest* internal_default_instance() {
    return reinterpret_cast<const RivaSynthesisConfigRequest*>(
               &_RivaSynthesisConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RivaSynthesisConfigRequest& a, RivaSynthesisConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RivaSynthesisConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RivaSynthesisConfigRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RivaSynthesisConfigRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RivaSynthesisConfigRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RivaSynthesisConfigRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RivaSynthesisConfigRequest& from) {
    RivaSynthesisConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RivaSynthesisConfigRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.tts.RivaSynthesisConfigRequest";
  }
  protected:
  explicit RivaSynthesisConfigRequest(::google::protobuf::Arena* arena);
  RivaSynthesisConfigRequest(::google::protobuf::Arena* arena, const RivaSynthesisConfigRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
  };
  // string model_name = 1;
  void clear_model_name() ;
  const std::string& model_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_name(Arg_&& arg, Args_... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* value);

  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(
      const std::string& value);
  std::string* _internal_mutable_model_name();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.tts.RivaSynthesisConfigRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr model_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5ftts_2eproto;
};// -------------------------------------------------------------------

class SynthesizeSpeechResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.tts.SynthesizeSpeechResponse) */ {
 public:
  inline SynthesizeSpeechResponse() : SynthesizeSpeechResponse(nullptr) {}
  ~SynthesizeSpeechResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SynthesizeSpeechResponse(::google::protobuf::internal::ConstantInitialized);

  inline SynthesizeSpeechResponse(const SynthesizeSpeechResponse& from)
      : SynthesizeSpeechResponse(nullptr, from) {}
  SynthesizeSpeechResponse(SynthesizeSpeechResponse&& from) noexcept
    : SynthesizeSpeechResponse() {
    *this = ::std::move(from);
  }

  inline SynthesizeSpeechResponse& operator=(const SynthesizeSpeechResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SynthesizeSpeechResponse& operator=(SynthesizeSpeechResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SynthesizeSpeechResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SynthesizeSpeechResponse* internal_default_instance() {
    return reinterpret_cast<const SynthesizeSpeechResponse*>(
               &_SynthesizeSpeechResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SynthesizeSpeechResponse& a, SynthesizeSpeechResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SynthesizeSpeechResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SynthesizeSpeechResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SynthesizeSpeechResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SynthesizeSpeechResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SynthesizeSpeechResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SynthesizeSpeechResponse& from) {
    SynthesizeSpeechResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SynthesizeSpeechResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.tts.SynthesizeSpeechResponse";
  }
  protected:
  explicit SynthesizeSpeechResponse(::google::protobuf::Arena* arena);
  SynthesizeSpeechResponse(::google::protobuf::Arena* arena, const SynthesizeSpeechResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioFieldNumber = 1,
    kMetaFieldNumber = 2,
    kIdFieldNumber = 100,
  };
  // bytes audio = 1;
  void clear_audio() ;
  const std::string& audio() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_audio(Arg_&& arg, Args_... args);
  std::string* mutable_audio();
  PROTOBUF_NODISCARD std::string* release_audio();
  void set_allocated_audio(std::string* value);

  private:
  const std::string& _internal_audio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio(
      const std::string& value);
  std::string* _internal_mutable_audio();

  public:
  // .nvidia.riva.tts.SynthesizeSpeechResponseMetadata meta = 2;
  bool has_meta() const;
  void clear_meta() ;
  const ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata& meta() const;
  PROTOBUF_NODISCARD ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* release_meta();
  ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* mutable_meta();
  void set_allocated_meta(::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* value);
  void unsafe_arena_set_allocated_meta(::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* value);
  ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* unsafe_arena_release_meta();

  private:
  const ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata& _internal_meta() const;
  ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* _internal_mutable_meta();

  public:
  // .nvidia.riva.RequestId id = 100;
  bool has_id() const;
  void clear_id() ;
  const ::nvidia::riva::RequestId& id() const;
  PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  ::nvidia::riva::RequestId* mutable_id();
  void set_allocated_id(::nvidia::riva::RequestId* value);
  void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.tts.SynthesizeSpeechResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr audio_;
    ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* meta_;
    ::nvidia::riva::RequestId* id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5ftts_2eproto;
};// -------------------------------------------------------------------

class SynthesizeSpeechRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.tts.SynthesizeSpeechRequest) */ {
 public:
  inline SynthesizeSpeechRequest() : SynthesizeSpeechRequest(nullptr) {}
  ~SynthesizeSpeechRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SynthesizeSpeechRequest(::google::protobuf::internal::ConstantInitialized);

  inline SynthesizeSpeechRequest(const SynthesizeSpeechRequest& from)
      : SynthesizeSpeechRequest(nullptr, from) {}
  SynthesizeSpeechRequest(SynthesizeSpeechRequest&& from) noexcept
    : SynthesizeSpeechRequest() {
    *this = ::std::move(from);
  }

  inline SynthesizeSpeechRequest& operator=(const SynthesizeSpeechRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SynthesizeSpeechRequest& operator=(SynthesizeSpeechRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SynthesizeSpeechRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SynthesizeSpeechRequest* internal_default_instance() {
    return reinterpret_cast<const SynthesizeSpeechRequest*>(
               &_SynthesizeSpeechRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SynthesizeSpeechRequest& a, SynthesizeSpeechRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SynthesizeSpeechRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SynthesizeSpeechRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SynthesizeSpeechRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SynthesizeSpeechRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SynthesizeSpeechRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SynthesizeSpeechRequest& from) {
    SynthesizeSpeechRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SynthesizeSpeechRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.tts.SynthesizeSpeechRequest";
  }
  protected:
  explicit SynthesizeSpeechRequest(::google::protobuf::Arena* arena);
  SynthesizeSpeechRequest(::google::protobuf::Arena* arena, const SynthesizeSpeechRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kLanguageCodeFieldNumber = 2,
    kVoiceNameFieldNumber = 5,
    kCustomDictionaryFieldNumber = 7,
    kZeroShotDataFieldNumber = 6,
    kIdFieldNumber = 100,
    kEncodingFieldNumber = 3,
    kSampleRateHzFieldNumber = 4,
  };
  // string text = 1;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // string language_code = 2;
  void clear_language_code() ;
  const std::string& language_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_language_code(Arg_&& arg, Args_... args);
  std::string* mutable_language_code();
  PROTOBUF_NODISCARD std::string* release_language_code();
  void set_allocated_language_code(std::string* value);

  private:
  const std::string& _internal_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_code(
      const std::string& value);
  std::string* _internal_mutable_language_code();

  public:
  // string voice_name = 5;
  void clear_voice_name() ;
  const std::string& voice_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_voice_name(Arg_&& arg, Args_... args);
  std::string* mutable_voice_name();
  PROTOBUF_NODISCARD std::string* release_voice_name();
  void set_allocated_voice_name(std::string* value);

  private:
  const std::string& _internal_voice_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_voice_name(
      const std::string& value);
  std::string* _internal_mutable_voice_name();

  public:
  // string custom_dictionary = 7;
  void clear_custom_dictionary() ;
  const std::string& custom_dictionary() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_custom_dictionary(Arg_&& arg, Args_... args);
  std::string* mutable_custom_dictionary();
  PROTOBUF_NODISCARD std::string* release_custom_dictionary();
  void set_allocated_custom_dictionary(std::string* value);

  private:
  const std::string& _internal_custom_dictionary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_custom_dictionary(
      const std::string& value);
  std::string* _internal_mutable_custom_dictionary();

  public:
  // .nvidia.riva.tts.ZeroShotData zero_shot_data = 6;
  bool has_zero_shot_data() const;
  void clear_zero_shot_data() ;
  const ::nvidia::riva::tts::ZeroShotData& zero_shot_data() const;
  PROTOBUF_NODISCARD ::nvidia::riva::tts::ZeroShotData* release_zero_shot_data();
  ::nvidia::riva::tts::ZeroShotData* mutable_zero_shot_data();
  void set_allocated_zero_shot_data(::nvidia::riva::tts::ZeroShotData* value);
  void unsafe_arena_set_allocated_zero_shot_data(::nvidia::riva::tts::ZeroShotData* value);
  ::nvidia::riva::tts::ZeroShotData* unsafe_arena_release_zero_shot_data();

  private:
  const ::nvidia::riva::tts::ZeroShotData& _internal_zero_shot_data() const;
  ::nvidia::riva::tts::ZeroShotData* _internal_mutable_zero_shot_data();

  public:
  // .nvidia.riva.RequestId id = 100;
  bool has_id() const;
  void clear_id() ;
  const ::nvidia::riva::RequestId& id() const;
  PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  ::nvidia::riva::RequestId* mutable_id();
  void set_allocated_id(::nvidia::riva::RequestId* value);
  void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // .nvidia.riva.AudioEncoding encoding = 3;
  void clear_encoding() ;
  ::nvidia::riva::AudioEncoding encoding() const;
  void set_encoding(::nvidia::riva::AudioEncoding value);

  private:
  ::nvidia::riva::AudioEncoding _internal_encoding() const;
  void _internal_set_encoding(::nvidia::riva::AudioEncoding value);

  public:
  // int32 sample_rate_hz = 4;
  void clear_sample_rate_hz() ;
  ::int32_t sample_rate_hz() const;
  void set_sample_rate_hz(::int32_t value);

  private:
  ::int32_t _internal_sample_rate_hz() const;
  void _internal_set_sample_rate_hz(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.tts.SynthesizeSpeechRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 2,
      100, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::google::protobuf::internal::ArenaStringPtr language_code_;
    ::google::protobuf::internal::ArenaStringPtr voice_name_;
    ::google::protobuf::internal::ArenaStringPtr custom_dictionary_;
    ::nvidia::riva::tts::ZeroShotData* zero_shot_data_;
    ::nvidia::riva::RequestId* id_;
    int encoding_;
    ::int32_t sample_rate_hz_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5ftts_2eproto;
};// -------------------------------------------------------------------

class RivaSynthesisConfigResponse_Config final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.tts.RivaSynthesisConfigResponse.Config) */ {
 public:
  inline RivaSynthesisConfigResponse_Config() : RivaSynthesisConfigResponse_Config(nullptr) {}
  ~RivaSynthesisConfigResponse_Config() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RivaSynthesisConfigResponse_Config(::google::protobuf::internal::ConstantInitialized);

  inline RivaSynthesisConfigResponse_Config(const RivaSynthesisConfigResponse_Config& from)
      : RivaSynthesisConfigResponse_Config(nullptr, from) {}
  RivaSynthesisConfigResponse_Config(RivaSynthesisConfigResponse_Config&& from) noexcept
    : RivaSynthesisConfigResponse_Config() {
    *this = ::std::move(from);
  }

  inline RivaSynthesisConfigResponse_Config& operator=(const RivaSynthesisConfigResponse_Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline RivaSynthesisConfigResponse_Config& operator=(RivaSynthesisConfigResponse_Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RivaSynthesisConfigResponse_Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const RivaSynthesisConfigResponse_Config* internal_default_instance() {
    return reinterpret_cast<const RivaSynthesisConfigResponse_Config*>(
               &_RivaSynthesisConfigResponse_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RivaSynthesisConfigResponse_Config& a, RivaSynthesisConfigResponse_Config& b) {
    a.Swap(&b);
  }
  inline void Swap(RivaSynthesisConfigResponse_Config* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RivaSynthesisConfigResponse_Config* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RivaSynthesisConfigResponse_Config* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RivaSynthesisConfigResponse_Config>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RivaSynthesisConfigResponse_Config& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RivaSynthesisConfigResponse_Config& from) {
    RivaSynthesisConfigResponse_Config::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RivaSynthesisConfigResponse_Config* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.tts.RivaSynthesisConfigResponse.Config";
  }
  protected:
  explicit RivaSynthesisConfigResponse_Config(::google::protobuf::Arena* arena);
  RivaSynthesisConfigResponse_Config(::google::protobuf::Arena* arena, const RivaSynthesisConfigResponse_Config& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 2,
    kModelNameFieldNumber = 1,
  };
  // map<string, string> parameters = 2;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_parameters();

  public:
  // string model_name = 1;
  void clear_model_name() ;
  const std::string& model_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_name(Arg_&& arg, Args_... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* value);

  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(
      const std::string& value);
  std::string* _internal_mutable_model_name();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.tts.RivaSynthesisConfigResponse.Config)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      79, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<RivaSynthesisConfigResponse_Config_ParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        parameters_;
    ::google::protobuf::internal::ArenaStringPtr model_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5ftts_2eproto;
};// -------------------------------------------------------------------

class RivaSynthesisConfigResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.tts.RivaSynthesisConfigResponse) */ {
 public:
  inline RivaSynthesisConfigResponse() : RivaSynthesisConfigResponse(nullptr) {}
  ~RivaSynthesisConfigResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RivaSynthesisConfigResponse(::google::protobuf::internal::ConstantInitialized);

  inline RivaSynthesisConfigResponse(const RivaSynthesisConfigResponse& from)
      : RivaSynthesisConfigResponse(nullptr, from) {}
  RivaSynthesisConfigResponse(RivaSynthesisConfigResponse&& from) noexcept
    : RivaSynthesisConfigResponse() {
    *this = ::std::move(from);
  }

  inline RivaSynthesisConfigResponse& operator=(const RivaSynthesisConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RivaSynthesisConfigResponse& operator=(RivaSynthesisConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RivaSynthesisConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RivaSynthesisConfigResponse* internal_default_instance() {
    return reinterpret_cast<const RivaSynthesisConfigResponse*>(
               &_RivaSynthesisConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RivaSynthesisConfigResponse& a, RivaSynthesisConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RivaSynthesisConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RivaSynthesisConfigResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RivaSynthesisConfigResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RivaSynthesisConfigResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RivaSynthesisConfigResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RivaSynthesisConfigResponse& from) {
    RivaSynthesisConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RivaSynthesisConfigResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.tts.RivaSynthesisConfigResponse";
  }
  protected:
  explicit RivaSynthesisConfigResponse(::google::protobuf::Arena* arena);
  RivaSynthesisConfigResponse(::google::protobuf::Arena* arena, const RivaSynthesisConfigResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Config = RivaSynthesisConfigResponse_Config;

  // accessors -------------------------------------------------------

  enum : int {
    kModelConfigFieldNumber = 1,
  };
  // repeated .nvidia.riva.tts.RivaSynthesisConfigResponse.Config model_config = 1;
  int model_config_size() const;
  private:
  int _internal_model_config_size() const;

  public:
  void clear_model_config() ;
  ::nvidia::riva::tts::RivaSynthesisConfigResponse_Config* mutable_model_config(int index);
  ::google::protobuf::RepeatedPtrField< ::nvidia::riva::tts::RivaSynthesisConfigResponse_Config >*
      mutable_model_config();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::tts::RivaSynthesisConfigResponse_Config>& _internal_model_config() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::tts::RivaSynthesisConfigResponse_Config>* _internal_mutable_model_config();
  public:
  const ::nvidia::riva::tts::RivaSynthesisConfigResponse_Config& model_config(int index) const;
  ::nvidia::riva::tts::RivaSynthesisConfigResponse_Config* add_model_config();
  const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::tts::RivaSynthesisConfigResponse_Config >&
      model_config() const;
  // @@protoc_insertion_point(class_scope:nvidia.riva.tts.RivaSynthesisConfigResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::tts::RivaSynthesisConfigResponse_Config > model_config_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5ftts_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RivaSynthesisConfigRequest

// string model_name = 1;
inline void RivaSynthesisConfigRequest::clear_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& RivaSynthesisConfigRequest::model_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.RivaSynthesisConfigRequest.model_name)
  return _internal_model_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RivaSynthesisConfigRequest::set_model_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.RivaSynthesisConfigRequest.model_name)
}
inline std::string* RivaSynthesisConfigRequest::mutable_model_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.RivaSynthesisConfigRequest.model_name)
  return _s;
}
inline const std::string& RivaSynthesisConfigRequest::_internal_model_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.model_name_.Get();
}
inline void RivaSynthesisConfigRequest::_internal_set_model_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_name_.Set(value, GetArena());
}
inline std::string* RivaSynthesisConfigRequest::_internal_mutable_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.model_name_.Mutable( GetArena());
}
inline std::string* RivaSynthesisConfigRequest::release_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.tts.RivaSynthesisConfigRequest.model_name)
  return _impl_.model_name_.Release();
}
inline void RivaSynthesisConfigRequest::set_allocated_model_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.model_name_.IsDefault()) {
          _impl_.model_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.tts.RivaSynthesisConfigRequest.model_name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RivaSynthesisConfigResponse_Config

// string model_name = 1;
inline void RivaSynthesisConfigResponse_Config::clear_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& RivaSynthesisConfigResponse_Config::model_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.RivaSynthesisConfigResponse.Config.model_name)
  return _internal_model_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RivaSynthesisConfigResponse_Config::set_model_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.RivaSynthesisConfigResponse.Config.model_name)
}
inline std::string* RivaSynthesisConfigResponse_Config::mutable_model_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.RivaSynthesisConfigResponse.Config.model_name)
  return _s;
}
inline const std::string& RivaSynthesisConfigResponse_Config::_internal_model_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.model_name_.Get();
}
inline void RivaSynthesisConfigResponse_Config::_internal_set_model_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_name_.Set(value, GetArena());
}
inline std::string* RivaSynthesisConfigResponse_Config::_internal_mutable_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.model_name_.Mutable( GetArena());
}
inline std::string* RivaSynthesisConfigResponse_Config::release_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.tts.RivaSynthesisConfigResponse.Config.model_name)
  return _impl_.model_name_.Release();
}
inline void RivaSynthesisConfigResponse_Config::set_allocated_model_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.model_name_.IsDefault()) {
          _impl_.model_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.tts.RivaSynthesisConfigResponse.Config.model_name)
}

// map<string, string> parameters = 2;
inline int RivaSynthesisConfigResponse_Config::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int RivaSynthesisConfigResponse_Config::parameters_size() const {
  return _internal_parameters_size();
}
inline void RivaSynthesisConfigResponse_Config::clear_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& RivaSynthesisConfigResponse_Config::_internal_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& RivaSynthesisConfigResponse_Config::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:nvidia.riva.tts.RivaSynthesisConfigResponse.Config.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* RivaSynthesisConfigResponse_Config::_internal_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* RivaSynthesisConfigResponse_Config::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:nvidia.riva.tts.RivaSynthesisConfigResponse.Config.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// RivaSynthesisConfigResponse

// repeated .nvidia.riva.tts.RivaSynthesisConfigResponse.Config model_config = 1;
inline int RivaSynthesisConfigResponse::_internal_model_config_size() const {
  return _internal_model_config().size();
}
inline int RivaSynthesisConfigResponse::model_config_size() const {
  return _internal_model_config_size();
}
inline void RivaSynthesisConfigResponse::clear_model_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_config_.Clear();
}
inline ::nvidia::riva::tts::RivaSynthesisConfigResponse_Config* RivaSynthesisConfigResponse::mutable_model_config(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.RivaSynthesisConfigResponse.model_config)
  return _internal_mutable_model_config()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::tts::RivaSynthesisConfigResponse_Config>* RivaSynthesisConfigResponse::mutable_model_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.tts.RivaSynthesisConfigResponse.model_config)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_model_config();
}
inline const ::nvidia::riva::tts::RivaSynthesisConfigResponse_Config& RivaSynthesisConfigResponse::model_config(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.RivaSynthesisConfigResponse.model_config)
  return _internal_model_config().Get(index);
}
inline ::nvidia::riva::tts::RivaSynthesisConfigResponse_Config* RivaSynthesisConfigResponse::add_model_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::tts::RivaSynthesisConfigResponse_Config* _add = _internal_mutable_model_config()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.tts.RivaSynthesisConfigResponse.model_config)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::tts::RivaSynthesisConfigResponse_Config>& RivaSynthesisConfigResponse::model_config() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.tts.RivaSynthesisConfigResponse.model_config)
  return _internal_model_config();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::tts::RivaSynthesisConfigResponse_Config>&
RivaSynthesisConfigResponse::_internal_model_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.model_config_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::tts::RivaSynthesisConfigResponse_Config>*
RivaSynthesisConfigResponse::_internal_mutable_model_config() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.model_config_;
}

// -------------------------------------------------------------------

// ZeroShotData

// bytes audio_prompt = 1;
inline void ZeroShotData::clear_audio_prompt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_prompt_.ClearToEmpty();
}
inline const std::string& ZeroShotData::audio_prompt() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.ZeroShotData.audio_prompt)
  return _internal_audio_prompt();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ZeroShotData::set_audio_prompt(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.audio_prompt_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.ZeroShotData.audio_prompt)
}
inline std::string* ZeroShotData::mutable_audio_prompt() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_audio_prompt();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.ZeroShotData.audio_prompt)
  return _s;
}
inline const std::string& ZeroShotData::_internal_audio_prompt() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_prompt_.Get();
}
inline void ZeroShotData::_internal_set_audio_prompt(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.audio_prompt_.Set(value, GetArena());
}
inline std::string* ZeroShotData::_internal_mutable_audio_prompt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.audio_prompt_.Mutable( GetArena());
}
inline std::string* ZeroShotData::release_audio_prompt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.tts.ZeroShotData.audio_prompt)
  return _impl_.audio_prompt_.Release();
}
inline void ZeroShotData::set_allocated_audio_prompt(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_prompt_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.audio_prompt_.IsDefault()) {
          _impl_.audio_prompt_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.tts.ZeroShotData.audio_prompt)
}

// int32 sample_rate_hz = 2;
inline void ZeroShotData::clear_sample_rate_hz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_rate_hz_ = 0;
}
inline ::int32_t ZeroShotData::sample_rate_hz() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.ZeroShotData.sample_rate_hz)
  return _internal_sample_rate_hz();
}
inline void ZeroShotData::set_sample_rate_hz(::int32_t value) {
  _internal_set_sample_rate_hz(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.ZeroShotData.sample_rate_hz)
}
inline ::int32_t ZeroShotData::_internal_sample_rate_hz() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sample_rate_hz_;
}
inline void ZeroShotData::_internal_set_sample_rate_hz(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sample_rate_hz_ = value;
}

// .nvidia.riva.AudioEncoding encoding = 3;
inline void ZeroShotData::clear_encoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encoding_ = 0;
}
inline ::nvidia::riva::AudioEncoding ZeroShotData::encoding() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.ZeroShotData.encoding)
  return _internal_encoding();
}
inline void ZeroShotData::set_encoding(::nvidia::riva::AudioEncoding value) {
  _internal_set_encoding(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.ZeroShotData.encoding)
}
inline ::nvidia::riva::AudioEncoding ZeroShotData::_internal_encoding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::nvidia::riva::AudioEncoding>(_impl_.encoding_);
}
inline void ZeroShotData::_internal_set_encoding(::nvidia::riva::AudioEncoding value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.encoding_ = value;
}

// int32 quality = 4;
inline void ZeroShotData::clear_quality() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quality_ = 0;
}
inline ::int32_t ZeroShotData::quality() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.ZeroShotData.quality)
  return _internal_quality();
}
inline void ZeroShotData::set_quality(::int32_t value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.ZeroShotData.quality)
}
inline ::int32_t ZeroShotData::_internal_quality() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quality_;
}
inline void ZeroShotData::_internal_set_quality(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quality_ = value;
}

// string transcript = 5;
inline void ZeroShotData::clear_transcript() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transcript_.ClearToEmpty();
}
inline const std::string& ZeroShotData::transcript() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.ZeroShotData.transcript)
  return _internal_transcript();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ZeroShotData::set_transcript(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.transcript_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.ZeroShotData.transcript)
}
inline std::string* ZeroShotData::mutable_transcript() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transcript();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.ZeroShotData.transcript)
  return _s;
}
inline const std::string& ZeroShotData::_internal_transcript() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transcript_.Get();
}
inline void ZeroShotData::_internal_set_transcript(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.transcript_.Set(value, GetArena());
}
inline std::string* ZeroShotData::_internal_mutable_transcript() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.transcript_.Mutable( GetArena());
}
inline std::string* ZeroShotData::release_transcript() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.tts.ZeroShotData.transcript)
  return _impl_.transcript_.Release();
}
inline void ZeroShotData::set_allocated_transcript(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transcript_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transcript_.IsDefault()) {
          _impl_.transcript_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.tts.ZeroShotData.transcript)
}

// -------------------------------------------------------------------

// SynthesizeSpeechRequest

// string text = 1;
inline void SynthesizeSpeechRequest::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& SynthesizeSpeechRequest::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.SynthesizeSpeechRequest.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SynthesizeSpeechRequest::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.SynthesizeSpeechRequest.text)
}
inline std::string* SynthesizeSpeechRequest::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.SynthesizeSpeechRequest.text)
  return _s;
}
inline const std::string& SynthesizeSpeechRequest::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void SynthesizeSpeechRequest::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(value, GetArena());
}
inline std::string* SynthesizeSpeechRequest::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* SynthesizeSpeechRequest::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.tts.SynthesizeSpeechRequest.text)
  return _impl_.text_.Release();
}
inline void SynthesizeSpeechRequest::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.tts.SynthesizeSpeechRequest.text)
}

// string language_code = 2;
inline void SynthesizeSpeechRequest::clear_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_code_.ClearToEmpty();
}
inline const std::string& SynthesizeSpeechRequest::language_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.SynthesizeSpeechRequest.language_code)
  return _internal_language_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SynthesizeSpeechRequest::set_language_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.SynthesizeSpeechRequest.language_code)
}
inline std::string* SynthesizeSpeechRequest::mutable_language_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_language_code();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.SynthesizeSpeechRequest.language_code)
  return _s;
}
inline const std::string& SynthesizeSpeechRequest::_internal_language_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.language_code_.Get();
}
inline void SynthesizeSpeechRequest::_internal_set_language_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_code_.Set(value, GetArena());
}
inline std::string* SynthesizeSpeechRequest::_internal_mutable_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.language_code_.Mutable( GetArena());
}
inline std::string* SynthesizeSpeechRequest::release_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.tts.SynthesizeSpeechRequest.language_code)
  return _impl_.language_code_.Release();
}
inline void SynthesizeSpeechRequest::set_allocated_language_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.language_code_.IsDefault()) {
          _impl_.language_code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.tts.SynthesizeSpeechRequest.language_code)
}

// .nvidia.riva.AudioEncoding encoding = 3;
inline void SynthesizeSpeechRequest::clear_encoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encoding_ = 0;
}
inline ::nvidia::riva::AudioEncoding SynthesizeSpeechRequest::encoding() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.SynthesizeSpeechRequest.encoding)
  return _internal_encoding();
}
inline void SynthesizeSpeechRequest::set_encoding(::nvidia::riva::AudioEncoding value) {
  _internal_set_encoding(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.SynthesizeSpeechRequest.encoding)
}
inline ::nvidia::riva::AudioEncoding SynthesizeSpeechRequest::_internal_encoding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::nvidia::riva::AudioEncoding>(_impl_.encoding_);
}
inline void SynthesizeSpeechRequest::_internal_set_encoding(::nvidia::riva::AudioEncoding value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.encoding_ = value;
}

// int32 sample_rate_hz = 4;
inline void SynthesizeSpeechRequest::clear_sample_rate_hz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_rate_hz_ = 0;
}
inline ::int32_t SynthesizeSpeechRequest::sample_rate_hz() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.SynthesizeSpeechRequest.sample_rate_hz)
  return _internal_sample_rate_hz();
}
inline void SynthesizeSpeechRequest::set_sample_rate_hz(::int32_t value) {
  _internal_set_sample_rate_hz(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.SynthesizeSpeechRequest.sample_rate_hz)
}
inline ::int32_t SynthesizeSpeechRequest::_internal_sample_rate_hz() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sample_rate_hz_;
}
inline void SynthesizeSpeechRequest::_internal_set_sample_rate_hz(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sample_rate_hz_ = value;
}

// string voice_name = 5;
inline void SynthesizeSpeechRequest::clear_voice_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.voice_name_.ClearToEmpty();
}
inline const std::string& SynthesizeSpeechRequest::voice_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.SynthesizeSpeechRequest.voice_name)
  return _internal_voice_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SynthesizeSpeechRequest::set_voice_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.voice_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.SynthesizeSpeechRequest.voice_name)
}
inline std::string* SynthesizeSpeechRequest::mutable_voice_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_voice_name();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.SynthesizeSpeechRequest.voice_name)
  return _s;
}
inline const std::string& SynthesizeSpeechRequest::_internal_voice_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.voice_name_.Get();
}
inline void SynthesizeSpeechRequest::_internal_set_voice_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.voice_name_.Set(value, GetArena());
}
inline std::string* SynthesizeSpeechRequest::_internal_mutable_voice_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.voice_name_.Mutable( GetArena());
}
inline std::string* SynthesizeSpeechRequest::release_voice_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.tts.SynthesizeSpeechRequest.voice_name)
  return _impl_.voice_name_.Release();
}
inline void SynthesizeSpeechRequest::set_allocated_voice_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.voice_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.voice_name_.IsDefault()) {
          _impl_.voice_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.tts.SynthesizeSpeechRequest.voice_name)
}

// .nvidia.riva.tts.ZeroShotData zero_shot_data = 6;
inline bool SynthesizeSpeechRequest::has_zero_shot_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.zero_shot_data_ != nullptr);
  return value;
}
inline void SynthesizeSpeechRequest::clear_zero_shot_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.zero_shot_data_ != nullptr) _impl_.zero_shot_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nvidia::riva::tts::ZeroShotData& SynthesizeSpeechRequest::_internal_zero_shot_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::tts::ZeroShotData* p = _impl_.zero_shot_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::tts::ZeroShotData&>(::nvidia::riva::tts::_ZeroShotData_default_instance_);
}
inline const ::nvidia::riva::tts::ZeroShotData& SynthesizeSpeechRequest::zero_shot_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.SynthesizeSpeechRequest.zero_shot_data)
  return _internal_zero_shot_data();
}
inline void SynthesizeSpeechRequest::unsafe_arena_set_allocated_zero_shot_data(::nvidia::riva::tts::ZeroShotData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.zero_shot_data_);
  }
  _impl_.zero_shot_data_ = reinterpret_cast<::nvidia::riva::tts::ZeroShotData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.tts.SynthesizeSpeechRequest.zero_shot_data)
}
inline ::nvidia::riva::tts::ZeroShotData* SynthesizeSpeechRequest::release_zero_shot_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::tts::ZeroShotData* released = _impl_.zero_shot_data_;
  _impl_.zero_shot_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::tts::ZeroShotData* SynthesizeSpeechRequest::unsafe_arena_release_zero_shot_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.tts.SynthesizeSpeechRequest.zero_shot_data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::tts::ZeroShotData* temp = _impl_.zero_shot_data_;
  _impl_.zero_shot_data_ = nullptr;
  return temp;
}
inline ::nvidia::riva::tts::ZeroShotData* SynthesizeSpeechRequest::_internal_mutable_zero_shot_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.zero_shot_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::tts::ZeroShotData>(GetArena());
    _impl_.zero_shot_data_ = reinterpret_cast<::nvidia::riva::tts::ZeroShotData*>(p);
  }
  return _impl_.zero_shot_data_;
}
inline ::nvidia::riva::tts::ZeroShotData* SynthesizeSpeechRequest::mutable_zero_shot_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::tts::ZeroShotData* _msg = _internal_mutable_zero_shot_data();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.SynthesizeSpeechRequest.zero_shot_data)
  return _msg;
}
inline void SynthesizeSpeechRequest::set_allocated_zero_shot_data(::nvidia::riva::tts::ZeroShotData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::nvidia::riva::tts::ZeroShotData*>(_impl_.zero_shot_data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::nvidia::riva::tts::ZeroShotData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.zero_shot_data_ = reinterpret_cast<::nvidia::riva::tts::ZeroShotData*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.tts.SynthesizeSpeechRequest.zero_shot_data)
}

// string custom_dictionary = 7;
inline void SynthesizeSpeechRequest::clear_custom_dictionary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.custom_dictionary_.ClearToEmpty();
}
inline const std::string& SynthesizeSpeechRequest::custom_dictionary() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.SynthesizeSpeechRequest.custom_dictionary)
  return _internal_custom_dictionary();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SynthesizeSpeechRequest::set_custom_dictionary(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.custom_dictionary_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.SynthesizeSpeechRequest.custom_dictionary)
}
inline std::string* SynthesizeSpeechRequest::mutable_custom_dictionary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_custom_dictionary();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.SynthesizeSpeechRequest.custom_dictionary)
  return _s;
}
inline const std::string& SynthesizeSpeechRequest::_internal_custom_dictionary() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.custom_dictionary_.Get();
}
inline void SynthesizeSpeechRequest::_internal_set_custom_dictionary(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.custom_dictionary_.Set(value, GetArena());
}
inline std::string* SynthesizeSpeechRequest::_internal_mutable_custom_dictionary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.custom_dictionary_.Mutable( GetArena());
}
inline std::string* SynthesizeSpeechRequest::release_custom_dictionary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.tts.SynthesizeSpeechRequest.custom_dictionary)
  return _impl_.custom_dictionary_.Release();
}
inline void SynthesizeSpeechRequest::set_allocated_custom_dictionary(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.custom_dictionary_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.custom_dictionary_.IsDefault()) {
          _impl_.custom_dictionary_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.tts.SynthesizeSpeechRequest.custom_dictionary)
}

// .nvidia.riva.RequestId id = 100;
inline bool SynthesizeSpeechRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& SynthesizeSpeechRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& SynthesizeSpeechRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.SynthesizeSpeechRequest.id)
  return _internal_id();
}
inline void SynthesizeSpeechRequest::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.tts.SynthesizeSpeechRequest.id)
}
inline ::nvidia::riva::RequestId* SynthesizeSpeechRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* SynthesizeSpeechRequest::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.tts.SynthesizeSpeechRequest.id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* SynthesizeSpeechRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* SynthesizeSpeechRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.SynthesizeSpeechRequest.id)
  return _msg;
}
inline void SynthesizeSpeechRequest::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.tts.SynthesizeSpeechRequest.id)
}

// -------------------------------------------------------------------

// SynthesizeSpeechResponseMetadata

// string text = 1;
inline void SynthesizeSpeechResponseMetadata::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& SynthesizeSpeechResponseMetadata::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.SynthesizeSpeechResponseMetadata.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SynthesizeSpeechResponseMetadata::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.SynthesizeSpeechResponseMetadata.text)
}
inline std::string* SynthesizeSpeechResponseMetadata::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.SynthesizeSpeechResponseMetadata.text)
  return _s;
}
inline const std::string& SynthesizeSpeechResponseMetadata::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void SynthesizeSpeechResponseMetadata::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(value, GetArena());
}
inline std::string* SynthesizeSpeechResponseMetadata::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* SynthesizeSpeechResponseMetadata::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.tts.SynthesizeSpeechResponseMetadata.text)
  return _impl_.text_.Release();
}
inline void SynthesizeSpeechResponseMetadata::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.tts.SynthesizeSpeechResponseMetadata.text)
}

// string processed_text = 2;
inline void SynthesizeSpeechResponseMetadata::clear_processed_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.processed_text_.ClearToEmpty();
}
inline const std::string& SynthesizeSpeechResponseMetadata::processed_text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.SynthesizeSpeechResponseMetadata.processed_text)
  return _internal_processed_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SynthesizeSpeechResponseMetadata::set_processed_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.processed_text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.SynthesizeSpeechResponseMetadata.processed_text)
}
inline std::string* SynthesizeSpeechResponseMetadata::mutable_processed_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_processed_text();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.SynthesizeSpeechResponseMetadata.processed_text)
  return _s;
}
inline const std::string& SynthesizeSpeechResponseMetadata::_internal_processed_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.processed_text_.Get();
}
inline void SynthesizeSpeechResponseMetadata::_internal_set_processed_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.processed_text_.Set(value, GetArena());
}
inline std::string* SynthesizeSpeechResponseMetadata::_internal_mutable_processed_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.processed_text_.Mutable( GetArena());
}
inline std::string* SynthesizeSpeechResponseMetadata::release_processed_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.tts.SynthesizeSpeechResponseMetadata.processed_text)
  return _impl_.processed_text_.Release();
}
inline void SynthesizeSpeechResponseMetadata::set_allocated_processed_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.processed_text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.processed_text_.IsDefault()) {
          _impl_.processed_text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.tts.SynthesizeSpeechResponseMetadata.processed_text)
}

// repeated float predicted_durations = 8;
inline int SynthesizeSpeechResponseMetadata::_internal_predicted_durations_size() const {
  return _internal_predicted_durations().size();
}
inline int SynthesizeSpeechResponseMetadata::predicted_durations_size() const {
  return _internal_predicted_durations_size();
}
inline void SynthesizeSpeechResponseMetadata::clear_predicted_durations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.predicted_durations_.Clear();
}
inline float SynthesizeSpeechResponseMetadata::predicted_durations(int index) const {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.SynthesizeSpeechResponseMetadata.predicted_durations)
  return _internal_predicted_durations().Get(index);
}
inline void SynthesizeSpeechResponseMetadata::set_predicted_durations(int index, float value) {
  _internal_mutable_predicted_durations()->Set(index, value);
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.SynthesizeSpeechResponseMetadata.predicted_durations)
}
inline void SynthesizeSpeechResponseMetadata::add_predicted_durations(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_predicted_durations()->Add(value);
  // @@protoc_insertion_point(field_add:nvidia.riva.tts.SynthesizeSpeechResponseMetadata.predicted_durations)
}
inline const ::google::protobuf::RepeatedField<float>& SynthesizeSpeechResponseMetadata::predicted_durations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.tts.SynthesizeSpeechResponseMetadata.predicted_durations)
  return _internal_predicted_durations();
}
inline ::google::protobuf::RepeatedField<float>* SynthesizeSpeechResponseMetadata::mutable_predicted_durations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.tts.SynthesizeSpeechResponseMetadata.predicted_durations)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_predicted_durations();
}
inline const ::google::protobuf::RepeatedField<float>& SynthesizeSpeechResponseMetadata::_internal_predicted_durations()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.predicted_durations_;
}
inline ::google::protobuf::RepeatedField<float>* SynthesizeSpeechResponseMetadata::_internal_mutable_predicted_durations() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.predicted_durations_;
}

// -------------------------------------------------------------------

// SynthesizeSpeechResponse

// bytes audio = 1;
inline void SynthesizeSpeechResponse::clear_audio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_.ClearToEmpty();
}
inline const std::string& SynthesizeSpeechResponse::audio() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.SynthesizeSpeechResponse.audio)
  return _internal_audio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SynthesizeSpeechResponse::set_audio(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.audio_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.tts.SynthesizeSpeechResponse.audio)
}
inline std::string* SynthesizeSpeechResponse::mutable_audio() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.SynthesizeSpeechResponse.audio)
  return _s;
}
inline const std::string& SynthesizeSpeechResponse::_internal_audio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_.Get();
}
inline void SynthesizeSpeechResponse::_internal_set_audio(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.audio_.Set(value, GetArena());
}
inline std::string* SynthesizeSpeechResponse::_internal_mutable_audio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.audio_.Mutable( GetArena());
}
inline std::string* SynthesizeSpeechResponse::release_audio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.tts.SynthesizeSpeechResponse.audio)
  return _impl_.audio_.Release();
}
inline void SynthesizeSpeechResponse::set_allocated_audio(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.audio_.IsDefault()) {
          _impl_.audio_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.tts.SynthesizeSpeechResponse.audio)
}

// .nvidia.riva.tts.SynthesizeSpeechResponseMetadata meta = 2;
inline bool SynthesizeSpeechResponse::has_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.meta_ != nullptr);
  return value;
}
inline void SynthesizeSpeechResponse::clear_meta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.meta_ != nullptr) _impl_.meta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata& SynthesizeSpeechResponse::_internal_meta() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* p = _impl_.meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata&>(::nvidia::riva::tts::_SynthesizeSpeechResponseMetadata_default_instance_);
}
inline const ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata& SynthesizeSpeechResponse::meta() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.SynthesizeSpeechResponse.meta)
  return _internal_meta();
}
inline void SynthesizeSpeechResponse::unsafe_arena_set_allocated_meta(::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.meta_);
  }
  _impl_.meta_ = reinterpret_cast<::nvidia::riva::tts::SynthesizeSpeechResponseMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.tts.SynthesizeSpeechResponse.meta)
}
inline ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* SynthesizeSpeechResponse::release_meta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* released = _impl_.meta_;
  _impl_.meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* SynthesizeSpeechResponse::unsafe_arena_release_meta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.tts.SynthesizeSpeechResponse.meta)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
  return temp;
}
inline ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* SynthesizeSpeechResponse::_internal_mutable_meta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::tts::SynthesizeSpeechResponseMetadata>(GetArena());
    _impl_.meta_ = reinterpret_cast<::nvidia::riva::tts::SynthesizeSpeechResponseMetadata*>(p);
  }
  return _impl_.meta_;
}
inline ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* SynthesizeSpeechResponse::mutable_meta() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.SynthesizeSpeechResponse.meta)
  return _msg;
}
inline void SynthesizeSpeechResponse::set_allocated_meta(::nvidia::riva::tts::SynthesizeSpeechResponseMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::nvidia::riva::tts::SynthesizeSpeechResponseMetadata*>(_impl_.meta_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::nvidia::riva::tts::SynthesizeSpeechResponseMetadata*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.meta_ = reinterpret_cast<::nvidia::riva::tts::SynthesizeSpeechResponseMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.tts.SynthesizeSpeechResponse.meta)
}

// .nvidia.riva.RequestId id = 100;
inline bool SynthesizeSpeechResponse::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& SynthesizeSpeechResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& SynthesizeSpeechResponse::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.tts.SynthesizeSpeechResponse.id)
  return _internal_id();
}
inline void SynthesizeSpeechResponse::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.tts.SynthesizeSpeechResponse.id)
}
inline ::nvidia::riva::RequestId* SynthesizeSpeechResponse::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* SynthesizeSpeechResponse::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.tts.SynthesizeSpeechResponse.id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* SynthesizeSpeechResponse::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* SynthesizeSpeechResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.tts.SynthesizeSpeechResponse.id)
  return _msg;
}
inline void SynthesizeSpeechResponse::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.tts.SynthesizeSpeechResponse.id)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace tts
}  // namespace riva
}  // namespace nvidia


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_riva_2fproto_2friva_5ftts_2eproto_2epb_2eh
