// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: riva/proto/riva_nlp.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_riva_2fproto_2friva_5fnlp_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_riva_2fproto_2friva_5fnlp_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
#include "riva/proto/riva_common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_riva_2fproto_2friva_5fnlp_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_riva_2fproto_2friva_5fnlp_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_riva_2fproto_2friva_5fnlp_2eproto;
namespace nvidia {
namespace riva {
namespace nlp {
class AnalyzeEntitiesOptions;
struct AnalyzeEntitiesOptionsDefaultTypeInternal;
extern AnalyzeEntitiesOptionsDefaultTypeInternal _AnalyzeEntitiesOptions_default_instance_;
class AnalyzeEntitiesRequest;
struct AnalyzeEntitiesRequestDefaultTypeInternal;
extern AnalyzeEntitiesRequestDefaultTypeInternal _AnalyzeEntitiesRequest_default_instance_;
class AnalyzeIntentContext;
struct AnalyzeIntentContextDefaultTypeInternal;
extern AnalyzeIntentContextDefaultTypeInternal _AnalyzeIntentContext_default_instance_;
class AnalyzeIntentOptions;
struct AnalyzeIntentOptionsDefaultTypeInternal;
extern AnalyzeIntentOptionsDefaultTypeInternal _AnalyzeIntentOptions_default_instance_;
class AnalyzeIntentRequest;
struct AnalyzeIntentRequestDefaultTypeInternal;
extern AnalyzeIntentRequestDefaultTypeInternal _AnalyzeIntentRequest_default_instance_;
class AnalyzeIntentResponse;
struct AnalyzeIntentResponseDefaultTypeInternal;
extern AnalyzeIntentResponseDefaultTypeInternal _AnalyzeIntentResponse_default_instance_;
class Classification;
struct ClassificationDefaultTypeInternal;
extern ClassificationDefaultTypeInternal _Classification_default_instance_;
class ClassificationResult;
struct ClassificationResultDefaultTypeInternal;
extern ClassificationResultDefaultTypeInternal _ClassificationResult_default_instance_;
class NLPModelParams;
struct NLPModelParamsDefaultTypeInternal;
extern NLPModelParamsDefaultTypeInternal _NLPModelParams_default_instance_;
class NaturalQueryRequest;
struct NaturalQueryRequestDefaultTypeInternal;
extern NaturalQueryRequestDefaultTypeInternal _NaturalQueryRequest_default_instance_;
class NaturalQueryResponse;
struct NaturalQueryResponseDefaultTypeInternal;
extern NaturalQueryResponseDefaultTypeInternal _NaturalQueryResponse_default_instance_;
class NaturalQueryResult;
struct NaturalQueryResultDefaultTypeInternal;
extern NaturalQueryResultDefaultTypeInternal _NaturalQueryResult_default_instance_;
class RivaNLPConfigRequest;
struct RivaNLPConfigRequestDefaultTypeInternal;
extern RivaNLPConfigRequestDefaultTypeInternal _RivaNLPConfigRequest_default_instance_;
class RivaNLPConfigResponse;
struct RivaNLPConfigResponseDefaultTypeInternal;
extern RivaNLPConfigResponseDefaultTypeInternal _RivaNLPConfigResponse_default_instance_;
class RivaNLPConfigResponse_Config;
struct RivaNLPConfigResponse_ConfigDefaultTypeInternal;
extern RivaNLPConfigResponse_ConfigDefaultTypeInternal _RivaNLPConfigResponse_Config_default_instance_;
class RivaNLPConfigResponse_Config_ParametersEntry_DoNotUse;
struct RivaNLPConfigResponse_Config_ParametersEntry_DoNotUseDefaultTypeInternal;
extern RivaNLPConfigResponse_Config_ParametersEntry_DoNotUseDefaultTypeInternal _RivaNLPConfigResponse_Config_ParametersEntry_DoNotUse_default_instance_;
class Span;
struct SpanDefaultTypeInternal;
extern SpanDefaultTypeInternal _Span_default_instance_;
class TextClassRequest;
struct TextClassRequestDefaultTypeInternal;
extern TextClassRequestDefaultTypeInternal _TextClassRequest_default_instance_;
class TextClassResponse;
struct TextClassResponseDefaultTypeInternal;
extern TextClassResponseDefaultTypeInternal _TextClassResponse_default_instance_;
class TextTransformRequest;
struct TextTransformRequestDefaultTypeInternal;
extern TextTransformRequestDefaultTypeInternal _TextTransformRequest_default_instance_;
class TextTransformResponse;
struct TextTransformResponseDefaultTypeInternal;
extern TextTransformResponseDefaultTypeInternal _TextTransformResponse_default_instance_;
class TokenClassRequest;
struct TokenClassRequestDefaultTypeInternal;
extern TokenClassRequestDefaultTypeInternal _TokenClassRequest_default_instance_;
class TokenClassResponse;
struct TokenClassResponseDefaultTypeInternal;
extern TokenClassResponseDefaultTypeInternal _TokenClassResponse_default_instance_;
class TokenClassSequence;
struct TokenClassSequenceDefaultTypeInternal;
extern TokenClassSequenceDefaultTypeInternal _TokenClassSequence_default_instance_;
class TokenClassValue;
struct TokenClassValueDefaultTypeInternal;
extern TokenClassValueDefaultTypeInternal _TokenClassValue_default_instance_;
}  // namespace nlp
}  // namespace riva
}  // namespace nvidia
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace nvidia {
namespace riva {
namespace nlp {

// ===================================================================


// -------------------------------------------------------------------

class Span final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.Span) */ {
 public:
  inline Span() : Span(nullptr) {}
  ~Span() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Span(::google::protobuf::internal::ConstantInitialized);

  inline Span(const Span& from)
      : Span(nullptr, from) {}
  Span(Span&& from) noexcept
    : Span() {
    *this = ::std::move(from);
  }

  inline Span& operator=(const Span& from) {
    CopyFrom(from);
    return *this;
  }
  inline Span& operator=(Span&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Span& default_instance() {
    return *internal_default_instance();
  }
  static inline const Span* internal_default_instance() {
    return reinterpret_cast<const Span*>(
               &_Span_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Span& a, Span& b) {
    a.Swap(&b);
  }
  inline void Swap(Span* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Span* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Span* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Span>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Span& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Span& from) {
    Span::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Span* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.Span";
  }
  protected:
  explicit Span(::google::protobuf::Arena* arena);
  Span(::google::protobuf::Arena* arena, const Span& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // uint32 start = 1 [deprecated = true];
  [[deprecated]]  void clear_start() ;
  [[deprecated]] ::uint32_t start() const;
  [[deprecated]] void set_start(::uint32_t value);

  private:
  ::uint32_t _internal_start() const;
  void _internal_set_start(::uint32_t value);

  public:
  // uint32 end = 2 [deprecated = true];
  [[deprecated]]  void clear_end() ;
  [[deprecated]] ::uint32_t end() const;
  [[deprecated]] void set_end(::uint32_t value);

  private:
  ::uint32_t _internal_end() const;
  void _internal_set_end(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.Span)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t start_;
    ::uint32_t end_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class RivaNLPConfigResponse_Config_ParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          RivaNLPConfigResponse_Config_ParametersEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      RivaNLPConfigResponse_Config_ParametersEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  RivaNLPConfigResponse_Config_ParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RivaNLPConfigResponse_Config_ParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit RivaNLPConfigResponse_Config_ParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const RivaNLPConfigResponse_Config_ParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const RivaNLPConfigResponse_Config_ParametersEntry_DoNotUse*>(
        &_RivaNLPConfigResponse_Config_ParametersEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "nvidia.riva.nlp.RivaNLPConfigResponse.Config.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "nvidia.riva.nlp.RivaNLPConfigResponse.Config.ParametersEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};
// -------------------------------------------------------------------

class RivaNLPConfigRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.RivaNLPConfigRequest) */ {
 public:
  inline RivaNLPConfigRequest() : RivaNLPConfigRequest(nullptr) {}
  ~RivaNLPConfigRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RivaNLPConfigRequest(::google::protobuf::internal::ConstantInitialized);

  inline RivaNLPConfigRequest(const RivaNLPConfigRequest& from)
      : RivaNLPConfigRequest(nullptr, from) {}
  RivaNLPConfigRequest(RivaNLPConfigRequest&& from) noexcept
    : RivaNLPConfigRequest() {
    *this = ::std::move(from);
  }

  inline RivaNLPConfigRequest& operator=(const RivaNLPConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RivaNLPConfigRequest& operator=(RivaNLPConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RivaNLPConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RivaNLPConfigRequest* internal_default_instance() {
    return reinterpret_cast<const RivaNLPConfigRequest*>(
               &_RivaNLPConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RivaNLPConfigRequest& a, RivaNLPConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RivaNLPConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RivaNLPConfigRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RivaNLPConfigRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RivaNLPConfigRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RivaNLPConfigRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RivaNLPConfigRequest& from) {
    RivaNLPConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RivaNLPConfigRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.RivaNLPConfigRequest";
  }
  protected:
  explicit RivaNLPConfigRequest(::google::protobuf::Arena* arena);
  RivaNLPConfigRequest(::google::protobuf::Arena* arena, const RivaNLPConfigRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
  };
  // string model_name = 1;
  void clear_model_name() ;
  const std::string& model_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_name(Arg_&& arg, Args_... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* value);

  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(
      const std::string& value);
  std::string* _internal_mutable_model_name();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.RivaNLPConfigRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr model_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class NaturalQueryResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.NaturalQueryResult) */ {
 public:
  inline NaturalQueryResult() : NaturalQueryResult(nullptr) {}
  ~NaturalQueryResult() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NaturalQueryResult(::google::protobuf::internal::ConstantInitialized);

  inline NaturalQueryResult(const NaturalQueryResult& from)
      : NaturalQueryResult(nullptr, from) {}
  NaturalQueryResult(NaturalQueryResult&& from) noexcept
    : NaturalQueryResult() {
    *this = ::std::move(from);
  }

  inline NaturalQueryResult& operator=(const NaturalQueryResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline NaturalQueryResult& operator=(NaturalQueryResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NaturalQueryResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const NaturalQueryResult* internal_default_instance() {
    return reinterpret_cast<const NaturalQueryResult*>(
               &_NaturalQueryResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(NaturalQueryResult& a, NaturalQueryResult& b) {
    a.Swap(&b);
  }
  inline void Swap(NaturalQueryResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NaturalQueryResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NaturalQueryResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NaturalQueryResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NaturalQueryResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NaturalQueryResult& from) {
    NaturalQueryResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NaturalQueryResult* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.NaturalQueryResult";
  }
  protected:
  explicit NaturalQueryResult(::google::protobuf::Arena* arena);
  NaturalQueryResult(::google::protobuf::Arena* arena, const NaturalQueryResult& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnswerFieldNumber = 1,
    kScoreFieldNumber = 2,
  };
  // string answer = 1 [deprecated = true];
  [[deprecated]]  void clear_answer() ;
  [[deprecated]] const std::string& answer() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_answer(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_answer();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_answer();
  [[deprecated]] void set_allocated_answer(std::string* value);

  private:
  const std::string& _internal_answer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_answer(
      const std::string& value);
  std::string* _internal_mutable_answer();

  public:
  // float score = 2 [deprecated = true];
  [[deprecated]]  void clear_score() ;
  [[deprecated]] float score() const;
  [[deprecated]] void set_score(float value);

  private:
  float _internal_score() const;
  void _internal_set_score(float value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.NaturalQueryResult)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr answer_;
    float score_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class NLPModelParams final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.NLPModelParams) */ {
 public:
  inline NLPModelParams() : NLPModelParams(nullptr) {}
  ~NLPModelParams() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NLPModelParams(::google::protobuf::internal::ConstantInitialized);

  inline NLPModelParams(const NLPModelParams& from)
      : NLPModelParams(nullptr, from) {}
  NLPModelParams(NLPModelParams&& from) noexcept
    : NLPModelParams() {
    *this = ::std::move(from);
  }

  inline NLPModelParams& operator=(const NLPModelParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline NLPModelParams& operator=(NLPModelParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NLPModelParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const NLPModelParams* internal_default_instance() {
    return reinterpret_cast<const NLPModelParams*>(
               &_NLPModelParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NLPModelParams& a, NLPModelParams& b) {
    a.Swap(&b);
  }
  inline void Swap(NLPModelParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NLPModelParams* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NLPModelParams* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NLPModelParams>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NLPModelParams& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NLPModelParams& from) {
    NLPModelParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NLPModelParams* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.NLPModelParams";
  }
  protected:
  explicit NLPModelParams(::google::protobuf::Arena* arena);
  NLPModelParams(::google::protobuf::Arena* arena, const NLPModelParams& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kLanguageCodeFieldNumber = 3,
  };
  // string model_name = 1;
  void clear_model_name() ;
  const std::string& model_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_name(Arg_&& arg, Args_... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* value);

  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(
      const std::string& value);
  std::string* _internal_mutable_model_name();

  public:
  // string language_code = 3;
  void clear_language_code() ;
  const std::string& language_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_language_code(Arg_&& arg, Args_... args);
  std::string* mutable_language_code();
  PROTOBUF_NODISCARD std::string* release_language_code();
  void set_allocated_language_code(std::string* value);

  private:
  const std::string& _internal_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_code(
      const std::string& value);
  std::string* _internal_mutable_language_code();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.NLPModelParams)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 0,
      62, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr model_name_;
    ::google::protobuf::internal::ArenaStringPtr language_code_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class Classification final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.Classification) */ {
 public:
  inline Classification() : Classification(nullptr) {}
  ~Classification() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Classification(::google::protobuf::internal::ConstantInitialized);

  inline Classification(const Classification& from)
      : Classification(nullptr, from) {}
  Classification(Classification&& from) noexcept
    : Classification() {
    *this = ::std::move(from);
  }

  inline Classification& operator=(const Classification& from) {
    CopyFrom(from);
    return *this;
  }
  inline Classification& operator=(Classification&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Classification& default_instance() {
    return *internal_default_instance();
  }
  static inline const Classification* internal_default_instance() {
    return reinterpret_cast<const Classification*>(
               &_Classification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Classification& a, Classification& b) {
    a.Swap(&b);
  }
  inline void Swap(Classification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Classification* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Classification* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Classification>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Classification& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Classification& from) {
    Classification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Classification* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.Classification";
  }
  protected:
  explicit Classification(::google::protobuf::Arena* arena);
  Classification(::google::protobuf::Arena* arena, const Classification& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassNameFieldNumber = 1,
    kScoreFieldNumber = 2,
  };
  // string class_name = 1 [deprecated = true];
  [[deprecated]]  void clear_class_name() ;
  [[deprecated]] const std::string& class_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_class_name(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_class_name();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_class_name();
  [[deprecated]] void set_allocated_class_name(std::string* value);

  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(
      const std::string& value);
  std::string* _internal_mutable_class_name();

  public:
  // float score = 2 [deprecated = true];
  [[deprecated]]  void clear_score() ;
  [[deprecated]] float score() const;
  [[deprecated]] void set_score(float value);

  private:
  float _internal_score() const;
  void _internal_set_score(float value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.Classification)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr class_name_;
    float score_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class AnalyzeIntentContext final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.AnalyzeIntentContext) */ {
 public:
  inline AnalyzeIntentContext() : AnalyzeIntentContext(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnalyzeIntentContext(::google::protobuf::internal::ConstantInitialized);

  inline AnalyzeIntentContext(const AnalyzeIntentContext& from)
      : AnalyzeIntentContext(nullptr, from) {}
  AnalyzeIntentContext(AnalyzeIntentContext&& from) noexcept
    : AnalyzeIntentContext() {
    *this = ::std::move(from);
  }

  inline AnalyzeIntentContext& operator=(const AnalyzeIntentContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalyzeIntentContext& operator=(AnalyzeIntentContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalyzeIntentContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalyzeIntentContext* internal_default_instance() {
    return reinterpret_cast<const AnalyzeIntentContext*>(
               &_AnalyzeIntentContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AnalyzeIntentContext& a, AnalyzeIntentContext& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalyzeIntentContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalyzeIntentContext* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalyzeIntentContext* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnalyzeIntentContext>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AnalyzeIntentContext& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AnalyzeIntentContext& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.AnalyzeIntentContext";
  }
  protected:
  explicit AnalyzeIntentContext(::google::protobuf::Arena* arena);
  AnalyzeIntentContext(::google::protobuf::Arena* arena, const AnalyzeIntentContext& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.AnalyzeIntentContext)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class AnalyzeEntitiesOptions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.AnalyzeEntitiesOptions) */ {
 public:
  inline AnalyzeEntitiesOptions() : AnalyzeEntitiesOptions(nullptr) {}
  ~AnalyzeEntitiesOptions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnalyzeEntitiesOptions(::google::protobuf::internal::ConstantInitialized);

  inline AnalyzeEntitiesOptions(const AnalyzeEntitiesOptions& from)
      : AnalyzeEntitiesOptions(nullptr, from) {}
  AnalyzeEntitiesOptions(AnalyzeEntitiesOptions&& from) noexcept
    : AnalyzeEntitiesOptions() {
    *this = ::std::move(from);
  }

  inline AnalyzeEntitiesOptions& operator=(const AnalyzeEntitiesOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalyzeEntitiesOptions& operator=(AnalyzeEntitiesOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalyzeEntitiesOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalyzeEntitiesOptions* internal_default_instance() {
    return reinterpret_cast<const AnalyzeEntitiesOptions*>(
               &_AnalyzeEntitiesOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AnalyzeEntitiesOptions& a, AnalyzeEntitiesOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalyzeEntitiesOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalyzeEntitiesOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalyzeEntitiesOptions* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnalyzeEntitiesOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnalyzeEntitiesOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnalyzeEntitiesOptions& from) {
    AnalyzeEntitiesOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnalyzeEntitiesOptions* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.AnalyzeEntitiesOptions";
  }
  protected:
  explicit AnalyzeEntitiesOptions(::google::protobuf::Arena* arena);
  AnalyzeEntitiesOptions(::google::protobuf::Arena* arena, const AnalyzeEntitiesOptions& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLangFieldNumber = 4,
  };
  // string lang = 4 [deprecated = true];
  [[deprecated]]  void clear_lang() ;
  [[deprecated]] const std::string& lang() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_lang(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_lang();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_lang();
  [[deprecated]] void set_allocated_lang(std::string* value);

  private:
  const std::string& _internal_lang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lang(
      const std::string& value);
  std::string* _internal_mutable_lang();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.AnalyzeEntitiesOptions)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr lang_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class TokenClassValue final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.TokenClassValue) */ {
 public:
  inline TokenClassValue() : TokenClassValue(nullptr) {}
  ~TokenClassValue() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TokenClassValue(::google::protobuf::internal::ConstantInitialized);

  inline TokenClassValue(const TokenClassValue& from)
      : TokenClassValue(nullptr, from) {}
  TokenClassValue(TokenClassValue&& from) noexcept
    : TokenClassValue() {
    *this = ::std::move(from);
  }

  inline TokenClassValue& operator=(const TokenClassValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenClassValue& operator=(TokenClassValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenClassValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenClassValue* internal_default_instance() {
    return reinterpret_cast<const TokenClassValue*>(
               &_TokenClassValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TokenClassValue& a, TokenClassValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenClassValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenClassValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenClassValue* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenClassValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TokenClassValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TokenClassValue& from) {
    TokenClassValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TokenClassValue* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.TokenClassValue";
  }
  protected:
  explicit TokenClassValue(::google::protobuf::Arena* arena);
  TokenClassValue(::google::protobuf::Arena* arena, const TokenClassValue& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 2,
    kSpanFieldNumber = 3,
    kTokenFieldNumber = 1,
  };
  // repeated .nvidia.riva.nlp.Classification label = 2 [deprecated = true];
  [[deprecated]]  int label_size() const;
  private:
  int _internal_label_size() const;

  public:
  [[deprecated]]  void clear_label() ;
  [[deprecated]] ::nvidia::riva::nlp::Classification* mutable_label(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::Classification >*
      mutable_label();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Classification>& _internal_label() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Classification>* _internal_mutable_label();
  public:
  [[deprecated]] const ::nvidia::riva::nlp::Classification& label(int index) const;
  [[deprecated]] ::nvidia::riva::nlp::Classification* add_label();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::Classification >&
      label() const;
  // repeated .nvidia.riva.nlp.Span span = 3 [deprecated = true];
  [[deprecated]]  int span_size() const;
  private:
  int _internal_span_size() const;

  public:
  [[deprecated]]  void clear_span() ;
  [[deprecated]] ::nvidia::riva::nlp::Span* mutable_span(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::Span >*
      mutable_span();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Span>& _internal_span() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Span>* _internal_mutable_span();
  public:
  [[deprecated]] const ::nvidia::riva::nlp::Span& span(int index) const;
  [[deprecated]] ::nvidia::riva::nlp::Span* add_span();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::Span >&
      span() const;
  // string token = 1 [deprecated = true];
  [[deprecated]]  void clear_token() ;
  [[deprecated]] const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_token(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_token();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_token();
  [[deprecated]] void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.TokenClassValue)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::Classification > label_;
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::Span > span_;
    ::google::protobuf::internal::ArenaStringPtr token_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class TokenClassRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.TokenClassRequest) */ {
 public:
  inline TokenClassRequest() : TokenClassRequest(nullptr) {}
  ~TokenClassRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TokenClassRequest(::google::protobuf::internal::ConstantInitialized);

  inline TokenClassRequest(const TokenClassRequest& from)
      : TokenClassRequest(nullptr, from) {}
  TokenClassRequest(TokenClassRequest&& from) noexcept
    : TokenClassRequest() {
    *this = ::std::move(from);
  }

  inline TokenClassRequest& operator=(const TokenClassRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenClassRequest& operator=(TokenClassRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenClassRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenClassRequest* internal_default_instance() {
    return reinterpret_cast<const TokenClassRequest*>(
               &_TokenClassRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TokenClassRequest& a, TokenClassRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenClassRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenClassRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenClassRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenClassRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TokenClassRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TokenClassRequest& from) {
    TokenClassRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TokenClassRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.TokenClassRequest";
  }
  protected:
  explicit TokenClassRequest(::google::protobuf::Arena* arena);
  TokenClassRequest(::google::protobuf::Arena* arena, const TokenClassRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kModelFieldNumber = 4,
    kIdFieldNumber = 100,
    kTopNFieldNumber = 3,
  };
  // repeated string text = 1 [deprecated = true];
  [[deprecated]]  int text_size() const;
  private:
  int _internal_text_size() const;

  public:
  [[deprecated]]  void clear_text() ;
  [[deprecated]] const std::string& text(int index) const;
  [[deprecated]] std::string* mutable_text(int index);
  [[deprecated]] void set_text(int index, const std::string& value);
  [[deprecated]] void set_text(int index, std::string&& value);
  [[deprecated]] void set_text(int index, const char* value);
  [[deprecated]] void set_text(int index, const char* value, std::size_t size);
  [[deprecated]] void set_text(int index, absl::string_view value);
  [[deprecated]] std::string* add_text();
  [[deprecated]] void add_text(const std::string& value);
  [[deprecated]] void add_text(std::string&& value);
  [[deprecated]] void add_text(const char* value);
  [[deprecated]] void add_text(const char* value, std::size_t size);
  [[deprecated]] void add_text(absl::string_view value);
  [[deprecated]] const ::google::protobuf::RepeatedPtrField<std::string>& text() const;
  [[deprecated]] ::google::protobuf::RepeatedPtrField<std::string>* mutable_text();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_text() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_text();

  public:
  // .nvidia.riva.nlp.NLPModelParams model = 4 [deprecated = true];
  [[deprecated]]  bool has_model() const;
  [[deprecated]]  void clear_model() ;
  [[deprecated]] const ::nvidia::riva::nlp::NLPModelParams& model() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::nlp::NLPModelParams* release_model();
  [[deprecated]] ::nvidia::riva::nlp::NLPModelParams* mutable_model();
  [[deprecated]] void set_allocated_model(::nvidia::riva::nlp::NLPModelParams* value);
  [[deprecated]] void unsafe_arena_set_allocated_model(::nvidia::riva::nlp::NLPModelParams* value);
  [[deprecated]] ::nvidia::riva::nlp::NLPModelParams* unsafe_arena_release_model();

  private:
  const ::nvidia::riva::nlp::NLPModelParams& _internal_model() const;
  ::nvidia::riva::nlp::NLPModelParams* _internal_mutable_model();

  public:
  // .nvidia.riva.RequestId id = 100 [deprecated = true];
  [[deprecated]]  bool has_id() const;
  [[deprecated]]  void clear_id() ;
  [[deprecated]] const ::nvidia::riva::RequestId& id() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  [[deprecated]] ::nvidia::riva::RequestId* mutable_id();
  [[deprecated]] void set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // uint32 top_n = 3 [deprecated = true];
  [[deprecated]]  void clear_top_n() ;
  [[deprecated]] ::uint32_t top_n() const;
  [[deprecated]] void set_top_n(::uint32_t value);

  private:
  ::uint32_t _internal_top_n() const;
  void _internal_set_top_n(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.TokenClassRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      46, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> text_;
    ::nvidia::riva::nlp::NLPModelParams* model_;
    ::nvidia::riva::RequestId* id_;
    ::uint32_t top_n_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class TextTransformResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.TextTransformResponse) */ {
 public:
  inline TextTransformResponse() : TextTransformResponse(nullptr) {}
  ~TextTransformResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TextTransformResponse(::google::protobuf::internal::ConstantInitialized);

  inline TextTransformResponse(const TextTransformResponse& from)
      : TextTransformResponse(nullptr, from) {}
  TextTransformResponse(TextTransformResponse&& from) noexcept
    : TextTransformResponse() {
    *this = ::std::move(from);
  }

  inline TextTransformResponse& operator=(const TextTransformResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextTransformResponse& operator=(TextTransformResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextTransformResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextTransformResponse* internal_default_instance() {
    return reinterpret_cast<const TextTransformResponse*>(
               &_TextTransformResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TextTransformResponse& a, TextTransformResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TextTransformResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextTransformResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextTransformResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextTransformResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TextTransformResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TextTransformResponse& from) {
    TextTransformResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TextTransformResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.TextTransformResponse";
  }
  protected:
  explicit TextTransformResponse(::google::protobuf::Arena* arena);
  TextTransformResponse(::google::protobuf::Arena* arena, const TextTransformResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kIdFieldNumber = 100,
  };
  // repeated string text = 1;
  int text_size() const;
  private:
  int _internal_text_size() const;

  public:
  void clear_text() ;
  const std::string& text(int index) const;
  std::string* mutable_text(int index);
  void set_text(int index, const std::string& value);
  void set_text(int index, std::string&& value);
  void set_text(int index, const char* value);
  void set_text(int index, const char* value, std::size_t size);
  void set_text(int index, absl::string_view value);
  std::string* add_text();
  void add_text(const std::string& value);
  void add_text(std::string&& value);
  void add_text(const char* value);
  void add_text(const char* value, std::size_t size);
  void add_text(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& text() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_text();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_text() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_text();

  public:
  // .nvidia.riva.RequestId id = 100;
  bool has_id() const;
  void clear_id() ;
  const ::nvidia::riva::RequestId& id() const;
  PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  ::nvidia::riva::RequestId* mutable_id();
  void set_allocated_id(::nvidia::riva::RequestId* value);
  void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.TextTransformResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      50, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> text_;
    ::nvidia::riva::RequestId* id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class TextTransformRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.TextTransformRequest) */ {
 public:
  inline TextTransformRequest() : TextTransformRequest(nullptr) {}
  ~TextTransformRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TextTransformRequest(::google::protobuf::internal::ConstantInitialized);

  inline TextTransformRequest(const TextTransformRequest& from)
      : TextTransformRequest(nullptr, from) {}
  TextTransformRequest(TextTransformRequest&& from) noexcept
    : TextTransformRequest() {
    *this = ::std::move(from);
  }

  inline TextTransformRequest& operator=(const TextTransformRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextTransformRequest& operator=(TextTransformRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextTransformRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextTransformRequest* internal_default_instance() {
    return reinterpret_cast<const TextTransformRequest*>(
               &_TextTransformRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TextTransformRequest& a, TextTransformRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TextTransformRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextTransformRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextTransformRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextTransformRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TextTransformRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TextTransformRequest& from) {
    TextTransformRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TextTransformRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.TextTransformRequest";
  }
  protected:
  explicit TextTransformRequest(::google::protobuf::Arena* arena);
  TextTransformRequest(::google::protobuf::Arena* arena, const TextTransformRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kModelFieldNumber = 3,
    kIdFieldNumber = 100,
    kTopNFieldNumber = 2,
  };
  // repeated string text = 1;
  int text_size() const;
  private:
  int _internal_text_size() const;

  public:
  void clear_text() ;
  const std::string& text(int index) const;
  std::string* mutable_text(int index);
  void set_text(int index, const std::string& value);
  void set_text(int index, std::string&& value);
  void set_text(int index, const char* value);
  void set_text(int index, const char* value, std::size_t size);
  void set_text(int index, absl::string_view value);
  std::string* add_text();
  void add_text(const std::string& value);
  void add_text(std::string&& value);
  void add_text(const char* value);
  void add_text(const char* value, std::size_t size);
  void add_text(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& text() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_text();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_text() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_text();

  public:
  // .nvidia.riva.nlp.NLPModelParams model = 3;
  bool has_model() const;
  void clear_model() ;
  const ::nvidia::riva::nlp::NLPModelParams& model() const;
  PROTOBUF_NODISCARD ::nvidia::riva::nlp::NLPModelParams* release_model();
  ::nvidia::riva::nlp::NLPModelParams* mutable_model();
  void set_allocated_model(::nvidia::riva::nlp::NLPModelParams* value);
  void unsafe_arena_set_allocated_model(::nvidia::riva::nlp::NLPModelParams* value);
  ::nvidia::riva::nlp::NLPModelParams* unsafe_arena_release_model();

  private:
  const ::nvidia::riva::nlp::NLPModelParams& _internal_model() const;
  ::nvidia::riva::nlp::NLPModelParams* _internal_mutable_model();

  public:
  // .nvidia.riva.RequestId id = 100;
  bool has_id() const;
  void clear_id() ;
  const ::nvidia::riva::RequestId& id() const;
  PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  ::nvidia::riva::RequestId* mutable_id();
  void set_allocated_id(::nvidia::riva::RequestId* value);
  void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // uint32 top_n = 2;
  void clear_top_n() ;
  ::uint32_t top_n() const;
  void set_top_n(::uint32_t value);

  private:
  ::uint32_t _internal_top_n() const;
  void _internal_set_top_n(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.TextTransformRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      49, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> text_;
    ::nvidia::riva::nlp::NLPModelParams* model_;
    ::nvidia::riva::RequestId* id_;
    ::uint32_t top_n_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class TextClassRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.TextClassRequest) */ {
 public:
  inline TextClassRequest() : TextClassRequest(nullptr) {}
  ~TextClassRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TextClassRequest(::google::protobuf::internal::ConstantInitialized);

  inline TextClassRequest(const TextClassRequest& from)
      : TextClassRequest(nullptr, from) {}
  TextClassRequest(TextClassRequest&& from) noexcept
    : TextClassRequest() {
    *this = ::std::move(from);
  }

  inline TextClassRequest& operator=(const TextClassRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextClassRequest& operator=(TextClassRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextClassRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextClassRequest* internal_default_instance() {
    return reinterpret_cast<const TextClassRequest*>(
               &_TextClassRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TextClassRequest& a, TextClassRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TextClassRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextClassRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextClassRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextClassRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TextClassRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TextClassRequest& from) {
    TextClassRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TextClassRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.TextClassRequest";
  }
  protected:
  explicit TextClassRequest(::google::protobuf::Arena* arena);
  TextClassRequest(::google::protobuf::Arena* arena, const TextClassRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kModelFieldNumber = 3,
    kIdFieldNumber = 100,
    kTopNFieldNumber = 2,
  };
  // repeated string text = 1 [deprecated = true];
  [[deprecated]]  int text_size() const;
  private:
  int _internal_text_size() const;

  public:
  [[deprecated]]  void clear_text() ;
  [[deprecated]] const std::string& text(int index) const;
  [[deprecated]] std::string* mutable_text(int index);
  [[deprecated]] void set_text(int index, const std::string& value);
  [[deprecated]] void set_text(int index, std::string&& value);
  [[deprecated]] void set_text(int index, const char* value);
  [[deprecated]] void set_text(int index, const char* value, std::size_t size);
  [[deprecated]] void set_text(int index, absl::string_view value);
  [[deprecated]] std::string* add_text();
  [[deprecated]] void add_text(const std::string& value);
  [[deprecated]] void add_text(std::string&& value);
  [[deprecated]] void add_text(const char* value);
  [[deprecated]] void add_text(const char* value, std::size_t size);
  [[deprecated]] void add_text(absl::string_view value);
  [[deprecated]] const ::google::protobuf::RepeatedPtrField<std::string>& text() const;
  [[deprecated]] ::google::protobuf::RepeatedPtrField<std::string>* mutable_text();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_text() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_text();

  public:
  // .nvidia.riva.nlp.NLPModelParams model = 3 [deprecated = true];
  [[deprecated]]  bool has_model() const;
  [[deprecated]]  void clear_model() ;
  [[deprecated]] const ::nvidia::riva::nlp::NLPModelParams& model() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::nlp::NLPModelParams* release_model();
  [[deprecated]] ::nvidia::riva::nlp::NLPModelParams* mutable_model();
  [[deprecated]] void set_allocated_model(::nvidia::riva::nlp::NLPModelParams* value);
  [[deprecated]] void unsafe_arena_set_allocated_model(::nvidia::riva::nlp::NLPModelParams* value);
  [[deprecated]] ::nvidia::riva::nlp::NLPModelParams* unsafe_arena_release_model();

  private:
  const ::nvidia::riva::nlp::NLPModelParams& _internal_model() const;
  ::nvidia::riva::nlp::NLPModelParams* _internal_mutable_model();

  public:
  // .nvidia.riva.RequestId id = 100 [deprecated = true];
  [[deprecated]]  bool has_id() const;
  [[deprecated]]  void clear_id() ;
  [[deprecated]] const ::nvidia::riva::RequestId& id() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  [[deprecated]] ::nvidia::riva::RequestId* mutable_id();
  [[deprecated]] void set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // uint32 top_n = 2 [deprecated = true];
  [[deprecated]]  void clear_top_n() ;
  [[deprecated]] ::uint32_t top_n() const;
  [[deprecated]] void set_top_n(::uint32_t value);

  private:
  ::uint32_t _internal_top_n() const;
  void _internal_set_top_n(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.TextClassRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      45, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> text_;
    ::nvidia::riva::nlp::NLPModelParams* model_;
    ::nvidia::riva::RequestId* id_;
    ::uint32_t top_n_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class RivaNLPConfigResponse_Config final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.RivaNLPConfigResponse.Config) */ {
 public:
  inline RivaNLPConfigResponse_Config() : RivaNLPConfigResponse_Config(nullptr) {}
  ~RivaNLPConfigResponse_Config() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RivaNLPConfigResponse_Config(::google::protobuf::internal::ConstantInitialized);

  inline RivaNLPConfigResponse_Config(const RivaNLPConfigResponse_Config& from)
      : RivaNLPConfigResponse_Config(nullptr, from) {}
  RivaNLPConfigResponse_Config(RivaNLPConfigResponse_Config&& from) noexcept
    : RivaNLPConfigResponse_Config() {
    *this = ::std::move(from);
  }

  inline RivaNLPConfigResponse_Config& operator=(const RivaNLPConfigResponse_Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline RivaNLPConfigResponse_Config& operator=(RivaNLPConfigResponse_Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RivaNLPConfigResponse_Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const RivaNLPConfigResponse_Config* internal_default_instance() {
    return reinterpret_cast<const RivaNLPConfigResponse_Config*>(
               &_RivaNLPConfigResponse_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RivaNLPConfigResponse_Config& a, RivaNLPConfigResponse_Config& b) {
    a.Swap(&b);
  }
  inline void Swap(RivaNLPConfigResponse_Config* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RivaNLPConfigResponse_Config* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RivaNLPConfigResponse_Config* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RivaNLPConfigResponse_Config>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RivaNLPConfigResponse_Config& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RivaNLPConfigResponse_Config& from) {
    RivaNLPConfigResponse_Config::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RivaNLPConfigResponse_Config* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.RivaNLPConfigResponse.Config";
  }
  protected:
  explicit RivaNLPConfigResponse_Config(::google::protobuf::Arena* arena);
  RivaNLPConfigResponse_Config(::google::protobuf::Arena* arena, const RivaNLPConfigResponse_Config& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 2,
    kModelNameFieldNumber = 1,
  };
  // map<string, string> parameters = 2;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_parameters();

  public:
  // string model_name = 1;
  void clear_model_name() ;
  const std::string& model_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_name(Arg_&& arg, Args_... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* value);

  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(
      const std::string& value);
  std::string* _internal_mutable_model_name();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.RivaNLPConfigResponse.Config)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      73, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<RivaNLPConfigResponse_Config_ParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        parameters_;
    ::google::protobuf::internal::ArenaStringPtr model_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class NaturalQueryResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.NaturalQueryResponse) */ {
 public:
  inline NaturalQueryResponse() : NaturalQueryResponse(nullptr) {}
  ~NaturalQueryResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NaturalQueryResponse(::google::protobuf::internal::ConstantInitialized);

  inline NaturalQueryResponse(const NaturalQueryResponse& from)
      : NaturalQueryResponse(nullptr, from) {}
  NaturalQueryResponse(NaturalQueryResponse&& from) noexcept
    : NaturalQueryResponse() {
    *this = ::std::move(from);
  }

  inline NaturalQueryResponse& operator=(const NaturalQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NaturalQueryResponse& operator=(NaturalQueryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NaturalQueryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NaturalQueryResponse* internal_default_instance() {
    return reinterpret_cast<const NaturalQueryResponse*>(
               &_NaturalQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(NaturalQueryResponse& a, NaturalQueryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NaturalQueryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NaturalQueryResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NaturalQueryResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NaturalQueryResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NaturalQueryResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NaturalQueryResponse& from) {
    NaturalQueryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NaturalQueryResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.NaturalQueryResponse";
  }
  protected:
  explicit NaturalQueryResponse(::google::protobuf::Arena* arena);
  NaturalQueryResponse(::google::protobuf::Arena* arena, const NaturalQueryResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
    kIdFieldNumber = 100,
  };
  // repeated .nvidia.riva.nlp.NaturalQueryResult results = 1 [deprecated = true];
  [[deprecated]]  int results_size() const;
  private:
  int _internal_results_size() const;

  public:
  [[deprecated]]  void clear_results() ;
  [[deprecated]] ::nvidia::riva::nlp::NaturalQueryResult* mutable_results(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::NaturalQueryResult >*
      mutable_results();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::NaturalQueryResult>& _internal_results() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::NaturalQueryResult>* _internal_mutable_results();
  public:
  [[deprecated]] const ::nvidia::riva::nlp::NaturalQueryResult& results(int index) const;
  [[deprecated]] ::nvidia::riva::nlp::NaturalQueryResult* add_results();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::NaturalQueryResult >&
      results() const;
  // .nvidia.riva.RequestId id = 100 [deprecated = true];
  [[deprecated]]  bool has_id() const;
  [[deprecated]]  void clear_id() ;
  [[deprecated]] const ::nvidia::riva::RequestId& id() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  [[deprecated]] ::nvidia::riva::RequestId* mutable_id();
  [[deprecated]] void set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.NaturalQueryResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::NaturalQueryResult > results_;
    ::nvidia::riva::RequestId* id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class NaturalQueryRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.NaturalQueryRequest) */ {
 public:
  inline NaturalQueryRequest() : NaturalQueryRequest(nullptr) {}
  ~NaturalQueryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NaturalQueryRequest(::google::protobuf::internal::ConstantInitialized);

  inline NaturalQueryRequest(const NaturalQueryRequest& from)
      : NaturalQueryRequest(nullptr, from) {}
  NaturalQueryRequest(NaturalQueryRequest&& from) noexcept
    : NaturalQueryRequest() {
    *this = ::std::move(from);
  }

  inline NaturalQueryRequest& operator=(const NaturalQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NaturalQueryRequest& operator=(NaturalQueryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NaturalQueryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NaturalQueryRequest* internal_default_instance() {
    return reinterpret_cast<const NaturalQueryRequest*>(
               &_NaturalQueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(NaturalQueryRequest& a, NaturalQueryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NaturalQueryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NaturalQueryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NaturalQueryRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NaturalQueryRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NaturalQueryRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NaturalQueryRequest& from) {
    NaturalQueryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NaturalQueryRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.NaturalQueryRequest";
  }
  protected:
  explicit NaturalQueryRequest(::google::protobuf::Arena* arena);
  NaturalQueryRequest(::google::protobuf::Arena* arena, const NaturalQueryRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryFieldNumber = 1,
    kContextFieldNumber = 3,
    kIdFieldNumber = 100,
    kTopNFieldNumber = 2,
  };
  // string query = 1 [deprecated = true];
  [[deprecated]]  void clear_query() ;
  [[deprecated]] const std::string& query() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_query(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_query();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_query();
  [[deprecated]] void set_allocated_query(std::string* value);

  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(
      const std::string& value);
  std::string* _internal_mutable_query();

  public:
  // string context = 3 [deprecated = true];
  [[deprecated]]  void clear_context() ;
  [[deprecated]] const std::string& context() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_context(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_context();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_context();
  [[deprecated]] void set_allocated_context(std::string* value);

  private:
  const std::string& _internal_context() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_context(
      const std::string& value);
  std::string* _internal_mutable_context();

  public:
  // .nvidia.riva.RequestId id = 100 [deprecated = true];
  [[deprecated]]  bool has_id() const;
  [[deprecated]]  void clear_id() ;
  [[deprecated]] const ::nvidia::riva::RequestId& id() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  [[deprecated]] ::nvidia::riva::RequestId* mutable_id();
  [[deprecated]] void set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // uint32 top_n = 2 [deprecated = true];
  [[deprecated]]  void clear_top_n() ;
  [[deprecated]] ::uint32_t top_n() const;
  [[deprecated]] void set_top_n(::uint32_t value);

  private:
  ::uint32_t _internal_top_n() const;
  void _internal_set_top_n(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.NaturalQueryRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      56, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr query_;
    ::google::protobuf::internal::ArenaStringPtr context_;
    ::nvidia::riva::RequestId* id_;
    ::uint32_t top_n_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class ClassificationResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.ClassificationResult) */ {
 public:
  inline ClassificationResult() : ClassificationResult(nullptr) {}
  ~ClassificationResult() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClassificationResult(::google::protobuf::internal::ConstantInitialized);

  inline ClassificationResult(const ClassificationResult& from)
      : ClassificationResult(nullptr, from) {}
  ClassificationResult(ClassificationResult&& from) noexcept
    : ClassificationResult() {
    *this = ::std::move(from);
  }

  inline ClassificationResult& operator=(const ClassificationResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClassificationResult& operator=(ClassificationResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClassificationResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClassificationResult* internal_default_instance() {
    return reinterpret_cast<const ClassificationResult*>(
               &_ClassificationResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ClassificationResult& a, ClassificationResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ClassificationResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClassificationResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClassificationResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClassificationResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClassificationResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ClassificationResult& from) {
    ClassificationResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ClassificationResult* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.ClassificationResult";
  }
  protected:
  explicit ClassificationResult(::google::protobuf::Arena* arena);
  ClassificationResult(::google::protobuf::Arena* arena, const ClassificationResult& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 1,
  };
  // repeated .nvidia.riva.nlp.Classification labels = 1 [deprecated = true];
  [[deprecated]]  int labels_size() const;
  private:
  int _internal_labels_size() const;

  public:
  [[deprecated]]  void clear_labels() ;
  [[deprecated]] ::nvidia::riva::nlp::Classification* mutable_labels(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::Classification >*
      mutable_labels();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Classification>& _internal_labels() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Classification>* _internal_mutable_labels();
  public:
  [[deprecated]] const ::nvidia::riva::nlp::Classification& labels(int index) const;
  [[deprecated]] ::nvidia::riva::nlp::Classification* add_labels();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::Classification >&
      labels() const;
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.ClassificationResult)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::Classification > labels_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class AnalyzeIntentOptions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.AnalyzeIntentOptions) */ {
 public:
  inline AnalyzeIntentOptions() : AnalyzeIntentOptions(nullptr) {}
  ~AnalyzeIntentOptions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnalyzeIntentOptions(::google::protobuf::internal::ConstantInitialized);

  inline AnalyzeIntentOptions(const AnalyzeIntentOptions& from)
      : AnalyzeIntentOptions(nullptr, from) {}
  AnalyzeIntentOptions(AnalyzeIntentOptions&& from) noexcept
    : AnalyzeIntentOptions() {
    *this = ::std::move(from);
  }

  inline AnalyzeIntentOptions& operator=(const AnalyzeIntentOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalyzeIntentOptions& operator=(AnalyzeIntentOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalyzeIntentOptions& default_instance() {
    return *internal_default_instance();
  }
  enum ContextCase {
    kPreviousIntent = 1,
    kVectors = 2,
    CONTEXT_NOT_SET = 0,
  };

  static inline const AnalyzeIntentOptions* internal_default_instance() {
    return reinterpret_cast<const AnalyzeIntentOptions*>(
               &_AnalyzeIntentOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AnalyzeIntentOptions& a, AnalyzeIntentOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalyzeIntentOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalyzeIntentOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalyzeIntentOptions* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnalyzeIntentOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnalyzeIntentOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnalyzeIntentOptions& from) {
    AnalyzeIntentOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnalyzeIntentOptions* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.AnalyzeIntentOptions";
  }
  protected:
  explicit AnalyzeIntentOptions(::google::protobuf::Arena* arena);
  AnalyzeIntentOptions(::google::protobuf::Arena* arena, const AnalyzeIntentOptions& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDomainFieldNumber = 3,
    kLangFieldNumber = 4,
    kPreviousIntentFieldNumber = 1,
    kVectorsFieldNumber = 2,
  };
  // string domain = 3 [deprecated = true];
  [[deprecated]]  void clear_domain() ;
  [[deprecated]] const std::string& domain() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_domain(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_domain();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_domain();
  [[deprecated]] void set_allocated_domain(std::string* value);

  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(
      const std::string& value);
  std::string* _internal_mutable_domain();

  public:
  // string lang = 4 [deprecated = true];
  [[deprecated]]  void clear_lang() ;
  [[deprecated]] const std::string& lang() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_lang(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_lang();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_lang();
  [[deprecated]] void set_allocated_lang(std::string* value);

  private:
  const std::string& _internal_lang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lang(
      const std::string& value);
  std::string* _internal_mutable_lang();

  public:
  // string previous_intent = 1 [deprecated = true];
  [[deprecated]]  bool has_previous_intent() const;
  [[deprecated]]  void clear_previous_intent() ;
  [[deprecated]] const std::string& previous_intent() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_previous_intent(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_previous_intent();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_previous_intent();
  [[deprecated]] void set_allocated_previous_intent(std::string* value);

  private:
  const std::string& _internal_previous_intent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_previous_intent(
      const std::string& value);
  std::string* _internal_mutable_previous_intent();

  public:
  // .nvidia.riva.nlp.AnalyzeIntentContext vectors = 2 [deprecated = true];
  [[deprecated]]  bool has_vectors() const;
  private:
  bool _internal_has_vectors() const;

  public:
  [[deprecated]]  void clear_vectors() ;
  [[deprecated]] const ::nvidia::riva::nlp::AnalyzeIntentContext& vectors() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::nlp::AnalyzeIntentContext* release_vectors();
  [[deprecated]] ::nvidia::riva::nlp::AnalyzeIntentContext* mutable_vectors();
  [[deprecated]] void set_allocated_vectors(::nvidia::riva::nlp::AnalyzeIntentContext* value);
  [[deprecated]] void unsafe_arena_set_allocated_vectors(::nvidia::riva::nlp::AnalyzeIntentContext* value);
  [[deprecated]] ::nvidia::riva::nlp::AnalyzeIntentContext* unsafe_arena_release_vectors();

  private:
  const ::nvidia::riva::nlp::AnalyzeIntentContext& _internal_vectors() const;
  ::nvidia::riva::nlp::AnalyzeIntentContext* _internal_mutable_vectors();

  public:
  void clear_context();
  ContextCase context_case() const;
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.AnalyzeIntentOptions)
 private:
  class _Internal;
  void set_has_previous_intent();
  void set_has_vectors();

  inline bool has_context() const;
  inline void clear_has_context();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 4, 1,
      70, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr domain_;
    ::google::protobuf::internal::ArenaStringPtr lang_;
    union ContextUnion {
      constexpr ContextUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr previous_intent_;
      ::nvidia::riva::nlp::AnalyzeIntentContext* vectors_;
    } context_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class AnalyzeEntitiesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.AnalyzeEntitiesRequest) */ {
 public:
  inline AnalyzeEntitiesRequest() : AnalyzeEntitiesRequest(nullptr) {}
  ~AnalyzeEntitiesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnalyzeEntitiesRequest(::google::protobuf::internal::ConstantInitialized);

  inline AnalyzeEntitiesRequest(const AnalyzeEntitiesRequest& from)
      : AnalyzeEntitiesRequest(nullptr, from) {}
  AnalyzeEntitiesRequest(AnalyzeEntitiesRequest&& from) noexcept
    : AnalyzeEntitiesRequest() {
    *this = ::std::move(from);
  }

  inline AnalyzeEntitiesRequest& operator=(const AnalyzeEntitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalyzeEntitiesRequest& operator=(AnalyzeEntitiesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalyzeEntitiesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalyzeEntitiesRequest* internal_default_instance() {
    return reinterpret_cast<const AnalyzeEntitiesRequest*>(
               &_AnalyzeEntitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AnalyzeEntitiesRequest& a, AnalyzeEntitiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalyzeEntitiesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalyzeEntitiesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalyzeEntitiesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnalyzeEntitiesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnalyzeEntitiesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnalyzeEntitiesRequest& from) {
    AnalyzeEntitiesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnalyzeEntitiesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.AnalyzeEntitiesRequest";
  }
  protected:
  explicit AnalyzeEntitiesRequest(::google::protobuf::Arena* arena);
  AnalyzeEntitiesRequest(::google::protobuf::Arena* arena, const AnalyzeEntitiesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryFieldNumber = 1,
    kOptionsFieldNumber = 2,
    kIdFieldNumber = 100,
  };
  // string query = 1 [deprecated = true];
  [[deprecated]]  void clear_query() ;
  [[deprecated]] const std::string& query() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_query(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_query();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_query();
  [[deprecated]] void set_allocated_query(std::string* value);

  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(
      const std::string& value);
  std::string* _internal_mutable_query();

  public:
  // .nvidia.riva.nlp.AnalyzeEntitiesOptions options = 2 [deprecated = true];
  [[deprecated]]  bool has_options() const;
  [[deprecated]]  void clear_options() ;
  [[deprecated]] const ::nvidia::riva::nlp::AnalyzeEntitiesOptions& options() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::nlp::AnalyzeEntitiesOptions* release_options();
  [[deprecated]] ::nvidia::riva::nlp::AnalyzeEntitiesOptions* mutable_options();
  [[deprecated]] void set_allocated_options(::nvidia::riva::nlp::AnalyzeEntitiesOptions* value);
  [[deprecated]] void unsafe_arena_set_allocated_options(::nvidia::riva::nlp::AnalyzeEntitiesOptions* value);
  [[deprecated]] ::nvidia::riva::nlp::AnalyzeEntitiesOptions* unsafe_arena_release_options();

  private:
  const ::nvidia::riva::nlp::AnalyzeEntitiesOptions& _internal_options() const;
  ::nvidia::riva::nlp::AnalyzeEntitiesOptions* _internal_mutable_options();

  public:
  // .nvidia.riva.RequestId id = 100 [deprecated = true];
  [[deprecated]]  bool has_id() const;
  [[deprecated]]  void clear_id() ;
  [[deprecated]] const ::nvidia::riva::RequestId& id() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  [[deprecated]] ::nvidia::riva::RequestId* mutable_id();
  [[deprecated]] void set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.AnalyzeEntitiesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      52, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr query_;
    ::nvidia::riva::nlp::AnalyzeEntitiesOptions* options_;
    ::nvidia::riva::RequestId* id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class TokenClassSequence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.TokenClassSequence) */ {
 public:
  inline TokenClassSequence() : TokenClassSequence(nullptr) {}
  ~TokenClassSequence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TokenClassSequence(::google::protobuf::internal::ConstantInitialized);

  inline TokenClassSequence(const TokenClassSequence& from)
      : TokenClassSequence(nullptr, from) {}
  TokenClassSequence(TokenClassSequence&& from) noexcept
    : TokenClassSequence() {
    *this = ::std::move(from);
  }

  inline TokenClassSequence& operator=(const TokenClassSequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenClassSequence& operator=(TokenClassSequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenClassSequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenClassSequence* internal_default_instance() {
    return reinterpret_cast<const TokenClassSequence*>(
               &_TokenClassSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TokenClassSequence& a, TokenClassSequence& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenClassSequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenClassSequence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenClassSequence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenClassSequence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TokenClassSequence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TokenClassSequence& from) {
    TokenClassSequence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TokenClassSequence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.TokenClassSequence";
  }
  protected:
  explicit TokenClassSequence(::google::protobuf::Arena* arena);
  TokenClassSequence(::google::protobuf::Arena* arena, const TokenClassSequence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .nvidia.riva.nlp.TokenClassValue results = 1 [deprecated = true];
  [[deprecated]]  int results_size() const;
  private:
  int _internal_results_size() const;

  public:
  [[deprecated]]  void clear_results() ;
  [[deprecated]] ::nvidia::riva::nlp::TokenClassValue* mutable_results(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::TokenClassValue >*
      mutable_results();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassValue>& _internal_results() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassValue>* _internal_mutable_results();
  public:
  [[deprecated]] const ::nvidia::riva::nlp::TokenClassValue& results(int index) const;
  [[deprecated]] ::nvidia::riva::nlp::TokenClassValue* add_results();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::TokenClassValue >&
      results() const;
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.TokenClassSequence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::TokenClassValue > results_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class TextClassResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.TextClassResponse) */ {
 public:
  inline TextClassResponse() : TextClassResponse(nullptr) {}
  ~TextClassResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TextClassResponse(::google::protobuf::internal::ConstantInitialized);

  inline TextClassResponse(const TextClassResponse& from)
      : TextClassResponse(nullptr, from) {}
  TextClassResponse(TextClassResponse&& from) noexcept
    : TextClassResponse() {
    *this = ::std::move(from);
  }

  inline TextClassResponse& operator=(const TextClassResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextClassResponse& operator=(TextClassResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextClassResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextClassResponse* internal_default_instance() {
    return reinterpret_cast<const TextClassResponse*>(
               &_TextClassResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TextClassResponse& a, TextClassResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TextClassResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextClassResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextClassResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextClassResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TextClassResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TextClassResponse& from) {
    TextClassResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TextClassResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.TextClassResponse";
  }
  protected:
  explicit TextClassResponse(::google::protobuf::Arena* arena);
  TextClassResponse(::google::protobuf::Arena* arena, const TextClassResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
    kIdFieldNumber = 100,
  };
  // repeated .nvidia.riva.nlp.ClassificationResult results = 1 [deprecated = true];
  [[deprecated]]  int results_size() const;
  private:
  int _internal_results_size() const;

  public:
  [[deprecated]]  void clear_results() ;
  [[deprecated]] ::nvidia::riva::nlp::ClassificationResult* mutable_results(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::ClassificationResult >*
      mutable_results();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::ClassificationResult>& _internal_results() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::ClassificationResult>* _internal_mutable_results();
  public:
  [[deprecated]] const ::nvidia::riva::nlp::ClassificationResult& results(int index) const;
  [[deprecated]] ::nvidia::riva::nlp::ClassificationResult* add_results();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::ClassificationResult >&
      results() const;
  // .nvidia.riva.RequestId id = 100 [deprecated = true];
  [[deprecated]]  bool has_id() const;
  [[deprecated]]  void clear_id() ;
  [[deprecated]] const ::nvidia::riva::RequestId& id() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  [[deprecated]] ::nvidia::riva::RequestId* mutable_id();
  [[deprecated]] void set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.TextClassResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::ClassificationResult > results_;
    ::nvidia::riva::RequestId* id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class RivaNLPConfigResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.RivaNLPConfigResponse) */ {
 public:
  inline RivaNLPConfigResponse() : RivaNLPConfigResponse(nullptr) {}
  ~RivaNLPConfigResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RivaNLPConfigResponse(::google::protobuf::internal::ConstantInitialized);

  inline RivaNLPConfigResponse(const RivaNLPConfigResponse& from)
      : RivaNLPConfigResponse(nullptr, from) {}
  RivaNLPConfigResponse(RivaNLPConfigResponse&& from) noexcept
    : RivaNLPConfigResponse() {
    *this = ::std::move(from);
  }

  inline RivaNLPConfigResponse& operator=(const RivaNLPConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RivaNLPConfigResponse& operator=(RivaNLPConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RivaNLPConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RivaNLPConfigResponse* internal_default_instance() {
    return reinterpret_cast<const RivaNLPConfigResponse*>(
               &_RivaNLPConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RivaNLPConfigResponse& a, RivaNLPConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RivaNLPConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RivaNLPConfigResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RivaNLPConfigResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RivaNLPConfigResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RivaNLPConfigResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RivaNLPConfigResponse& from) {
    RivaNLPConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RivaNLPConfigResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.RivaNLPConfigResponse";
  }
  protected:
  explicit RivaNLPConfigResponse(::google::protobuf::Arena* arena);
  RivaNLPConfigResponse(::google::protobuf::Arena* arena, const RivaNLPConfigResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Config = RivaNLPConfigResponse_Config;

  // accessors -------------------------------------------------------

  enum : int {
    kModelConfigFieldNumber = 1,
  };
  // repeated .nvidia.riva.nlp.RivaNLPConfigResponse.Config model_config = 1;
  int model_config_size() const;
  private:
  int _internal_model_config_size() const;

  public:
  void clear_model_config() ;
  ::nvidia::riva::nlp::RivaNLPConfigResponse_Config* mutable_model_config(int index);
  ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::RivaNLPConfigResponse_Config >*
      mutable_model_config();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::RivaNLPConfigResponse_Config>& _internal_model_config() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::RivaNLPConfigResponse_Config>* _internal_mutable_model_config();
  public:
  const ::nvidia::riva::nlp::RivaNLPConfigResponse_Config& model_config(int index) const;
  ::nvidia::riva::nlp::RivaNLPConfigResponse_Config* add_model_config();
  const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::RivaNLPConfigResponse_Config >&
      model_config() const;
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.RivaNLPConfigResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::RivaNLPConfigResponse_Config > model_config_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class AnalyzeIntentResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.AnalyzeIntentResponse) */ {
 public:
  inline AnalyzeIntentResponse() : AnalyzeIntentResponse(nullptr) {}
  ~AnalyzeIntentResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnalyzeIntentResponse(::google::protobuf::internal::ConstantInitialized);

  inline AnalyzeIntentResponse(const AnalyzeIntentResponse& from)
      : AnalyzeIntentResponse(nullptr, from) {}
  AnalyzeIntentResponse(AnalyzeIntentResponse&& from) noexcept
    : AnalyzeIntentResponse() {
    *this = ::std::move(from);
  }

  inline AnalyzeIntentResponse& operator=(const AnalyzeIntentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalyzeIntentResponse& operator=(AnalyzeIntentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalyzeIntentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalyzeIntentResponse* internal_default_instance() {
    return reinterpret_cast<const AnalyzeIntentResponse*>(
               &_AnalyzeIntentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AnalyzeIntentResponse& a, AnalyzeIntentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalyzeIntentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalyzeIntentResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalyzeIntentResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnalyzeIntentResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnalyzeIntentResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnalyzeIntentResponse& from) {
    AnalyzeIntentResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnalyzeIntentResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.AnalyzeIntentResponse";
  }
  protected:
  explicit AnalyzeIntentResponse(::google::protobuf::Arena* arena);
  AnalyzeIntentResponse(::google::protobuf::Arena* arena, const AnalyzeIntentResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotsFieldNumber = 2,
    kDomainStrFieldNumber = 3,
    kIntentFieldNumber = 1,
    kDomainFieldNumber = 4,
    kIdFieldNumber = 100,
  };
  // repeated .nvidia.riva.nlp.TokenClassValue slots = 2 [deprecated = true];
  [[deprecated]]  int slots_size() const;
  private:
  int _internal_slots_size() const;

  public:
  [[deprecated]]  void clear_slots() ;
  [[deprecated]] ::nvidia::riva::nlp::TokenClassValue* mutable_slots(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::TokenClassValue >*
      mutable_slots();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassValue>& _internal_slots() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassValue>* _internal_mutable_slots();
  public:
  [[deprecated]] const ::nvidia::riva::nlp::TokenClassValue& slots(int index) const;
  [[deprecated]] ::nvidia::riva::nlp::TokenClassValue* add_slots();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::TokenClassValue >&
      slots() const;
  // string domain_str = 3 [deprecated = true];
  [[deprecated]]  void clear_domain_str() ;
  [[deprecated]] const std::string& domain_str() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_domain_str(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_domain_str();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_domain_str();
  [[deprecated]] void set_allocated_domain_str(std::string* value);

  private:
  const std::string& _internal_domain_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain_str(
      const std::string& value);
  std::string* _internal_mutable_domain_str();

  public:
  // .nvidia.riva.nlp.Classification intent = 1 [deprecated = true];
  [[deprecated]]  bool has_intent() const;
  [[deprecated]]  void clear_intent() ;
  [[deprecated]] const ::nvidia::riva::nlp::Classification& intent() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::nlp::Classification* release_intent();
  [[deprecated]] ::nvidia::riva::nlp::Classification* mutable_intent();
  [[deprecated]] void set_allocated_intent(::nvidia::riva::nlp::Classification* value);
  [[deprecated]] void unsafe_arena_set_allocated_intent(::nvidia::riva::nlp::Classification* value);
  [[deprecated]] ::nvidia::riva::nlp::Classification* unsafe_arena_release_intent();

  private:
  const ::nvidia::riva::nlp::Classification& _internal_intent() const;
  ::nvidia::riva::nlp::Classification* _internal_mutable_intent();

  public:
  // .nvidia.riva.nlp.Classification domain = 4 [deprecated = true];
  [[deprecated]]  bool has_domain() const;
  [[deprecated]]  void clear_domain() ;
  [[deprecated]] const ::nvidia::riva::nlp::Classification& domain() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::nlp::Classification* release_domain();
  [[deprecated]] ::nvidia::riva::nlp::Classification* mutable_domain();
  [[deprecated]] void set_allocated_domain(::nvidia::riva::nlp::Classification* value);
  [[deprecated]] void unsafe_arena_set_allocated_domain(::nvidia::riva::nlp::Classification* value);
  [[deprecated]] ::nvidia::riva::nlp::Classification* unsafe_arena_release_domain();

  private:
  const ::nvidia::riva::nlp::Classification& _internal_domain() const;
  ::nvidia::riva::nlp::Classification* _internal_mutable_domain();

  public:
  // .nvidia.riva.RequestId id = 100 [deprecated = true];
  [[deprecated]]  bool has_id() const;
  [[deprecated]]  void clear_id() ;
  [[deprecated]] const ::nvidia::riva::RequestId& id() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  [[deprecated]] ::nvidia::riva::RequestId* mutable_id();
  [[deprecated]] void set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.AnalyzeIntentResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 4,
      56, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::TokenClassValue > slots_;
    ::google::protobuf::internal::ArenaStringPtr domain_str_;
    ::nvidia::riva::nlp::Classification* intent_;
    ::nvidia::riva::nlp::Classification* domain_;
    ::nvidia::riva::RequestId* id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class AnalyzeIntentRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.AnalyzeIntentRequest) */ {
 public:
  inline AnalyzeIntentRequest() : AnalyzeIntentRequest(nullptr) {}
  ~AnalyzeIntentRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnalyzeIntentRequest(::google::protobuf::internal::ConstantInitialized);

  inline AnalyzeIntentRequest(const AnalyzeIntentRequest& from)
      : AnalyzeIntentRequest(nullptr, from) {}
  AnalyzeIntentRequest(AnalyzeIntentRequest&& from) noexcept
    : AnalyzeIntentRequest() {
    *this = ::std::move(from);
  }

  inline AnalyzeIntentRequest& operator=(const AnalyzeIntentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalyzeIntentRequest& operator=(AnalyzeIntentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalyzeIntentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalyzeIntentRequest* internal_default_instance() {
    return reinterpret_cast<const AnalyzeIntentRequest*>(
               &_AnalyzeIntentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AnalyzeIntentRequest& a, AnalyzeIntentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalyzeIntentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalyzeIntentRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalyzeIntentRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnalyzeIntentRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnalyzeIntentRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnalyzeIntentRequest& from) {
    AnalyzeIntentRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnalyzeIntentRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.AnalyzeIntentRequest";
  }
  protected:
  explicit AnalyzeIntentRequest(::google::protobuf::Arena* arena);
  AnalyzeIntentRequest(::google::protobuf::Arena* arena, const AnalyzeIntentRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryFieldNumber = 1,
    kOptionsFieldNumber = 2,
    kIdFieldNumber = 100,
  };
  // string query = 1 [deprecated = true];
  [[deprecated]]  void clear_query() ;
  [[deprecated]] const std::string& query() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_query(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_query();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_query();
  [[deprecated]] void set_allocated_query(std::string* value);

  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(
      const std::string& value);
  std::string* _internal_mutable_query();

  public:
  // .nvidia.riva.nlp.AnalyzeIntentOptions options = 2 [deprecated = true];
  [[deprecated]]  bool has_options() const;
  [[deprecated]]  void clear_options() ;
  [[deprecated]] const ::nvidia::riva::nlp::AnalyzeIntentOptions& options() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::nlp::AnalyzeIntentOptions* release_options();
  [[deprecated]] ::nvidia::riva::nlp::AnalyzeIntentOptions* mutable_options();
  [[deprecated]] void set_allocated_options(::nvidia::riva::nlp::AnalyzeIntentOptions* value);
  [[deprecated]] void unsafe_arena_set_allocated_options(::nvidia::riva::nlp::AnalyzeIntentOptions* value);
  [[deprecated]] ::nvidia::riva::nlp::AnalyzeIntentOptions* unsafe_arena_release_options();

  private:
  const ::nvidia::riva::nlp::AnalyzeIntentOptions& _internal_options() const;
  ::nvidia::riva::nlp::AnalyzeIntentOptions* _internal_mutable_options();

  public:
  // .nvidia.riva.RequestId id = 100 [deprecated = true];
  [[deprecated]]  bool has_id() const;
  [[deprecated]]  void clear_id() ;
  [[deprecated]] const ::nvidia::riva::RequestId& id() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  [[deprecated]] ::nvidia::riva::RequestId* mutable_id();
  [[deprecated]] void set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.AnalyzeIntentRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      50, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr query_;
    ::nvidia::riva::nlp::AnalyzeIntentOptions* options_;
    ::nvidia::riva::RequestId* id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};// -------------------------------------------------------------------

class TokenClassResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.nlp.TokenClassResponse) */ {
 public:
  inline TokenClassResponse() : TokenClassResponse(nullptr) {}
  ~TokenClassResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TokenClassResponse(::google::protobuf::internal::ConstantInitialized);

  inline TokenClassResponse(const TokenClassResponse& from)
      : TokenClassResponse(nullptr, from) {}
  TokenClassResponse(TokenClassResponse&& from) noexcept
    : TokenClassResponse() {
    *this = ::std::move(from);
  }

  inline TokenClassResponse& operator=(const TokenClassResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenClassResponse& operator=(TokenClassResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenClassResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenClassResponse* internal_default_instance() {
    return reinterpret_cast<const TokenClassResponse*>(
               &_TokenClassResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TokenClassResponse& a, TokenClassResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenClassResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenClassResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenClassResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenClassResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TokenClassResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TokenClassResponse& from) {
    TokenClassResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TokenClassResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.nlp.TokenClassResponse";
  }
  protected:
  explicit TokenClassResponse(::google::protobuf::Arena* arena);
  TokenClassResponse(::google::protobuf::Arena* arena, const TokenClassResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
    kIdFieldNumber = 100,
  };
  // repeated .nvidia.riva.nlp.TokenClassSequence results = 1 [deprecated = true];
  [[deprecated]]  int results_size() const;
  private:
  int _internal_results_size() const;

  public:
  [[deprecated]]  void clear_results() ;
  [[deprecated]] ::nvidia::riva::nlp::TokenClassSequence* mutable_results(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::TokenClassSequence >*
      mutable_results();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassSequence>& _internal_results() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassSequence>* _internal_mutable_results();
  public:
  [[deprecated]] const ::nvidia::riva::nlp::TokenClassSequence& results(int index) const;
  [[deprecated]] ::nvidia::riva::nlp::TokenClassSequence* add_results();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::TokenClassSequence >&
      results() const;
  // .nvidia.riva.RequestId id = 100 [deprecated = true];
  [[deprecated]]  bool has_id() const;
  [[deprecated]]  void clear_id() ;
  [[deprecated]] const ::nvidia::riva::RequestId& id() const;
  [[deprecated]] PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  [[deprecated]] ::nvidia::riva::RequestId* mutable_id();
  [[deprecated]] void set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  [[deprecated]] ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.nlp.TokenClassResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::nlp::TokenClassSequence > results_;
    ::nvidia::riva::RequestId* id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fnlp_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RivaNLPConfigRequest

// string model_name = 1;
inline void RivaNLPConfigRequest::clear_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& RivaNLPConfigRequest::model_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.RivaNLPConfigRequest.model_name)
  return _internal_model_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RivaNLPConfigRequest::set_model_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.RivaNLPConfigRequest.model_name)
}
inline std::string* RivaNLPConfigRequest::mutable_model_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.RivaNLPConfigRequest.model_name)
  return _s;
}
inline const std::string& RivaNLPConfigRequest::_internal_model_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.model_name_.Get();
}
inline void RivaNLPConfigRequest::_internal_set_model_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_name_.Set(value, GetArena());
}
inline std::string* RivaNLPConfigRequest::_internal_mutable_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.model_name_.Mutable( GetArena());
}
inline std::string* RivaNLPConfigRequest::release_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.RivaNLPConfigRequest.model_name)
  return _impl_.model_name_.Release();
}
inline void RivaNLPConfigRequest::set_allocated_model_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.model_name_.IsDefault()) {
          _impl_.model_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.RivaNLPConfigRequest.model_name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RivaNLPConfigResponse_Config

// string model_name = 1;
inline void RivaNLPConfigResponse_Config::clear_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& RivaNLPConfigResponse_Config::model_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.RivaNLPConfigResponse.Config.model_name)
  return _internal_model_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RivaNLPConfigResponse_Config::set_model_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.RivaNLPConfigResponse.Config.model_name)
}
inline std::string* RivaNLPConfigResponse_Config::mutable_model_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.RivaNLPConfigResponse.Config.model_name)
  return _s;
}
inline const std::string& RivaNLPConfigResponse_Config::_internal_model_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.model_name_.Get();
}
inline void RivaNLPConfigResponse_Config::_internal_set_model_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_name_.Set(value, GetArena());
}
inline std::string* RivaNLPConfigResponse_Config::_internal_mutable_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.model_name_.Mutable( GetArena());
}
inline std::string* RivaNLPConfigResponse_Config::release_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.RivaNLPConfigResponse.Config.model_name)
  return _impl_.model_name_.Release();
}
inline void RivaNLPConfigResponse_Config::set_allocated_model_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.model_name_.IsDefault()) {
          _impl_.model_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.RivaNLPConfigResponse.Config.model_name)
}

// map<string, string> parameters = 2;
inline int RivaNLPConfigResponse_Config::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int RivaNLPConfigResponse_Config::parameters_size() const {
  return _internal_parameters_size();
}
inline void RivaNLPConfigResponse_Config::clear_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& RivaNLPConfigResponse_Config::_internal_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& RivaNLPConfigResponse_Config::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:nvidia.riva.nlp.RivaNLPConfigResponse.Config.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* RivaNLPConfigResponse_Config::_internal_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* RivaNLPConfigResponse_Config::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:nvidia.riva.nlp.RivaNLPConfigResponse.Config.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// RivaNLPConfigResponse

// repeated .nvidia.riva.nlp.RivaNLPConfigResponse.Config model_config = 1;
inline int RivaNLPConfigResponse::_internal_model_config_size() const {
  return _internal_model_config().size();
}
inline int RivaNLPConfigResponse::model_config_size() const {
  return _internal_model_config_size();
}
inline void RivaNLPConfigResponse::clear_model_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_config_.Clear();
}
inline ::nvidia::riva::nlp::RivaNLPConfigResponse_Config* RivaNLPConfigResponse::mutable_model_config(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.RivaNLPConfigResponse.model_config)
  return _internal_mutable_model_config()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::RivaNLPConfigResponse_Config>* RivaNLPConfigResponse::mutable_model_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.nlp.RivaNLPConfigResponse.model_config)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_model_config();
}
inline const ::nvidia::riva::nlp::RivaNLPConfigResponse_Config& RivaNLPConfigResponse::model_config(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.RivaNLPConfigResponse.model_config)
  return _internal_model_config().Get(index);
}
inline ::nvidia::riva::nlp::RivaNLPConfigResponse_Config* RivaNLPConfigResponse::add_model_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::nlp::RivaNLPConfigResponse_Config* _add = _internal_mutable_model_config()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.RivaNLPConfigResponse.model_config)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::RivaNLPConfigResponse_Config>& RivaNLPConfigResponse::model_config() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.nlp.RivaNLPConfigResponse.model_config)
  return _internal_model_config();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::RivaNLPConfigResponse_Config>&
RivaNLPConfigResponse::_internal_model_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.model_config_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::RivaNLPConfigResponse_Config>*
RivaNLPConfigResponse::_internal_mutable_model_config() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.model_config_;
}

// -------------------------------------------------------------------

// NLPModelParams

// string model_name = 1;
inline void NLPModelParams::clear_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& NLPModelParams::model_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.NLPModelParams.model_name)
  return _internal_model_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NLPModelParams::set_model_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.NLPModelParams.model_name)
}
inline std::string* NLPModelParams::mutable_model_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.NLPModelParams.model_name)
  return _s;
}
inline const std::string& NLPModelParams::_internal_model_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.model_name_.Get();
}
inline void NLPModelParams::_internal_set_model_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_name_.Set(value, GetArena());
}
inline std::string* NLPModelParams::_internal_mutable_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.model_name_.Mutable( GetArena());
}
inline std::string* NLPModelParams::release_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.NLPModelParams.model_name)
  return _impl_.model_name_.Release();
}
inline void NLPModelParams::set_allocated_model_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.model_name_.IsDefault()) {
          _impl_.model_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.NLPModelParams.model_name)
}

// string language_code = 3;
inline void NLPModelParams::clear_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_code_.ClearToEmpty();
}
inline const std::string& NLPModelParams::language_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.NLPModelParams.language_code)
  return _internal_language_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NLPModelParams::set_language_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.NLPModelParams.language_code)
}
inline std::string* NLPModelParams::mutable_language_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_language_code();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.NLPModelParams.language_code)
  return _s;
}
inline const std::string& NLPModelParams::_internal_language_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.language_code_.Get();
}
inline void NLPModelParams::_internal_set_language_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_code_.Set(value, GetArena());
}
inline std::string* NLPModelParams::_internal_mutable_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.language_code_.Mutable( GetArena());
}
inline std::string* NLPModelParams::release_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.NLPModelParams.language_code)
  return _impl_.language_code_.Release();
}
inline void NLPModelParams::set_allocated_language_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.language_code_.IsDefault()) {
          _impl_.language_code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.NLPModelParams.language_code)
}

// -------------------------------------------------------------------

// TextTransformRequest

// repeated string text = 1;
inline int TextTransformRequest::_internal_text_size() const {
  return _internal_text().size();
}
inline int TextTransformRequest::text_size() const {
  return _internal_text_size();
}
inline void TextTransformRequest::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.Clear();
}
inline std::string* TextTransformRequest::add_text()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_text()->Add();
  // @@protoc_insertion_point(field_add_mutable:nvidia.riva.nlp.TextTransformRequest.text)
  return _s;
}
inline const std::string& TextTransformRequest::text(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TextTransformRequest.text)
  return _internal_text().Get(index);
}
inline std::string* TextTransformRequest::mutable_text(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TextTransformRequest.text)
  return _internal_mutable_text()->Mutable(index);
}
inline void TextTransformRequest::set_text(int index, const std::string& value) {
  _internal_mutable_text()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.TextTransformRequest.text)
}
inline void TextTransformRequest::set_text(int index, std::string&& value) {
  _internal_mutable_text()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.TextTransformRequest.text)
}
inline void TextTransformRequest::set_text(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_text()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nvidia.riva.nlp.TextTransformRequest.text)
}
inline void TextTransformRequest::set_text(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_text()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nvidia.riva.nlp.TextTransformRequest.text)
}
inline void TextTransformRequest::set_text(int index, absl::string_view value) {
  _internal_mutable_text()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:nvidia.riva.nlp.TextTransformRequest.text)
}
inline void TextTransformRequest::add_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.TextTransformRequest.text)
}
inline void TextTransformRequest::add_text(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.TextTransformRequest.text)
}
inline void TextTransformRequest::add_text(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nvidia.riva.nlp.TextTransformRequest.text)
}
inline void TextTransformRequest::add_text(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nvidia.riva.nlp.TextTransformRequest.text)
}
inline void TextTransformRequest::add_text(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:nvidia.riva.nlp.TextTransformRequest.text)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TextTransformRequest::text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.nlp.TextTransformRequest.text)
  return _internal_text();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TextTransformRequest::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.nlp.TextTransformRequest.text)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_text();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TextTransformRequest::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TextTransformRequest::_internal_mutable_text() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.text_;
}

// uint32 top_n = 2;
inline void TextTransformRequest::clear_top_n() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_n_ = 0u;
}
inline ::uint32_t TextTransformRequest::top_n() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TextTransformRequest.top_n)
  return _internal_top_n();
}
inline void TextTransformRequest::set_top_n(::uint32_t value) {
  _internal_set_top_n(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.TextTransformRequest.top_n)
}
inline ::uint32_t TextTransformRequest::_internal_top_n() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.top_n_;
}
inline void TextTransformRequest::_internal_set_top_n(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.top_n_ = value;
}

// .nvidia.riva.nlp.NLPModelParams model = 3;
inline bool TextTransformRequest::has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_ != nullptr);
  return value;
}
inline void TextTransformRequest::clear_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.model_ != nullptr) _impl_.model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nvidia::riva::nlp::NLPModelParams& TextTransformRequest::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::nlp::NLPModelParams* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::nlp::NLPModelParams&>(::nvidia::riva::nlp::_NLPModelParams_default_instance_);
}
inline const ::nvidia::riva::nlp::NLPModelParams& TextTransformRequest::model() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TextTransformRequest.model)
  return _internal_model();
}
inline void TextTransformRequest::unsafe_arena_set_allocated_model(::nvidia::riva::nlp::NLPModelParams* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = reinterpret_cast<::nvidia::riva::nlp::NLPModelParams*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.TextTransformRequest.model)
}
inline ::nvidia::riva::nlp::NLPModelParams* TextTransformRequest::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::nlp::NLPModelParams* released = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::nlp::NLPModelParams* TextTransformRequest::unsafe_arena_release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.TextTransformRequest.model)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::nlp::NLPModelParams* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::nvidia::riva::nlp::NLPModelParams* TextTransformRequest::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::nlp::NLPModelParams>(GetArena());
    _impl_.model_ = reinterpret_cast<::nvidia::riva::nlp::NLPModelParams*>(p);
  }
  return _impl_.model_;
}
inline ::nvidia::riva::nlp::NLPModelParams* TextTransformRequest::mutable_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::nlp::NLPModelParams* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TextTransformRequest.model)
  return _msg;
}
inline void TextTransformRequest::set_allocated_model(::nvidia::riva::nlp::NLPModelParams* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::nvidia::riva::nlp::NLPModelParams*>(_impl_.model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::nvidia::riva::nlp::NLPModelParams*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.model_ = reinterpret_cast<::nvidia::riva::nlp::NLPModelParams*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.TextTransformRequest.model)
}

// .nvidia.riva.RequestId id = 100;
inline bool TextTransformRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& TextTransformRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& TextTransformRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TextTransformRequest.id)
  return _internal_id();
}
inline void TextTransformRequest::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.TextTransformRequest.id)
}
inline ::nvidia::riva::RequestId* TextTransformRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* TextTransformRequest::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.TextTransformRequest.id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* TextTransformRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* TextTransformRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TextTransformRequest.id)
  return _msg;
}
inline void TextTransformRequest::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.TextTransformRequest.id)
}

// -------------------------------------------------------------------

// TextTransformResponse

// repeated string text = 1;
inline int TextTransformResponse::_internal_text_size() const {
  return _internal_text().size();
}
inline int TextTransformResponse::text_size() const {
  return _internal_text_size();
}
inline void TextTransformResponse::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.Clear();
}
inline std::string* TextTransformResponse::add_text()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_text()->Add();
  // @@protoc_insertion_point(field_add_mutable:nvidia.riva.nlp.TextTransformResponse.text)
  return _s;
}
inline const std::string& TextTransformResponse::text(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TextTransformResponse.text)
  return _internal_text().Get(index);
}
inline std::string* TextTransformResponse::mutable_text(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TextTransformResponse.text)
  return _internal_mutable_text()->Mutable(index);
}
inline void TextTransformResponse::set_text(int index, const std::string& value) {
  _internal_mutable_text()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.TextTransformResponse.text)
}
inline void TextTransformResponse::set_text(int index, std::string&& value) {
  _internal_mutable_text()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.TextTransformResponse.text)
}
inline void TextTransformResponse::set_text(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_text()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nvidia.riva.nlp.TextTransformResponse.text)
}
inline void TextTransformResponse::set_text(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_text()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nvidia.riva.nlp.TextTransformResponse.text)
}
inline void TextTransformResponse::set_text(int index, absl::string_view value) {
  _internal_mutable_text()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:nvidia.riva.nlp.TextTransformResponse.text)
}
inline void TextTransformResponse::add_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.TextTransformResponse.text)
}
inline void TextTransformResponse::add_text(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.TextTransformResponse.text)
}
inline void TextTransformResponse::add_text(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nvidia.riva.nlp.TextTransformResponse.text)
}
inline void TextTransformResponse::add_text(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nvidia.riva.nlp.TextTransformResponse.text)
}
inline void TextTransformResponse::add_text(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:nvidia.riva.nlp.TextTransformResponse.text)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TextTransformResponse::text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.nlp.TextTransformResponse.text)
  return _internal_text();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TextTransformResponse::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.nlp.TextTransformResponse.text)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_text();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TextTransformResponse::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TextTransformResponse::_internal_mutable_text() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.text_;
}

// .nvidia.riva.RequestId id = 100;
inline bool TextTransformResponse::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& TextTransformResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& TextTransformResponse::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TextTransformResponse.id)
  return _internal_id();
}
inline void TextTransformResponse::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.TextTransformResponse.id)
}
inline ::nvidia::riva::RequestId* TextTransformResponse::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* TextTransformResponse::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.TextTransformResponse.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* TextTransformResponse::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* TextTransformResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TextTransformResponse.id)
  return _msg;
}
inline void TextTransformResponse::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.TextTransformResponse.id)
}

// -------------------------------------------------------------------

// TextClassRequest

// repeated string text = 1 [deprecated = true];
inline int TextClassRequest::_internal_text_size() const {
  return _internal_text().size();
}
inline int TextClassRequest::text_size() const {
  return _internal_text_size();
}
inline void TextClassRequest::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.Clear();
}
inline std::string* TextClassRequest::add_text()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_text()->Add();
  // @@protoc_insertion_point(field_add_mutable:nvidia.riva.nlp.TextClassRequest.text)
  return _s;
}
inline const std::string& TextClassRequest::text(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TextClassRequest.text)
  return _internal_text().Get(index);
}
inline std::string* TextClassRequest::mutable_text(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TextClassRequest.text)
  return _internal_mutable_text()->Mutable(index);
}
inline void TextClassRequest::set_text(int index, const std::string& value) {
  _internal_mutable_text()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.TextClassRequest.text)
}
inline void TextClassRequest::set_text(int index, std::string&& value) {
  _internal_mutable_text()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.TextClassRequest.text)
}
inline void TextClassRequest::set_text(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_text()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nvidia.riva.nlp.TextClassRequest.text)
}
inline void TextClassRequest::set_text(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_text()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nvidia.riva.nlp.TextClassRequest.text)
}
inline void TextClassRequest::set_text(int index, absl::string_view value) {
  _internal_mutable_text()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:nvidia.riva.nlp.TextClassRequest.text)
}
inline void TextClassRequest::add_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.TextClassRequest.text)
}
inline void TextClassRequest::add_text(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.TextClassRequest.text)
}
inline void TextClassRequest::add_text(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nvidia.riva.nlp.TextClassRequest.text)
}
inline void TextClassRequest::add_text(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nvidia.riva.nlp.TextClassRequest.text)
}
inline void TextClassRequest::add_text(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:nvidia.riva.nlp.TextClassRequest.text)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TextClassRequest::text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.nlp.TextClassRequest.text)
  return _internal_text();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TextClassRequest::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.nlp.TextClassRequest.text)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_text();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TextClassRequest::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TextClassRequest::_internal_mutable_text() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.text_;
}

// uint32 top_n = 2 [deprecated = true];
inline void TextClassRequest::clear_top_n() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_n_ = 0u;
}
inline ::uint32_t TextClassRequest::top_n() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TextClassRequest.top_n)
  return _internal_top_n();
}
inline void TextClassRequest::set_top_n(::uint32_t value) {
  _internal_set_top_n(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.TextClassRequest.top_n)
}
inline ::uint32_t TextClassRequest::_internal_top_n() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.top_n_;
}
inline void TextClassRequest::_internal_set_top_n(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.top_n_ = value;
}

// .nvidia.riva.nlp.NLPModelParams model = 3 [deprecated = true];
inline bool TextClassRequest::has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_ != nullptr);
  return value;
}
inline void TextClassRequest::clear_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.model_ != nullptr) _impl_.model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nvidia::riva::nlp::NLPModelParams& TextClassRequest::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::nlp::NLPModelParams* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::nlp::NLPModelParams&>(::nvidia::riva::nlp::_NLPModelParams_default_instance_);
}
inline const ::nvidia::riva::nlp::NLPModelParams& TextClassRequest::model() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TextClassRequest.model)
  return _internal_model();
}
inline void TextClassRequest::unsafe_arena_set_allocated_model(::nvidia::riva::nlp::NLPModelParams* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = reinterpret_cast<::nvidia::riva::nlp::NLPModelParams*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.TextClassRequest.model)
}
inline ::nvidia::riva::nlp::NLPModelParams* TextClassRequest::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::nlp::NLPModelParams* released = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::nlp::NLPModelParams* TextClassRequest::unsafe_arena_release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.TextClassRequest.model)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::nlp::NLPModelParams* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::nvidia::riva::nlp::NLPModelParams* TextClassRequest::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::nlp::NLPModelParams>(GetArena());
    _impl_.model_ = reinterpret_cast<::nvidia::riva::nlp::NLPModelParams*>(p);
  }
  return _impl_.model_;
}
inline ::nvidia::riva::nlp::NLPModelParams* TextClassRequest::mutable_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::nlp::NLPModelParams* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TextClassRequest.model)
  return _msg;
}
inline void TextClassRequest::set_allocated_model(::nvidia::riva::nlp::NLPModelParams* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::nvidia::riva::nlp::NLPModelParams*>(_impl_.model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::nvidia::riva::nlp::NLPModelParams*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.model_ = reinterpret_cast<::nvidia::riva::nlp::NLPModelParams*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.TextClassRequest.model)
}

// .nvidia.riva.RequestId id = 100 [deprecated = true];
inline bool TextClassRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& TextClassRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& TextClassRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TextClassRequest.id)
  return _internal_id();
}
inline void TextClassRequest::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.TextClassRequest.id)
}
inline ::nvidia::riva::RequestId* TextClassRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* TextClassRequest::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.TextClassRequest.id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* TextClassRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* TextClassRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TextClassRequest.id)
  return _msg;
}
inline void TextClassRequest::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.TextClassRequest.id)
}

// -------------------------------------------------------------------

// Classification

// string class_name = 1 [deprecated = true];
inline void Classification::clear_class_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.class_name_.ClearToEmpty();
}
inline const std::string& Classification::class_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.Classification.class_name)
  return _internal_class_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Classification::set_class_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.class_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.Classification.class_name)
}
inline std::string* Classification::mutable_class_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.Classification.class_name)
  return _s;
}
inline const std::string& Classification::_internal_class_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.class_name_.Get();
}
inline void Classification::_internal_set_class_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.class_name_.Set(value, GetArena());
}
inline std::string* Classification::_internal_mutable_class_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.class_name_.Mutable( GetArena());
}
inline std::string* Classification::release_class_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.Classification.class_name)
  return _impl_.class_name_.Release();
}
inline void Classification::set_allocated_class_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.class_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.class_name_.IsDefault()) {
          _impl_.class_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.Classification.class_name)
}

// float score = 2 [deprecated = true];
inline void Classification::clear_score() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.score_ = 0;
}
inline float Classification::score() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.Classification.score)
  return _internal_score();
}
inline void Classification::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.Classification.score)
}
inline float Classification::_internal_score() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.score_;
}
inline void Classification::_internal_set_score(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.score_ = value;
}

// -------------------------------------------------------------------

// Span

// uint32 start = 1 [deprecated = true];
inline void Span::clear_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_ = 0u;
}
inline ::uint32_t Span::start() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.Span.start)
  return _internal_start();
}
inline void Span::set_start(::uint32_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.Span.start)
}
inline ::uint32_t Span::_internal_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_;
}
inline void Span::_internal_set_start(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_ = value;
}

// uint32 end = 2 [deprecated = true];
inline void Span::clear_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_ = 0u;
}
inline ::uint32_t Span::end() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.Span.end)
  return _internal_end();
}
inline void Span::set_end(::uint32_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.Span.end)
}
inline ::uint32_t Span::_internal_end() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_;
}
inline void Span::_internal_set_end(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_ = value;
}

// -------------------------------------------------------------------

// ClassificationResult

// repeated .nvidia.riva.nlp.Classification labels = 1 [deprecated = true];
inline int ClassificationResult::_internal_labels_size() const {
  return _internal_labels().size();
}
inline int ClassificationResult::labels_size() const {
  return _internal_labels_size();
}
inline void ClassificationResult::clear_labels() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.labels_.Clear();
}
inline ::nvidia::riva::nlp::Classification* ClassificationResult::mutable_labels(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.ClassificationResult.labels)
  return _internal_mutable_labels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Classification>* ClassificationResult::mutable_labels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.nlp.ClassificationResult.labels)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_labels();
}
inline const ::nvidia::riva::nlp::Classification& ClassificationResult::labels(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.ClassificationResult.labels)
  return _internal_labels().Get(index);
}
inline ::nvidia::riva::nlp::Classification* ClassificationResult::add_labels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::nlp::Classification* _add = _internal_mutable_labels()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.ClassificationResult.labels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Classification>& ClassificationResult::labels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.nlp.ClassificationResult.labels)
  return _internal_labels();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Classification>&
ClassificationResult::_internal_labels() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.labels_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Classification>*
ClassificationResult::_internal_mutable_labels() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.labels_;
}

// -------------------------------------------------------------------

// TextClassResponse

// repeated .nvidia.riva.nlp.ClassificationResult results = 1 [deprecated = true];
inline int TextClassResponse::_internal_results_size() const {
  return _internal_results().size();
}
inline int TextClassResponse::results_size() const {
  return _internal_results_size();
}
inline void TextClassResponse::clear_results() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.results_.Clear();
}
inline ::nvidia::riva::nlp::ClassificationResult* TextClassResponse::mutable_results(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TextClassResponse.results)
  return _internal_mutable_results()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::ClassificationResult>* TextClassResponse::mutable_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.nlp.TextClassResponse.results)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_results();
}
inline const ::nvidia::riva::nlp::ClassificationResult& TextClassResponse::results(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TextClassResponse.results)
  return _internal_results().Get(index);
}
inline ::nvidia::riva::nlp::ClassificationResult* TextClassResponse::add_results() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::nlp::ClassificationResult* _add = _internal_mutable_results()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.TextClassResponse.results)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::ClassificationResult>& TextClassResponse::results() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.nlp.TextClassResponse.results)
  return _internal_results();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::ClassificationResult>&
TextClassResponse::_internal_results() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.results_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::ClassificationResult>*
TextClassResponse::_internal_mutable_results() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.results_;
}

// .nvidia.riva.RequestId id = 100 [deprecated = true];
inline bool TextClassResponse::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& TextClassResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& TextClassResponse::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TextClassResponse.id)
  return _internal_id();
}
inline void TextClassResponse::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.TextClassResponse.id)
}
inline ::nvidia::riva::RequestId* TextClassResponse::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* TextClassResponse::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.TextClassResponse.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* TextClassResponse::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* TextClassResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TextClassResponse.id)
  return _msg;
}
inline void TextClassResponse::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.TextClassResponse.id)
}

// -------------------------------------------------------------------

// TokenClassRequest

// repeated string text = 1 [deprecated = true];
inline int TokenClassRequest::_internal_text_size() const {
  return _internal_text().size();
}
inline int TokenClassRequest::text_size() const {
  return _internal_text_size();
}
inline void TokenClassRequest::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.Clear();
}
inline std::string* TokenClassRequest::add_text()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_text()->Add();
  // @@protoc_insertion_point(field_add_mutable:nvidia.riva.nlp.TokenClassRequest.text)
  return _s;
}
inline const std::string& TokenClassRequest::text(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TokenClassRequest.text)
  return _internal_text().Get(index);
}
inline std::string* TokenClassRequest::mutable_text(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TokenClassRequest.text)
  return _internal_mutable_text()->Mutable(index);
}
inline void TokenClassRequest::set_text(int index, const std::string& value) {
  _internal_mutable_text()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.TokenClassRequest.text)
}
inline void TokenClassRequest::set_text(int index, std::string&& value) {
  _internal_mutable_text()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.TokenClassRequest.text)
}
inline void TokenClassRequest::set_text(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_text()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nvidia.riva.nlp.TokenClassRequest.text)
}
inline void TokenClassRequest::set_text(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_text()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nvidia.riva.nlp.TokenClassRequest.text)
}
inline void TokenClassRequest::set_text(int index, absl::string_view value) {
  _internal_mutable_text()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:nvidia.riva.nlp.TokenClassRequest.text)
}
inline void TokenClassRequest::add_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.TokenClassRequest.text)
}
inline void TokenClassRequest::add_text(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.TokenClassRequest.text)
}
inline void TokenClassRequest::add_text(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nvidia.riva.nlp.TokenClassRequest.text)
}
inline void TokenClassRequest::add_text(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nvidia.riva.nlp.TokenClassRequest.text)
}
inline void TokenClassRequest::add_text(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_text()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:nvidia.riva.nlp.TokenClassRequest.text)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TokenClassRequest::text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.nlp.TokenClassRequest.text)
  return _internal_text();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TokenClassRequest::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.nlp.TokenClassRequest.text)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_text();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TokenClassRequest::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TokenClassRequest::_internal_mutable_text() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.text_;
}

// uint32 top_n = 3 [deprecated = true];
inline void TokenClassRequest::clear_top_n() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_n_ = 0u;
}
inline ::uint32_t TokenClassRequest::top_n() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TokenClassRequest.top_n)
  return _internal_top_n();
}
inline void TokenClassRequest::set_top_n(::uint32_t value) {
  _internal_set_top_n(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.TokenClassRequest.top_n)
}
inline ::uint32_t TokenClassRequest::_internal_top_n() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.top_n_;
}
inline void TokenClassRequest::_internal_set_top_n(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.top_n_ = value;
}

// .nvidia.riva.nlp.NLPModelParams model = 4 [deprecated = true];
inline bool TokenClassRequest::has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_ != nullptr);
  return value;
}
inline void TokenClassRequest::clear_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.model_ != nullptr) _impl_.model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nvidia::riva::nlp::NLPModelParams& TokenClassRequest::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::nlp::NLPModelParams* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::nlp::NLPModelParams&>(::nvidia::riva::nlp::_NLPModelParams_default_instance_);
}
inline const ::nvidia::riva::nlp::NLPModelParams& TokenClassRequest::model() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TokenClassRequest.model)
  return _internal_model();
}
inline void TokenClassRequest::unsafe_arena_set_allocated_model(::nvidia::riva::nlp::NLPModelParams* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = reinterpret_cast<::nvidia::riva::nlp::NLPModelParams*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.TokenClassRequest.model)
}
inline ::nvidia::riva::nlp::NLPModelParams* TokenClassRequest::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::nlp::NLPModelParams* released = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::nlp::NLPModelParams* TokenClassRequest::unsafe_arena_release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.TokenClassRequest.model)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::nlp::NLPModelParams* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::nvidia::riva::nlp::NLPModelParams* TokenClassRequest::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::nlp::NLPModelParams>(GetArena());
    _impl_.model_ = reinterpret_cast<::nvidia::riva::nlp::NLPModelParams*>(p);
  }
  return _impl_.model_;
}
inline ::nvidia::riva::nlp::NLPModelParams* TokenClassRequest::mutable_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::nlp::NLPModelParams* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TokenClassRequest.model)
  return _msg;
}
inline void TokenClassRequest::set_allocated_model(::nvidia::riva::nlp::NLPModelParams* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::nvidia::riva::nlp::NLPModelParams*>(_impl_.model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::nvidia::riva::nlp::NLPModelParams*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.model_ = reinterpret_cast<::nvidia::riva::nlp::NLPModelParams*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.TokenClassRequest.model)
}

// .nvidia.riva.RequestId id = 100 [deprecated = true];
inline bool TokenClassRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& TokenClassRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& TokenClassRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TokenClassRequest.id)
  return _internal_id();
}
inline void TokenClassRequest::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.TokenClassRequest.id)
}
inline ::nvidia::riva::RequestId* TokenClassRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* TokenClassRequest::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.TokenClassRequest.id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* TokenClassRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* TokenClassRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TokenClassRequest.id)
  return _msg;
}
inline void TokenClassRequest::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.TokenClassRequest.id)
}

// -------------------------------------------------------------------

// TokenClassValue

// string token = 1 [deprecated = true];
inline void TokenClassValue::clear_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& TokenClassValue::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TokenClassValue.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenClassValue::set_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.TokenClassValue.token)
}
inline std::string* TokenClassValue::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TokenClassValue.token)
  return _s;
}
inline const std::string& TokenClassValue::_internal_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.token_.Get();
}
inline void TokenClassValue::_internal_set_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.token_.Set(value, GetArena());
}
inline std::string* TokenClassValue::_internal_mutable_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* TokenClassValue::release_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.TokenClassValue.token)
  return _impl_.token_.Release();
}
inline void TokenClassValue::set_allocated_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault()) {
          _impl_.token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.TokenClassValue.token)
}

// repeated .nvidia.riva.nlp.Classification label = 2 [deprecated = true];
inline int TokenClassValue::_internal_label_size() const {
  return _internal_label().size();
}
inline int TokenClassValue::label_size() const {
  return _internal_label_size();
}
inline void TokenClassValue::clear_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.label_.Clear();
}
inline ::nvidia::riva::nlp::Classification* TokenClassValue::mutable_label(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TokenClassValue.label)
  return _internal_mutable_label()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Classification>* TokenClassValue::mutable_label()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.nlp.TokenClassValue.label)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_label();
}
inline const ::nvidia::riva::nlp::Classification& TokenClassValue::label(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TokenClassValue.label)
  return _internal_label().Get(index);
}
inline ::nvidia::riva::nlp::Classification* TokenClassValue::add_label() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::nlp::Classification* _add = _internal_mutable_label()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.TokenClassValue.label)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Classification>& TokenClassValue::label() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.nlp.TokenClassValue.label)
  return _internal_label();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Classification>&
TokenClassValue::_internal_label() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.label_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Classification>*
TokenClassValue::_internal_mutable_label() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.label_;
}

// repeated .nvidia.riva.nlp.Span span = 3 [deprecated = true];
inline int TokenClassValue::_internal_span_size() const {
  return _internal_span().size();
}
inline int TokenClassValue::span_size() const {
  return _internal_span_size();
}
inline void TokenClassValue::clear_span() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.span_.Clear();
}
inline ::nvidia::riva::nlp::Span* TokenClassValue::mutable_span(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TokenClassValue.span)
  return _internal_mutable_span()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Span>* TokenClassValue::mutable_span()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.nlp.TokenClassValue.span)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_span();
}
inline const ::nvidia::riva::nlp::Span& TokenClassValue::span(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TokenClassValue.span)
  return _internal_span().Get(index);
}
inline ::nvidia::riva::nlp::Span* TokenClassValue::add_span() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::nlp::Span* _add = _internal_mutable_span()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.TokenClassValue.span)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Span>& TokenClassValue::span() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.nlp.TokenClassValue.span)
  return _internal_span();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Span>&
TokenClassValue::_internal_span() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.span_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::Span>*
TokenClassValue::_internal_mutable_span() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.span_;
}

// -------------------------------------------------------------------

// TokenClassSequence

// repeated .nvidia.riva.nlp.TokenClassValue results = 1 [deprecated = true];
inline int TokenClassSequence::_internal_results_size() const {
  return _internal_results().size();
}
inline int TokenClassSequence::results_size() const {
  return _internal_results_size();
}
inline void TokenClassSequence::clear_results() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.results_.Clear();
}
inline ::nvidia::riva::nlp::TokenClassValue* TokenClassSequence::mutable_results(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TokenClassSequence.results)
  return _internal_mutable_results()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassValue>* TokenClassSequence::mutable_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.nlp.TokenClassSequence.results)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_results();
}
inline const ::nvidia::riva::nlp::TokenClassValue& TokenClassSequence::results(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TokenClassSequence.results)
  return _internal_results().Get(index);
}
inline ::nvidia::riva::nlp::TokenClassValue* TokenClassSequence::add_results() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::nlp::TokenClassValue* _add = _internal_mutable_results()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.TokenClassSequence.results)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassValue>& TokenClassSequence::results() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.nlp.TokenClassSequence.results)
  return _internal_results();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassValue>&
TokenClassSequence::_internal_results() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.results_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassValue>*
TokenClassSequence::_internal_mutable_results() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.results_;
}

// -------------------------------------------------------------------

// TokenClassResponse

// repeated .nvidia.riva.nlp.TokenClassSequence results = 1 [deprecated = true];
inline int TokenClassResponse::_internal_results_size() const {
  return _internal_results().size();
}
inline int TokenClassResponse::results_size() const {
  return _internal_results_size();
}
inline void TokenClassResponse::clear_results() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.results_.Clear();
}
inline ::nvidia::riva::nlp::TokenClassSequence* TokenClassResponse::mutable_results(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TokenClassResponse.results)
  return _internal_mutable_results()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassSequence>* TokenClassResponse::mutable_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.nlp.TokenClassResponse.results)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_results();
}
inline const ::nvidia::riva::nlp::TokenClassSequence& TokenClassResponse::results(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TokenClassResponse.results)
  return _internal_results().Get(index);
}
inline ::nvidia::riva::nlp::TokenClassSequence* TokenClassResponse::add_results() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::nlp::TokenClassSequence* _add = _internal_mutable_results()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.TokenClassResponse.results)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassSequence>& TokenClassResponse::results() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.nlp.TokenClassResponse.results)
  return _internal_results();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassSequence>&
TokenClassResponse::_internal_results() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.results_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassSequence>*
TokenClassResponse::_internal_mutable_results() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.results_;
}

// .nvidia.riva.RequestId id = 100 [deprecated = true];
inline bool TokenClassResponse::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& TokenClassResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& TokenClassResponse::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.TokenClassResponse.id)
  return _internal_id();
}
inline void TokenClassResponse::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.TokenClassResponse.id)
}
inline ::nvidia::riva::RequestId* TokenClassResponse::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* TokenClassResponse::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.TokenClassResponse.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* TokenClassResponse::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* TokenClassResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.TokenClassResponse.id)
  return _msg;
}
inline void TokenClassResponse::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.TokenClassResponse.id)
}

// -------------------------------------------------------------------

// AnalyzeIntentContext

// -------------------------------------------------------------------

// AnalyzeIntentOptions

// string previous_intent = 1 [deprecated = true];
inline bool AnalyzeIntentOptions::has_previous_intent() const {
  return context_case() == kPreviousIntent;
}
inline void AnalyzeIntentOptions::set_has_previous_intent() {
  _impl_._oneof_case_[0] = kPreviousIntent;
}
inline void AnalyzeIntentOptions::clear_previous_intent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (context_case() == kPreviousIntent) {
    _impl_.context_.previous_intent_.Destroy();
    clear_has_context();
  }
}
inline const std::string& AnalyzeIntentOptions::previous_intent() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeIntentOptions.previous_intent)
  return _internal_previous_intent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AnalyzeIntentOptions::set_previous_intent(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (context_case() != kPreviousIntent) {
    clear_context();

    set_has_previous_intent();
    _impl_.context_.previous_intent_.InitDefault();
  }
  _impl_.context_.previous_intent_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.AnalyzeIntentOptions.previous_intent)
}
inline std::string* AnalyzeIntentOptions::mutable_previous_intent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_previous_intent();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeIntentOptions.previous_intent)
  return _s;
}
inline const std::string& AnalyzeIntentOptions::_internal_previous_intent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (context_case() != kPreviousIntent) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.context_.previous_intent_.Get();
}
inline void AnalyzeIntentOptions::_internal_set_previous_intent(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (context_case() != kPreviousIntent) {
    clear_context();

    set_has_previous_intent();
    _impl_.context_.previous_intent_.InitDefault();
  }
  _impl_.context_.previous_intent_.Set(value, GetArena());
}
inline std::string* AnalyzeIntentOptions::_internal_mutable_previous_intent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (context_case() != kPreviousIntent) {
    clear_context();

    set_has_previous_intent();
    _impl_.context_.previous_intent_.InitDefault();
  }
  return _impl_.context_.previous_intent_.Mutable( GetArena());
}
inline std::string* AnalyzeIntentOptions::release_previous_intent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.AnalyzeIntentOptions.previous_intent)
  if (context_case() != kPreviousIntent) {
    return nullptr;
  }
  clear_has_context();
  return _impl_.context_.previous_intent_.Release();
}
inline void AnalyzeIntentOptions::set_allocated_previous_intent(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_context()) {
    clear_context();
  }
  if (value != nullptr) {
    set_has_previous_intent();
    _impl_.context_.previous_intent_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.AnalyzeIntentOptions.previous_intent)
}

// .nvidia.riva.nlp.AnalyzeIntentContext vectors = 2 [deprecated = true];
inline bool AnalyzeIntentOptions::has_vectors() const {
  return context_case() == kVectors;
}
inline bool AnalyzeIntentOptions::_internal_has_vectors() const {
  return context_case() == kVectors;
}
inline void AnalyzeIntentOptions::set_has_vectors() {
  _impl_._oneof_case_[0] = kVectors;
}
inline void AnalyzeIntentOptions::clear_vectors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (context_case() == kVectors) {
    if (GetArena() == nullptr) {
      delete _impl_.context_.vectors_;
    }
    clear_has_context();
  }
}
inline ::nvidia::riva::nlp::AnalyzeIntentContext* AnalyzeIntentOptions::release_vectors() {
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.AnalyzeIntentOptions.vectors)
  if (context_case() == kVectors) {
    clear_has_context();
    auto* temp = _impl_.context_.vectors_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.context_.vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nvidia::riva::nlp::AnalyzeIntentContext& AnalyzeIntentOptions::_internal_vectors() const {
  return context_case() == kVectors ? *_impl_.context_.vectors_ : reinterpret_cast<::nvidia::riva::nlp::AnalyzeIntentContext&>(::nvidia::riva::nlp::_AnalyzeIntentContext_default_instance_);
}
inline const ::nvidia::riva::nlp::AnalyzeIntentContext& AnalyzeIntentOptions::vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeIntentOptions.vectors)
  return _internal_vectors();
}
inline ::nvidia::riva::nlp::AnalyzeIntentContext* AnalyzeIntentOptions::unsafe_arena_release_vectors() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nvidia.riva.nlp.AnalyzeIntentOptions.vectors)
  if (context_case() == kVectors) {
    clear_has_context();
    auto* temp = _impl_.context_.vectors_;
    _impl_.context_.vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AnalyzeIntentOptions::unsafe_arena_set_allocated_vectors(::nvidia::riva::nlp::AnalyzeIntentContext* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_context();
  if (value) {
    set_has_vectors();
    _impl_.context_.vectors_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.AnalyzeIntentOptions.vectors)
}
inline ::nvidia::riva::nlp::AnalyzeIntentContext* AnalyzeIntentOptions::_internal_mutable_vectors() {
  if (context_case() != kVectors) {
    clear_context();
    set_has_vectors();
    _impl_.context_.vectors_ = CreateMaybeMessage<::nvidia::riva::nlp::AnalyzeIntentContext>(GetArena());
  }
  return _impl_.context_.vectors_;
}
inline ::nvidia::riva::nlp::AnalyzeIntentContext* AnalyzeIntentOptions::mutable_vectors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::nlp::AnalyzeIntentContext* _msg = _internal_mutable_vectors();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeIntentOptions.vectors)
  return _msg;
}

// string domain = 3 [deprecated = true];
inline void AnalyzeIntentOptions::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.ClearToEmpty();
}
inline const std::string& AnalyzeIntentOptions::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeIntentOptions.domain)
  return _internal_domain();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AnalyzeIntentOptions::set_domain(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.domain_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.AnalyzeIntentOptions.domain)
}
inline std::string* AnalyzeIntentOptions::mutable_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeIntentOptions.domain)
  return _s;
}
inline const std::string& AnalyzeIntentOptions::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_.Get();
}
inline void AnalyzeIntentOptions::_internal_set_domain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.domain_.Set(value, GetArena());
}
inline std::string* AnalyzeIntentOptions::_internal_mutable_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.domain_.Mutable( GetArena());
}
inline std::string* AnalyzeIntentOptions::release_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.AnalyzeIntentOptions.domain)
  return _impl_.domain_.Release();
}
inline void AnalyzeIntentOptions::set_allocated_domain(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.domain_.IsDefault()) {
          _impl_.domain_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.AnalyzeIntentOptions.domain)
}

// string lang = 4 [deprecated = true];
inline void AnalyzeIntentOptions::clear_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lang_.ClearToEmpty();
}
inline const std::string& AnalyzeIntentOptions::lang() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeIntentOptions.lang)
  return _internal_lang();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AnalyzeIntentOptions::set_lang(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lang_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.AnalyzeIntentOptions.lang)
}
inline std::string* AnalyzeIntentOptions::mutable_lang() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_lang();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeIntentOptions.lang)
  return _s;
}
inline const std::string& AnalyzeIntentOptions::_internal_lang() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lang_.Get();
}
inline void AnalyzeIntentOptions::_internal_set_lang(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lang_.Set(value, GetArena());
}
inline std::string* AnalyzeIntentOptions::_internal_mutable_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.lang_.Mutable( GetArena());
}
inline std::string* AnalyzeIntentOptions::release_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.AnalyzeIntentOptions.lang)
  return _impl_.lang_.Release();
}
inline void AnalyzeIntentOptions::set_allocated_lang(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lang_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lang_.IsDefault()) {
          _impl_.lang_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.AnalyzeIntentOptions.lang)
}

inline bool AnalyzeIntentOptions::has_context() const {
  return context_case() != CONTEXT_NOT_SET;
}
inline void AnalyzeIntentOptions::clear_has_context() {
  _impl_._oneof_case_[0] = CONTEXT_NOT_SET;
}
inline AnalyzeIntentOptions::ContextCase AnalyzeIntentOptions::context_case() const {
  return AnalyzeIntentOptions::ContextCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnalyzeIntentRequest

// string query = 1 [deprecated = true];
inline void AnalyzeIntentRequest::clear_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.query_.ClearToEmpty();
}
inline const std::string& AnalyzeIntentRequest::query() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeIntentRequest.query)
  return _internal_query();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AnalyzeIntentRequest::set_query(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.query_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.AnalyzeIntentRequest.query)
}
inline std::string* AnalyzeIntentRequest::mutable_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeIntentRequest.query)
  return _s;
}
inline const std::string& AnalyzeIntentRequest::_internal_query() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.query_.Get();
}
inline void AnalyzeIntentRequest::_internal_set_query(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.query_.Set(value, GetArena());
}
inline std::string* AnalyzeIntentRequest::_internal_mutable_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.query_.Mutable( GetArena());
}
inline std::string* AnalyzeIntentRequest::release_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.AnalyzeIntentRequest.query)
  return _impl_.query_.Release();
}
inline void AnalyzeIntentRequest::set_allocated_query(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.query_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.query_.IsDefault()) {
          _impl_.query_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.AnalyzeIntentRequest.query)
}

// .nvidia.riva.nlp.AnalyzeIntentOptions options = 2 [deprecated = true];
inline bool AnalyzeIntentRequest::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline void AnalyzeIntentRequest::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nvidia::riva::nlp::AnalyzeIntentOptions& AnalyzeIntentRequest::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::nlp::AnalyzeIntentOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::nlp::AnalyzeIntentOptions&>(::nvidia::riva::nlp::_AnalyzeIntentOptions_default_instance_);
}
inline const ::nvidia::riva::nlp::AnalyzeIntentOptions& AnalyzeIntentRequest::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeIntentRequest.options)
  return _internal_options();
}
inline void AnalyzeIntentRequest::unsafe_arena_set_allocated_options(::nvidia::riva::nlp::AnalyzeIntentOptions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = reinterpret_cast<::nvidia::riva::nlp::AnalyzeIntentOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.AnalyzeIntentRequest.options)
}
inline ::nvidia::riva::nlp::AnalyzeIntentOptions* AnalyzeIntentRequest::release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::nlp::AnalyzeIntentOptions* released = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::nlp::AnalyzeIntentOptions* AnalyzeIntentRequest::unsafe_arena_release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.AnalyzeIntentRequest.options)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::nlp::AnalyzeIntentOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::nvidia::riva::nlp::AnalyzeIntentOptions* AnalyzeIntentRequest::_internal_mutable_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::nlp::AnalyzeIntentOptions>(GetArena());
    _impl_.options_ = reinterpret_cast<::nvidia::riva::nlp::AnalyzeIntentOptions*>(p);
  }
  return _impl_.options_;
}
inline ::nvidia::riva::nlp::AnalyzeIntentOptions* AnalyzeIntentRequest::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::nlp::AnalyzeIntentOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeIntentRequest.options)
  return _msg;
}
inline void AnalyzeIntentRequest::set_allocated_options(::nvidia::riva::nlp::AnalyzeIntentOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::nvidia::riva::nlp::AnalyzeIntentOptions*>(_impl_.options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::nvidia::riva::nlp::AnalyzeIntentOptions*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.options_ = reinterpret_cast<::nvidia::riva::nlp::AnalyzeIntentOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.AnalyzeIntentRequest.options)
}

// .nvidia.riva.RequestId id = 100 [deprecated = true];
inline bool AnalyzeIntentRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& AnalyzeIntentRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& AnalyzeIntentRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeIntentRequest.id)
  return _internal_id();
}
inline void AnalyzeIntentRequest::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.AnalyzeIntentRequest.id)
}
inline ::nvidia::riva::RequestId* AnalyzeIntentRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* AnalyzeIntentRequest::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.AnalyzeIntentRequest.id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* AnalyzeIntentRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* AnalyzeIntentRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeIntentRequest.id)
  return _msg;
}
inline void AnalyzeIntentRequest::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.AnalyzeIntentRequest.id)
}

// -------------------------------------------------------------------

// AnalyzeIntentResponse

// .nvidia.riva.nlp.Classification intent = 1 [deprecated = true];
inline bool AnalyzeIntentResponse::has_intent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.intent_ != nullptr);
  return value;
}
inline void AnalyzeIntentResponse::clear_intent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.intent_ != nullptr) _impl_.intent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nvidia::riva::nlp::Classification& AnalyzeIntentResponse::_internal_intent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::nlp::Classification* p = _impl_.intent_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::nlp::Classification&>(::nvidia::riva::nlp::_Classification_default_instance_);
}
inline const ::nvidia::riva::nlp::Classification& AnalyzeIntentResponse::intent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeIntentResponse.intent)
  return _internal_intent();
}
inline void AnalyzeIntentResponse::unsafe_arena_set_allocated_intent(::nvidia::riva::nlp::Classification* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.intent_);
  }
  _impl_.intent_ = reinterpret_cast<::nvidia::riva::nlp::Classification*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.AnalyzeIntentResponse.intent)
}
inline ::nvidia::riva::nlp::Classification* AnalyzeIntentResponse::release_intent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::nlp::Classification* released = _impl_.intent_;
  _impl_.intent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::nlp::Classification* AnalyzeIntentResponse::unsafe_arena_release_intent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.AnalyzeIntentResponse.intent)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::nlp::Classification* temp = _impl_.intent_;
  _impl_.intent_ = nullptr;
  return temp;
}
inline ::nvidia::riva::nlp::Classification* AnalyzeIntentResponse::_internal_mutable_intent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.intent_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::nlp::Classification>(GetArena());
    _impl_.intent_ = reinterpret_cast<::nvidia::riva::nlp::Classification*>(p);
  }
  return _impl_.intent_;
}
inline ::nvidia::riva::nlp::Classification* AnalyzeIntentResponse::mutable_intent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::nlp::Classification* _msg = _internal_mutable_intent();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeIntentResponse.intent)
  return _msg;
}
inline void AnalyzeIntentResponse::set_allocated_intent(::nvidia::riva::nlp::Classification* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::nvidia::riva::nlp::Classification*>(_impl_.intent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::nvidia::riva::nlp::Classification*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.intent_ = reinterpret_cast<::nvidia::riva::nlp::Classification*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.AnalyzeIntentResponse.intent)
}

// repeated .nvidia.riva.nlp.TokenClassValue slots = 2 [deprecated = true];
inline int AnalyzeIntentResponse::_internal_slots_size() const {
  return _internal_slots().size();
}
inline int AnalyzeIntentResponse::slots_size() const {
  return _internal_slots_size();
}
inline void AnalyzeIntentResponse::clear_slots() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.slots_.Clear();
}
inline ::nvidia::riva::nlp::TokenClassValue* AnalyzeIntentResponse::mutable_slots(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeIntentResponse.slots)
  return _internal_mutable_slots()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassValue>* AnalyzeIntentResponse::mutable_slots()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.nlp.AnalyzeIntentResponse.slots)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_slots();
}
inline const ::nvidia::riva::nlp::TokenClassValue& AnalyzeIntentResponse::slots(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeIntentResponse.slots)
  return _internal_slots().Get(index);
}
inline ::nvidia::riva::nlp::TokenClassValue* AnalyzeIntentResponse::add_slots() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::nlp::TokenClassValue* _add = _internal_mutable_slots()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.AnalyzeIntentResponse.slots)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassValue>& AnalyzeIntentResponse::slots() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.nlp.AnalyzeIntentResponse.slots)
  return _internal_slots();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassValue>&
AnalyzeIntentResponse::_internal_slots() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slots_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::TokenClassValue>*
AnalyzeIntentResponse::_internal_mutable_slots() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.slots_;
}

// string domain_str = 3 [deprecated = true];
inline void AnalyzeIntentResponse::clear_domain_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_str_.ClearToEmpty();
}
inline const std::string& AnalyzeIntentResponse::domain_str() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeIntentResponse.domain_str)
  return _internal_domain_str();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AnalyzeIntentResponse::set_domain_str(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.domain_str_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.AnalyzeIntentResponse.domain_str)
}
inline std::string* AnalyzeIntentResponse::mutable_domain_str() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_domain_str();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeIntentResponse.domain_str)
  return _s;
}
inline const std::string& AnalyzeIntentResponse::_internal_domain_str() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_str_.Get();
}
inline void AnalyzeIntentResponse::_internal_set_domain_str(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.domain_str_.Set(value, GetArena());
}
inline std::string* AnalyzeIntentResponse::_internal_mutable_domain_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.domain_str_.Mutable( GetArena());
}
inline std::string* AnalyzeIntentResponse::release_domain_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.AnalyzeIntentResponse.domain_str)
  return _impl_.domain_str_.Release();
}
inline void AnalyzeIntentResponse::set_allocated_domain_str(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_str_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.domain_str_.IsDefault()) {
          _impl_.domain_str_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.AnalyzeIntentResponse.domain_str)
}

// .nvidia.riva.nlp.Classification domain = 4 [deprecated = true];
inline bool AnalyzeIntentResponse::has_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.domain_ != nullptr);
  return value;
}
inline void AnalyzeIntentResponse::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.domain_ != nullptr) _impl_.domain_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::nvidia::riva::nlp::Classification& AnalyzeIntentResponse::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::nlp::Classification* p = _impl_.domain_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::nlp::Classification&>(::nvidia::riva::nlp::_Classification_default_instance_);
}
inline const ::nvidia::riva::nlp::Classification& AnalyzeIntentResponse::domain() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeIntentResponse.domain)
  return _internal_domain();
}
inline void AnalyzeIntentResponse::unsafe_arena_set_allocated_domain(::nvidia::riva::nlp::Classification* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.domain_);
  }
  _impl_.domain_ = reinterpret_cast<::nvidia::riva::nlp::Classification*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.AnalyzeIntentResponse.domain)
}
inline ::nvidia::riva::nlp::Classification* AnalyzeIntentResponse::release_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::nlp::Classification* released = _impl_.domain_;
  _impl_.domain_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::nlp::Classification* AnalyzeIntentResponse::unsafe_arena_release_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.AnalyzeIntentResponse.domain)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::nlp::Classification* temp = _impl_.domain_;
  _impl_.domain_ = nullptr;
  return temp;
}
inline ::nvidia::riva::nlp::Classification* AnalyzeIntentResponse::_internal_mutable_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.domain_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::nlp::Classification>(GetArena());
    _impl_.domain_ = reinterpret_cast<::nvidia::riva::nlp::Classification*>(p);
  }
  return _impl_.domain_;
}
inline ::nvidia::riva::nlp::Classification* AnalyzeIntentResponse::mutable_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::nlp::Classification* _msg = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeIntentResponse.domain)
  return _msg;
}
inline void AnalyzeIntentResponse::set_allocated_domain(::nvidia::riva::nlp::Classification* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::nvidia::riva::nlp::Classification*>(_impl_.domain_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::nvidia::riva::nlp::Classification*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.domain_ = reinterpret_cast<::nvidia::riva::nlp::Classification*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.AnalyzeIntentResponse.domain)
}

// .nvidia.riva.RequestId id = 100 [deprecated = true];
inline bool AnalyzeIntentResponse::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& AnalyzeIntentResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& AnalyzeIntentResponse::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeIntentResponse.id)
  return _internal_id();
}
inline void AnalyzeIntentResponse::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.AnalyzeIntentResponse.id)
}
inline ::nvidia::riva::RequestId* AnalyzeIntentResponse::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* AnalyzeIntentResponse::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.AnalyzeIntentResponse.id)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* AnalyzeIntentResponse::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* AnalyzeIntentResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeIntentResponse.id)
  return _msg;
}
inline void AnalyzeIntentResponse::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.AnalyzeIntentResponse.id)
}

// -------------------------------------------------------------------

// AnalyzeEntitiesOptions

// string lang = 4 [deprecated = true];
inline void AnalyzeEntitiesOptions::clear_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lang_.ClearToEmpty();
}
inline const std::string& AnalyzeEntitiesOptions::lang() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeEntitiesOptions.lang)
  return _internal_lang();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AnalyzeEntitiesOptions::set_lang(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lang_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.AnalyzeEntitiesOptions.lang)
}
inline std::string* AnalyzeEntitiesOptions::mutable_lang() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_lang();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeEntitiesOptions.lang)
  return _s;
}
inline const std::string& AnalyzeEntitiesOptions::_internal_lang() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lang_.Get();
}
inline void AnalyzeEntitiesOptions::_internal_set_lang(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lang_.Set(value, GetArena());
}
inline std::string* AnalyzeEntitiesOptions::_internal_mutable_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.lang_.Mutable( GetArena());
}
inline std::string* AnalyzeEntitiesOptions::release_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.AnalyzeEntitiesOptions.lang)
  return _impl_.lang_.Release();
}
inline void AnalyzeEntitiesOptions::set_allocated_lang(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lang_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lang_.IsDefault()) {
          _impl_.lang_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.AnalyzeEntitiesOptions.lang)
}

// -------------------------------------------------------------------

// AnalyzeEntitiesRequest

// string query = 1 [deprecated = true];
inline void AnalyzeEntitiesRequest::clear_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.query_.ClearToEmpty();
}
inline const std::string& AnalyzeEntitiesRequest::query() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeEntitiesRequest.query)
  return _internal_query();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AnalyzeEntitiesRequest::set_query(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.query_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.AnalyzeEntitiesRequest.query)
}
inline std::string* AnalyzeEntitiesRequest::mutable_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeEntitiesRequest.query)
  return _s;
}
inline const std::string& AnalyzeEntitiesRequest::_internal_query() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.query_.Get();
}
inline void AnalyzeEntitiesRequest::_internal_set_query(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.query_.Set(value, GetArena());
}
inline std::string* AnalyzeEntitiesRequest::_internal_mutable_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.query_.Mutable( GetArena());
}
inline std::string* AnalyzeEntitiesRequest::release_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.AnalyzeEntitiesRequest.query)
  return _impl_.query_.Release();
}
inline void AnalyzeEntitiesRequest::set_allocated_query(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.query_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.query_.IsDefault()) {
          _impl_.query_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.AnalyzeEntitiesRequest.query)
}

// .nvidia.riva.nlp.AnalyzeEntitiesOptions options = 2 [deprecated = true];
inline bool AnalyzeEntitiesRequest::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline void AnalyzeEntitiesRequest::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nvidia::riva::nlp::AnalyzeEntitiesOptions& AnalyzeEntitiesRequest::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::nlp::AnalyzeEntitiesOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::nlp::AnalyzeEntitiesOptions&>(::nvidia::riva::nlp::_AnalyzeEntitiesOptions_default_instance_);
}
inline const ::nvidia::riva::nlp::AnalyzeEntitiesOptions& AnalyzeEntitiesRequest::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeEntitiesRequest.options)
  return _internal_options();
}
inline void AnalyzeEntitiesRequest::unsafe_arena_set_allocated_options(::nvidia::riva::nlp::AnalyzeEntitiesOptions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = reinterpret_cast<::nvidia::riva::nlp::AnalyzeEntitiesOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.AnalyzeEntitiesRequest.options)
}
inline ::nvidia::riva::nlp::AnalyzeEntitiesOptions* AnalyzeEntitiesRequest::release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::nlp::AnalyzeEntitiesOptions* released = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::nlp::AnalyzeEntitiesOptions* AnalyzeEntitiesRequest::unsafe_arena_release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.AnalyzeEntitiesRequest.options)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::nlp::AnalyzeEntitiesOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::nvidia::riva::nlp::AnalyzeEntitiesOptions* AnalyzeEntitiesRequest::_internal_mutable_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::nlp::AnalyzeEntitiesOptions>(GetArena());
    _impl_.options_ = reinterpret_cast<::nvidia::riva::nlp::AnalyzeEntitiesOptions*>(p);
  }
  return _impl_.options_;
}
inline ::nvidia::riva::nlp::AnalyzeEntitiesOptions* AnalyzeEntitiesRequest::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::nlp::AnalyzeEntitiesOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeEntitiesRequest.options)
  return _msg;
}
inline void AnalyzeEntitiesRequest::set_allocated_options(::nvidia::riva::nlp::AnalyzeEntitiesOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::nvidia::riva::nlp::AnalyzeEntitiesOptions*>(_impl_.options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::nvidia::riva::nlp::AnalyzeEntitiesOptions*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.options_ = reinterpret_cast<::nvidia::riva::nlp::AnalyzeEntitiesOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.AnalyzeEntitiesRequest.options)
}

// .nvidia.riva.RequestId id = 100 [deprecated = true];
inline bool AnalyzeEntitiesRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& AnalyzeEntitiesRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& AnalyzeEntitiesRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.AnalyzeEntitiesRequest.id)
  return _internal_id();
}
inline void AnalyzeEntitiesRequest::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.AnalyzeEntitiesRequest.id)
}
inline ::nvidia::riva::RequestId* AnalyzeEntitiesRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* AnalyzeEntitiesRequest::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.AnalyzeEntitiesRequest.id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* AnalyzeEntitiesRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* AnalyzeEntitiesRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.AnalyzeEntitiesRequest.id)
  return _msg;
}
inline void AnalyzeEntitiesRequest::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.AnalyzeEntitiesRequest.id)
}

// -------------------------------------------------------------------

// NaturalQueryRequest

// string query = 1 [deprecated = true];
inline void NaturalQueryRequest::clear_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.query_.ClearToEmpty();
}
inline const std::string& NaturalQueryRequest::query() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.NaturalQueryRequest.query)
  return _internal_query();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NaturalQueryRequest::set_query(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.query_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.NaturalQueryRequest.query)
}
inline std::string* NaturalQueryRequest::mutable_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.NaturalQueryRequest.query)
  return _s;
}
inline const std::string& NaturalQueryRequest::_internal_query() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.query_.Get();
}
inline void NaturalQueryRequest::_internal_set_query(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.query_.Set(value, GetArena());
}
inline std::string* NaturalQueryRequest::_internal_mutable_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.query_.Mutable( GetArena());
}
inline std::string* NaturalQueryRequest::release_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.NaturalQueryRequest.query)
  return _impl_.query_.Release();
}
inline void NaturalQueryRequest::set_allocated_query(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.query_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.query_.IsDefault()) {
          _impl_.query_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.NaturalQueryRequest.query)
}

// uint32 top_n = 2 [deprecated = true];
inline void NaturalQueryRequest::clear_top_n() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_n_ = 0u;
}
inline ::uint32_t NaturalQueryRequest::top_n() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.NaturalQueryRequest.top_n)
  return _internal_top_n();
}
inline void NaturalQueryRequest::set_top_n(::uint32_t value) {
  _internal_set_top_n(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.NaturalQueryRequest.top_n)
}
inline ::uint32_t NaturalQueryRequest::_internal_top_n() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.top_n_;
}
inline void NaturalQueryRequest::_internal_set_top_n(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.top_n_ = value;
}

// string context = 3 [deprecated = true];
inline void NaturalQueryRequest::clear_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.context_.ClearToEmpty();
}
inline const std::string& NaturalQueryRequest::context() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.NaturalQueryRequest.context)
  return _internal_context();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NaturalQueryRequest::set_context(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.context_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.NaturalQueryRequest.context)
}
inline std::string* NaturalQueryRequest::mutable_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.NaturalQueryRequest.context)
  return _s;
}
inline const std::string& NaturalQueryRequest::_internal_context() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.context_.Get();
}
inline void NaturalQueryRequest::_internal_set_context(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.context_.Set(value, GetArena());
}
inline std::string* NaturalQueryRequest::_internal_mutable_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.context_.Mutable( GetArena());
}
inline std::string* NaturalQueryRequest::release_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.NaturalQueryRequest.context)
  return _impl_.context_.Release();
}
inline void NaturalQueryRequest::set_allocated_context(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.context_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.context_.IsDefault()) {
          _impl_.context_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.NaturalQueryRequest.context)
}

// .nvidia.riva.RequestId id = 100 [deprecated = true];
inline bool NaturalQueryRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& NaturalQueryRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& NaturalQueryRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.NaturalQueryRequest.id)
  return _internal_id();
}
inline void NaturalQueryRequest::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.NaturalQueryRequest.id)
}
inline ::nvidia::riva::RequestId* NaturalQueryRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* NaturalQueryRequest::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.NaturalQueryRequest.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* NaturalQueryRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* NaturalQueryRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.NaturalQueryRequest.id)
  return _msg;
}
inline void NaturalQueryRequest::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.NaturalQueryRequest.id)
}

// -------------------------------------------------------------------

// NaturalQueryResult

// string answer = 1 [deprecated = true];
inline void NaturalQueryResult::clear_answer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.answer_.ClearToEmpty();
}
inline const std::string& NaturalQueryResult::answer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.NaturalQueryResult.answer)
  return _internal_answer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NaturalQueryResult::set_answer(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.answer_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.NaturalQueryResult.answer)
}
inline std::string* NaturalQueryResult::mutable_answer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.NaturalQueryResult.answer)
  return _s;
}
inline const std::string& NaturalQueryResult::_internal_answer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.answer_.Get();
}
inline void NaturalQueryResult::_internal_set_answer(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.answer_.Set(value, GetArena());
}
inline std::string* NaturalQueryResult::_internal_mutable_answer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.answer_.Mutable( GetArena());
}
inline std::string* NaturalQueryResult::release_answer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.NaturalQueryResult.answer)
  return _impl_.answer_.Release();
}
inline void NaturalQueryResult::set_allocated_answer(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.answer_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.answer_.IsDefault()) {
          _impl_.answer_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.NaturalQueryResult.answer)
}

// float score = 2 [deprecated = true];
inline void NaturalQueryResult::clear_score() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.score_ = 0;
}
inline float NaturalQueryResult::score() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.NaturalQueryResult.score)
  return _internal_score();
}
inline void NaturalQueryResult::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.nlp.NaturalQueryResult.score)
}
inline float NaturalQueryResult::_internal_score() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.score_;
}
inline void NaturalQueryResult::_internal_set_score(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.score_ = value;
}

// -------------------------------------------------------------------

// NaturalQueryResponse

// repeated .nvidia.riva.nlp.NaturalQueryResult results = 1 [deprecated = true];
inline int NaturalQueryResponse::_internal_results_size() const {
  return _internal_results().size();
}
inline int NaturalQueryResponse::results_size() const {
  return _internal_results_size();
}
inline void NaturalQueryResponse::clear_results() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.results_.Clear();
}
inline ::nvidia::riva::nlp::NaturalQueryResult* NaturalQueryResponse::mutable_results(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.NaturalQueryResponse.results)
  return _internal_mutable_results()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::NaturalQueryResult>* NaturalQueryResponse::mutable_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.nlp.NaturalQueryResponse.results)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_results();
}
inline const ::nvidia::riva::nlp::NaturalQueryResult& NaturalQueryResponse::results(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.NaturalQueryResponse.results)
  return _internal_results().Get(index);
}
inline ::nvidia::riva::nlp::NaturalQueryResult* NaturalQueryResponse::add_results() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::nlp::NaturalQueryResult* _add = _internal_mutable_results()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.nlp.NaturalQueryResponse.results)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::NaturalQueryResult>& NaturalQueryResponse::results() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.nlp.NaturalQueryResponse.results)
  return _internal_results();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::NaturalQueryResult>&
NaturalQueryResponse::_internal_results() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.results_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::nlp::NaturalQueryResult>*
NaturalQueryResponse::_internal_mutable_results() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.results_;
}

// .nvidia.riva.RequestId id = 100 [deprecated = true];
inline bool NaturalQueryResponse::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& NaturalQueryResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& NaturalQueryResponse::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.nlp.NaturalQueryResponse.id)
  return _internal_id();
}
inline void NaturalQueryResponse::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.nlp.NaturalQueryResponse.id)
}
inline ::nvidia::riva::RequestId* NaturalQueryResponse::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* NaturalQueryResponse::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.nlp.NaturalQueryResponse.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* NaturalQueryResponse::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* NaturalQueryResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.nlp.NaturalQueryResponse.id)
  return _msg;
}
inline void NaturalQueryResponse::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.nlp.NaturalQueryResponse.id)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace nlp
}  // namespace riva
}  // namespace nvidia


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_riva_2fproto_2friva_5fnlp_2eproto_2epb_2eh
