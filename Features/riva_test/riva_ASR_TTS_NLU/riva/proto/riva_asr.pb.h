// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: riva/proto/riva_asr.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_riva_2fproto_2friva_5fasr_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_riva_2fproto_2friva_5fasr_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
#include "riva/proto/riva_audio.pb.h"
#include "riva/proto/riva_common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_riva_2fproto_2friva_5fasr_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_riva_2fproto_2friva_5fasr_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_riva_2fproto_2friva_5fasr_2eproto;
namespace nvidia {
namespace riva {
namespace asr {
class EndpointingConfig;
struct EndpointingConfigDefaultTypeInternal;
extern EndpointingConfigDefaultTypeInternal _EndpointingConfig_default_instance_;
class PipelineStates;
struct PipelineStatesDefaultTypeInternal;
extern PipelineStatesDefaultTypeInternal _PipelineStates_default_instance_;
class RecognitionConfig;
struct RecognitionConfigDefaultTypeInternal;
extern RecognitionConfigDefaultTypeInternal _RecognitionConfig_default_instance_;
class RecognitionConfig_CustomConfigurationEntry_DoNotUse;
struct RecognitionConfig_CustomConfigurationEntry_DoNotUseDefaultTypeInternal;
extern RecognitionConfig_CustomConfigurationEntry_DoNotUseDefaultTypeInternal _RecognitionConfig_CustomConfigurationEntry_DoNotUse_default_instance_;
class RecognizeRequest;
struct RecognizeRequestDefaultTypeInternal;
extern RecognizeRequestDefaultTypeInternal _RecognizeRequest_default_instance_;
class RecognizeResponse;
struct RecognizeResponseDefaultTypeInternal;
extern RecognizeResponseDefaultTypeInternal _RecognizeResponse_default_instance_;
class RivaSpeechRecognitionConfigRequest;
struct RivaSpeechRecognitionConfigRequestDefaultTypeInternal;
extern RivaSpeechRecognitionConfigRequestDefaultTypeInternal _RivaSpeechRecognitionConfigRequest_default_instance_;
class RivaSpeechRecognitionConfigResponse;
struct RivaSpeechRecognitionConfigResponseDefaultTypeInternal;
extern RivaSpeechRecognitionConfigResponseDefaultTypeInternal _RivaSpeechRecognitionConfigResponse_default_instance_;
class RivaSpeechRecognitionConfigResponse_Config;
struct RivaSpeechRecognitionConfigResponse_ConfigDefaultTypeInternal;
extern RivaSpeechRecognitionConfigResponse_ConfigDefaultTypeInternal _RivaSpeechRecognitionConfigResponse_Config_default_instance_;
class RivaSpeechRecognitionConfigResponse_Config_ParametersEntry_DoNotUse;
struct RivaSpeechRecognitionConfigResponse_Config_ParametersEntry_DoNotUseDefaultTypeInternal;
extern RivaSpeechRecognitionConfigResponse_Config_ParametersEntry_DoNotUseDefaultTypeInternal _RivaSpeechRecognitionConfigResponse_Config_ParametersEntry_DoNotUse_default_instance_;
class SpeakerDiarizationConfig;
struct SpeakerDiarizationConfigDefaultTypeInternal;
extern SpeakerDiarizationConfigDefaultTypeInternal _SpeakerDiarizationConfig_default_instance_;
class SpeechContext;
struct SpeechContextDefaultTypeInternal;
extern SpeechContextDefaultTypeInternal _SpeechContext_default_instance_;
class SpeechRecognitionAlternative;
struct SpeechRecognitionAlternativeDefaultTypeInternal;
extern SpeechRecognitionAlternativeDefaultTypeInternal _SpeechRecognitionAlternative_default_instance_;
class SpeechRecognitionResult;
struct SpeechRecognitionResultDefaultTypeInternal;
extern SpeechRecognitionResultDefaultTypeInternal _SpeechRecognitionResult_default_instance_;
class StreamingRecognitionConfig;
struct StreamingRecognitionConfigDefaultTypeInternal;
extern StreamingRecognitionConfigDefaultTypeInternal _StreamingRecognitionConfig_default_instance_;
class StreamingRecognitionResult;
struct StreamingRecognitionResultDefaultTypeInternal;
extern StreamingRecognitionResultDefaultTypeInternal _StreamingRecognitionResult_default_instance_;
class StreamingRecognizeRequest;
struct StreamingRecognizeRequestDefaultTypeInternal;
extern StreamingRecognizeRequestDefaultTypeInternal _StreamingRecognizeRequest_default_instance_;
class StreamingRecognizeResponse;
struct StreamingRecognizeResponseDefaultTypeInternal;
extern StreamingRecognizeResponseDefaultTypeInternal _StreamingRecognizeResponse_default_instance_;
class WordInfo;
struct WordInfoDefaultTypeInternal;
extern WordInfoDefaultTypeInternal _WordInfo_default_instance_;
}  // namespace asr
}  // namespace riva
}  // namespace nvidia
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace nvidia {
namespace riva {
namespace asr {

// ===================================================================


// -------------------------------------------------------------------

class WordInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.WordInfo) */ {
 public:
  inline WordInfo() : WordInfo(nullptr) {}
  ~WordInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WordInfo(::google::protobuf::internal::ConstantInitialized);

  inline WordInfo(const WordInfo& from)
      : WordInfo(nullptr, from) {}
  WordInfo(WordInfo&& from) noexcept
    : WordInfo() {
    *this = ::std::move(from);
  }

  inline WordInfo& operator=(const WordInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WordInfo& operator=(WordInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WordInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WordInfo* internal_default_instance() {
    return reinterpret_cast<const WordInfo*>(
               &_WordInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(WordInfo& a, WordInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WordInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WordInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WordInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WordInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WordInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WordInfo& from) {
    WordInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WordInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.WordInfo";
  }
  protected:
  explicit WordInfo(::google::protobuf::Arena* arena);
  WordInfo(::google::protobuf::Arena* arena, const WordInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWordFieldNumber = 3,
    kLanguageCodeFieldNumber = 6,
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
    kConfidenceFieldNumber = 4,
    kSpeakerTagFieldNumber = 5,
  };
  // string word = 3;
  void clear_word() ;
  const std::string& word() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_word(Arg_&& arg, Args_... args);
  std::string* mutable_word();
  PROTOBUF_NODISCARD std::string* release_word();
  void set_allocated_word(std::string* value);

  private:
  const std::string& _internal_word() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_word(
      const std::string& value);
  std::string* _internal_mutable_word();

  public:
  // string language_code = 6;
  void clear_language_code() ;
  const std::string& language_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_language_code(Arg_&& arg, Args_... args);
  std::string* mutable_language_code();
  PROTOBUF_NODISCARD std::string* release_language_code();
  void set_allocated_language_code(std::string* value);

  private:
  const std::string& _internal_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_code(
      const std::string& value);
  std::string* _internal_mutable_language_code();

  public:
  // int32 start_time = 1;
  void clear_start_time() ;
  ::int32_t start_time() const;
  void set_start_time(::int32_t value);

  private:
  ::int32_t _internal_start_time() const;
  void _internal_set_start_time(::int32_t value);

  public:
  // int32 end_time = 2;
  void clear_end_time() ;
  ::int32_t end_time() const;
  void set_end_time(::int32_t value);

  private:
  ::int32_t _internal_end_time() const;
  void _internal_set_end_time(::int32_t value);

  public:
  // float confidence = 4;
  void clear_confidence() ;
  float confidence() const;
  void set_confidence(float value);

  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);

  public:
  // int32 speaker_tag = 5;
  void clear_speaker_tag() ;
  ::int32_t speaker_tag() const;
  void set_speaker_tag(::int32_t value);

  private:
  ::int32_t _internal_speaker_tag() const;
  void _internal_set_speaker_tag(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.WordInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr word_;
    ::google::protobuf::internal::ArenaStringPtr language_code_;
    ::int32_t start_time_;
    ::int32_t end_time_;
    float confidence_;
    ::int32_t speaker_tag_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class SpeechContext final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.SpeechContext) */ {
 public:
  inline SpeechContext() : SpeechContext(nullptr) {}
  ~SpeechContext() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpeechContext(::google::protobuf::internal::ConstantInitialized);

  inline SpeechContext(const SpeechContext& from)
      : SpeechContext(nullptr, from) {}
  SpeechContext(SpeechContext&& from) noexcept
    : SpeechContext() {
    *this = ::std::move(from);
  }

  inline SpeechContext& operator=(const SpeechContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeechContext& operator=(SpeechContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeechContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpeechContext* internal_default_instance() {
    return reinterpret_cast<const SpeechContext*>(
               &_SpeechContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SpeechContext& a, SpeechContext& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeechContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeechContext* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeechContext* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpeechContext>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SpeechContext& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SpeechContext& from) {
    SpeechContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SpeechContext* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.SpeechContext";
  }
  protected:
  explicit SpeechContext(::google::protobuf::Arena* arena);
  SpeechContext(::google::protobuf::Arena* arena, const SpeechContext& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhrasesFieldNumber = 1,
    kBoostFieldNumber = 4,
  };
  // repeated string phrases = 1;
  int phrases_size() const;
  private:
  int _internal_phrases_size() const;

  public:
  void clear_phrases() ;
  const std::string& phrases(int index) const;
  std::string* mutable_phrases(int index);
  void set_phrases(int index, const std::string& value);
  void set_phrases(int index, std::string&& value);
  void set_phrases(int index, const char* value);
  void set_phrases(int index, const char* value, std::size_t size);
  void set_phrases(int index, absl::string_view value);
  std::string* add_phrases();
  void add_phrases(const std::string& value);
  void add_phrases(std::string&& value);
  void add_phrases(const char* value);
  void add_phrases(const char* value, std::size_t size);
  void add_phrases(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& phrases() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_phrases();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_phrases() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_phrases();

  public:
  // float boost = 4;
  void clear_boost() ;
  float boost() const;
  void set_boost(float value);

  private:
  float _internal_boost() const;
  void _internal_set_boost(float value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.SpeechContext)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> phrases_;
    float boost_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class SpeakerDiarizationConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.SpeakerDiarizationConfig) */ {
 public:
  inline SpeakerDiarizationConfig() : SpeakerDiarizationConfig(nullptr) {}
  ~SpeakerDiarizationConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpeakerDiarizationConfig(::google::protobuf::internal::ConstantInitialized);

  inline SpeakerDiarizationConfig(const SpeakerDiarizationConfig& from)
      : SpeakerDiarizationConfig(nullptr, from) {}
  SpeakerDiarizationConfig(SpeakerDiarizationConfig&& from) noexcept
    : SpeakerDiarizationConfig() {
    *this = ::std::move(from);
  }

  inline SpeakerDiarizationConfig& operator=(const SpeakerDiarizationConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeakerDiarizationConfig& operator=(SpeakerDiarizationConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeakerDiarizationConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpeakerDiarizationConfig* internal_default_instance() {
    return reinterpret_cast<const SpeakerDiarizationConfig*>(
               &_SpeakerDiarizationConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SpeakerDiarizationConfig& a, SpeakerDiarizationConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeakerDiarizationConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeakerDiarizationConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeakerDiarizationConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpeakerDiarizationConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SpeakerDiarizationConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SpeakerDiarizationConfig& from) {
    SpeakerDiarizationConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SpeakerDiarizationConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.SpeakerDiarizationConfig";
  }
  protected:
  explicit SpeakerDiarizationConfig(::google::protobuf::Arena* arena);
  SpeakerDiarizationConfig(::google::protobuf::Arena* arena, const SpeakerDiarizationConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableSpeakerDiarizationFieldNumber = 1,
    kMaxSpeakerCountFieldNumber = 2,
  };
  // bool enable_speaker_diarization = 1;
  void clear_enable_speaker_diarization() ;
  bool enable_speaker_diarization() const;
  void set_enable_speaker_diarization(bool value);

  private:
  bool _internal_enable_speaker_diarization() const;
  void _internal_set_enable_speaker_diarization(bool value);

  public:
  // int32 max_speaker_count = 2;
  void clear_max_speaker_count() ;
  ::int32_t max_speaker_count() const;
  void set_max_speaker_count(::int32_t value);

  private:
  ::int32_t _internal_max_speaker_count() const;
  void _internal_set_max_speaker_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.SpeakerDiarizationConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool enable_speaker_diarization_;
    ::int32_t max_speaker_count_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class RivaSpeechRecognitionConfigResponse_Config_ParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          RivaSpeechRecognitionConfigResponse_Config_ParametersEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      RivaSpeechRecognitionConfigResponse_Config_ParametersEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  RivaSpeechRecognitionConfigResponse_Config_ParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RivaSpeechRecognitionConfigResponse_Config_ParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit RivaSpeechRecognitionConfigResponse_Config_ParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const RivaSpeechRecognitionConfigResponse_Config_ParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const RivaSpeechRecognitionConfigResponse_Config_ParametersEntry_DoNotUse*>(
        &_RivaSpeechRecognitionConfigResponse_Config_ParametersEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config.ParametersEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};
// -------------------------------------------------------------------

class RivaSpeechRecognitionConfigRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.RivaSpeechRecognitionConfigRequest) */ {
 public:
  inline RivaSpeechRecognitionConfigRequest() : RivaSpeechRecognitionConfigRequest(nullptr) {}
  ~RivaSpeechRecognitionConfigRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RivaSpeechRecognitionConfigRequest(::google::protobuf::internal::ConstantInitialized);

  inline RivaSpeechRecognitionConfigRequest(const RivaSpeechRecognitionConfigRequest& from)
      : RivaSpeechRecognitionConfigRequest(nullptr, from) {}
  RivaSpeechRecognitionConfigRequest(RivaSpeechRecognitionConfigRequest&& from) noexcept
    : RivaSpeechRecognitionConfigRequest() {
    *this = ::std::move(from);
  }

  inline RivaSpeechRecognitionConfigRequest& operator=(const RivaSpeechRecognitionConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RivaSpeechRecognitionConfigRequest& operator=(RivaSpeechRecognitionConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RivaSpeechRecognitionConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RivaSpeechRecognitionConfigRequest* internal_default_instance() {
    return reinterpret_cast<const RivaSpeechRecognitionConfigRequest*>(
               &_RivaSpeechRecognitionConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RivaSpeechRecognitionConfigRequest& a, RivaSpeechRecognitionConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RivaSpeechRecognitionConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RivaSpeechRecognitionConfigRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RivaSpeechRecognitionConfigRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RivaSpeechRecognitionConfigRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RivaSpeechRecognitionConfigRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RivaSpeechRecognitionConfigRequest& from) {
    RivaSpeechRecognitionConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RivaSpeechRecognitionConfigRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.RivaSpeechRecognitionConfigRequest";
  }
  protected:
  explicit RivaSpeechRecognitionConfigRequest(::google::protobuf::Arena* arena);
  RivaSpeechRecognitionConfigRequest(::google::protobuf::Arena* arena, const RivaSpeechRecognitionConfigRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
  };
  // string model_name = 1;
  void clear_model_name() ;
  const std::string& model_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_name(Arg_&& arg, Args_... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* value);

  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(
      const std::string& value);
  std::string* _internal_mutable_model_name();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.RivaSpeechRecognitionConfigRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      69, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr model_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class RecognitionConfig_CustomConfigurationEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          RecognitionConfig_CustomConfigurationEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      RecognitionConfig_CustomConfigurationEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  RecognitionConfig_CustomConfigurationEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RecognitionConfig_CustomConfigurationEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit RecognitionConfig_CustomConfigurationEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const RecognitionConfig_CustomConfigurationEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const RecognitionConfig_CustomConfigurationEntry_DoNotUse*>(
        &_RecognitionConfig_CustomConfigurationEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "nvidia.riva.asr.RecognitionConfig.CustomConfigurationEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "nvidia.riva.asr.RecognitionConfig.CustomConfigurationEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};
// -------------------------------------------------------------------

class PipelineStates final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.PipelineStates) */ {
 public:
  inline PipelineStates() : PipelineStates(nullptr) {}
  ~PipelineStates() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PipelineStates(::google::protobuf::internal::ConstantInitialized);

  inline PipelineStates(const PipelineStates& from)
      : PipelineStates(nullptr, from) {}
  PipelineStates(PipelineStates&& from) noexcept
    : PipelineStates() {
    *this = ::std::move(from);
  }

  inline PipelineStates& operator=(const PipelineStates& from) {
    CopyFrom(from);
    return *this;
  }
  inline PipelineStates& operator=(PipelineStates&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PipelineStates& default_instance() {
    return *internal_default_instance();
  }
  static inline const PipelineStates* internal_default_instance() {
    return reinterpret_cast<const PipelineStates*>(
               &_PipelineStates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PipelineStates& a, PipelineStates& b) {
    a.Swap(&b);
  }
  inline void Swap(PipelineStates* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PipelineStates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PipelineStates* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PipelineStates>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PipelineStates& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PipelineStates& from) {
    PipelineStates::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PipelineStates* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.PipelineStates";
  }
  protected:
  explicit PipelineStates(::google::protobuf::Arena* arena);
  PipelineStates(::google::protobuf::Arena* arena, const PipelineStates& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVadProbabilitiesFieldNumber = 1,
  };
  // repeated float vad_probabilities = 1;
  int vad_probabilities_size() const;
  private:
  int _internal_vad_probabilities_size() const;

  public:
  void clear_vad_probabilities() ;
  float vad_probabilities(int index) const;
  void set_vad_probabilities(int index, float value);
  void add_vad_probabilities(float value);
  const ::google::protobuf::RepeatedField<float>& vad_probabilities() const;
  ::google::protobuf::RepeatedField<float>* mutable_vad_probabilities();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_vad_probabilities() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_vad_probabilities();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.PipelineStates)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> vad_probabilities_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class EndpointingConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.EndpointingConfig) */ {
 public:
  inline EndpointingConfig() : EndpointingConfig(nullptr) {}
  ~EndpointingConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EndpointingConfig(::google::protobuf::internal::ConstantInitialized);

  inline EndpointingConfig(const EndpointingConfig& from)
      : EndpointingConfig(nullptr, from) {}
  EndpointingConfig(EndpointingConfig&& from) noexcept
    : EndpointingConfig() {
    *this = ::std::move(from);
  }

  inline EndpointingConfig& operator=(const EndpointingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndpointingConfig& operator=(EndpointingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndpointingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndpointingConfig* internal_default_instance() {
    return reinterpret_cast<const EndpointingConfig*>(
               &_EndpointingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EndpointingConfig& a, EndpointingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(EndpointingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndpointingConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndpointingConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndpointingConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EndpointingConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EndpointingConfig& from) {
    EndpointingConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EndpointingConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.EndpointingConfig";
  }
  protected:
  explicit EndpointingConfig(::google::protobuf::Arena* arena);
  EndpointingConfig(::google::protobuf::Arena* arena, const EndpointingConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartHistoryFieldNumber = 1,
    kStartThresholdFieldNumber = 2,
    kStopHistoryFieldNumber = 3,
    kStopThresholdFieldNumber = 4,
    kStopHistoryEouFieldNumber = 5,
    kStopThresholdEouFieldNumber = 6,
  };
  // optional int32 start_history = 1;
  bool has_start_history() const;
  void clear_start_history() ;
  ::int32_t start_history() const;
  void set_start_history(::int32_t value);

  private:
  ::int32_t _internal_start_history() const;
  void _internal_set_start_history(::int32_t value);

  public:
  // optional float start_threshold = 2;
  bool has_start_threshold() const;
  void clear_start_threshold() ;
  float start_threshold() const;
  void set_start_threshold(float value);

  private:
  float _internal_start_threshold() const;
  void _internal_set_start_threshold(float value);

  public:
  // optional int32 stop_history = 3;
  bool has_stop_history() const;
  void clear_stop_history() ;
  ::int32_t stop_history() const;
  void set_stop_history(::int32_t value);

  private:
  ::int32_t _internal_stop_history() const;
  void _internal_set_stop_history(::int32_t value);

  public:
  // optional float stop_threshold = 4;
  bool has_stop_threshold() const;
  void clear_stop_threshold() ;
  float stop_threshold() const;
  void set_stop_threshold(float value);

  private:
  float _internal_stop_threshold() const;
  void _internal_set_stop_threshold(float value);

  public:
  // optional int32 stop_history_eou = 5;
  bool has_stop_history_eou() const;
  void clear_stop_history_eou() ;
  ::int32_t stop_history_eou() const;
  void set_stop_history_eou(::int32_t value);

  private:
  ::int32_t _internal_stop_history_eou() const;
  void _internal_set_stop_history_eou(::int32_t value);

  public:
  // optional float stop_threshold_eou = 6;
  bool has_stop_threshold_eou() const;
  void clear_stop_threshold_eou() ;
  float stop_threshold_eou() const;
  void set_stop_threshold_eou(float value);

  private:
  float _internal_stop_threshold_eou() const;
  void _internal_set_stop_threshold_eou(float value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.EndpointingConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t start_history_;
    float start_threshold_;
    ::int32_t stop_history_;
    float stop_threshold_;
    ::int32_t stop_history_eou_;
    float stop_threshold_eou_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class SpeechRecognitionAlternative final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.SpeechRecognitionAlternative) */ {
 public:
  inline SpeechRecognitionAlternative() : SpeechRecognitionAlternative(nullptr) {}
  ~SpeechRecognitionAlternative() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpeechRecognitionAlternative(::google::protobuf::internal::ConstantInitialized);

  inline SpeechRecognitionAlternative(const SpeechRecognitionAlternative& from)
      : SpeechRecognitionAlternative(nullptr, from) {}
  SpeechRecognitionAlternative(SpeechRecognitionAlternative&& from) noexcept
    : SpeechRecognitionAlternative() {
    *this = ::std::move(from);
  }

  inline SpeechRecognitionAlternative& operator=(const SpeechRecognitionAlternative& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeechRecognitionAlternative& operator=(SpeechRecognitionAlternative&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeechRecognitionAlternative& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpeechRecognitionAlternative* internal_default_instance() {
    return reinterpret_cast<const SpeechRecognitionAlternative*>(
               &_SpeechRecognitionAlternative_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SpeechRecognitionAlternative& a, SpeechRecognitionAlternative& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeechRecognitionAlternative* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeechRecognitionAlternative* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeechRecognitionAlternative* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpeechRecognitionAlternative>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SpeechRecognitionAlternative& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SpeechRecognitionAlternative& from) {
    SpeechRecognitionAlternative::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SpeechRecognitionAlternative* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.SpeechRecognitionAlternative";
  }
  protected:
  explicit SpeechRecognitionAlternative(::google::protobuf::Arena* arena);
  SpeechRecognitionAlternative(::google::protobuf::Arena* arena, const SpeechRecognitionAlternative& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWordsFieldNumber = 3,
    kLanguageCodeFieldNumber = 4,
    kTranscriptFieldNumber = 1,
    kConfidenceFieldNumber = 2,
  };
  // repeated .nvidia.riva.asr.WordInfo words = 3;
  int words_size() const;
  private:
  int _internal_words_size() const;

  public:
  void clear_words() ;
  ::nvidia::riva::asr::WordInfo* mutable_words(int index);
  ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::WordInfo >*
      mutable_words();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::WordInfo>& _internal_words() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::WordInfo>* _internal_mutable_words();
  public:
  const ::nvidia::riva::asr::WordInfo& words(int index) const;
  ::nvidia::riva::asr::WordInfo* add_words();
  const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::WordInfo >&
      words() const;
  // repeated string language_code = 4;
  int language_code_size() const;
  private:
  int _internal_language_code_size() const;

  public:
  void clear_language_code() ;
  const std::string& language_code(int index) const;
  std::string* mutable_language_code(int index);
  void set_language_code(int index, const std::string& value);
  void set_language_code(int index, std::string&& value);
  void set_language_code(int index, const char* value);
  void set_language_code(int index, const char* value, std::size_t size);
  void set_language_code(int index, absl::string_view value);
  std::string* add_language_code();
  void add_language_code(const std::string& value);
  void add_language_code(std::string&& value);
  void add_language_code(const char* value);
  void add_language_code(const char* value, std::size_t size);
  void add_language_code(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& language_code() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_language_code();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_language_code() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_language_code();

  public:
  // string transcript = 1;
  void clear_transcript() ;
  const std::string& transcript() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transcript(Arg_&& arg, Args_... args);
  std::string* mutable_transcript();
  PROTOBUF_NODISCARD std::string* release_transcript();
  void set_allocated_transcript(std::string* value);

  private:
  const std::string& _internal_transcript() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transcript(
      const std::string& value);
  std::string* _internal_mutable_transcript();

  public:
  // float confidence = 2;
  void clear_confidence() ;
  float confidence() const;
  void set_confidence(float value);

  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.SpeechRecognitionAlternative)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      76, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::WordInfo > words_;
    ::google::protobuf::RepeatedPtrField<std::string> language_code_;
    ::google::protobuf::internal::ArenaStringPtr transcript_;
    float confidence_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class RivaSpeechRecognitionConfigResponse_Config final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config) */ {
 public:
  inline RivaSpeechRecognitionConfigResponse_Config() : RivaSpeechRecognitionConfigResponse_Config(nullptr) {}
  ~RivaSpeechRecognitionConfigResponse_Config() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RivaSpeechRecognitionConfigResponse_Config(::google::protobuf::internal::ConstantInitialized);

  inline RivaSpeechRecognitionConfigResponse_Config(const RivaSpeechRecognitionConfigResponse_Config& from)
      : RivaSpeechRecognitionConfigResponse_Config(nullptr, from) {}
  RivaSpeechRecognitionConfigResponse_Config(RivaSpeechRecognitionConfigResponse_Config&& from) noexcept
    : RivaSpeechRecognitionConfigResponse_Config() {
    *this = ::std::move(from);
  }

  inline RivaSpeechRecognitionConfigResponse_Config& operator=(const RivaSpeechRecognitionConfigResponse_Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline RivaSpeechRecognitionConfigResponse_Config& operator=(RivaSpeechRecognitionConfigResponse_Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RivaSpeechRecognitionConfigResponse_Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const RivaSpeechRecognitionConfigResponse_Config* internal_default_instance() {
    return reinterpret_cast<const RivaSpeechRecognitionConfigResponse_Config*>(
               &_RivaSpeechRecognitionConfigResponse_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RivaSpeechRecognitionConfigResponse_Config& a, RivaSpeechRecognitionConfigResponse_Config& b) {
    a.Swap(&b);
  }
  inline void Swap(RivaSpeechRecognitionConfigResponse_Config* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RivaSpeechRecognitionConfigResponse_Config* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RivaSpeechRecognitionConfigResponse_Config* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RivaSpeechRecognitionConfigResponse_Config>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RivaSpeechRecognitionConfigResponse_Config& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RivaSpeechRecognitionConfigResponse_Config& from) {
    RivaSpeechRecognitionConfigResponse_Config::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RivaSpeechRecognitionConfigResponse_Config* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config";
  }
  protected:
  explicit RivaSpeechRecognitionConfigResponse_Config(::google::protobuf::Arena* arena);
  RivaSpeechRecognitionConfigResponse_Config(::google::protobuf::Arena* arena, const RivaSpeechRecognitionConfigResponse_Config& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 2,
    kModelNameFieldNumber = 1,
  };
  // map<string, string> parameters = 2;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_parameters();

  public:
  // string model_name = 1;
  void clear_model_name() ;
  const std::string& model_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_name(Arg_&& arg, Args_... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* value);

  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(
      const std::string& value);
  std::string* _internal_mutable_model_name();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      87, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<RivaSpeechRecognitionConfigResponse_Config_ParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        parameters_;
    ::google::protobuf::internal::ArenaStringPtr model_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class RecognitionConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.RecognitionConfig) */ {
 public:
  inline RecognitionConfig() : RecognitionConfig(nullptr) {}
  ~RecognitionConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecognitionConfig(::google::protobuf::internal::ConstantInitialized);

  inline RecognitionConfig(const RecognitionConfig& from)
      : RecognitionConfig(nullptr, from) {}
  RecognitionConfig(RecognitionConfig&& from) noexcept
    : RecognitionConfig() {
    *this = ::std::move(from);
  }

  inline RecognitionConfig& operator=(const RecognitionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecognitionConfig& operator=(RecognitionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecognitionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecognitionConfig* internal_default_instance() {
    return reinterpret_cast<const RecognitionConfig*>(
               &_RecognitionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RecognitionConfig& a, RecognitionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RecognitionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecognitionConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecognitionConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecognitionConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecognitionConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecognitionConfig& from) {
    RecognitionConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecognitionConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.RecognitionConfig";
  }
  protected:
  explicit RecognitionConfig(::google::protobuf::Arena* arena);
  RecognitionConfig(::google::protobuf::Arena* arena, const RecognitionConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSpeechContextsFieldNumber = 6,
    kCustomConfigurationFieldNumber = 24,
    kLanguageCodeFieldNumber = 3,
    kModelFieldNumber = 13,
    kDiarizationConfigFieldNumber = 19,
    kEndpointingConfigFieldNumber = 25,
    kEncodingFieldNumber = 1,
    kSampleRateHertzFieldNumber = 2,
    kMaxAlternativesFieldNumber = 4,
    kAudioChannelCountFieldNumber = 7,
    kProfanityFilterFieldNumber = 5,
    kEnableWordTimeOffsetsFieldNumber = 8,
    kEnableAutomaticPunctuationFieldNumber = 11,
    kEnableSeparateRecognitionPerChannelFieldNumber = 12,
    kVerbatimTranscriptsFieldNumber = 14,
  };
  // repeated .nvidia.riva.asr.SpeechContext speech_contexts = 6;
  int speech_contexts_size() const;
  private:
  int _internal_speech_contexts_size() const;

  public:
  void clear_speech_contexts() ;
  ::nvidia::riva::asr::SpeechContext* mutable_speech_contexts(int index);
  ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::SpeechContext >*
      mutable_speech_contexts();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechContext>& _internal_speech_contexts() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechContext>* _internal_mutable_speech_contexts();
  public:
  const ::nvidia::riva::asr::SpeechContext& speech_contexts(int index) const;
  ::nvidia::riva::asr::SpeechContext* add_speech_contexts();
  const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::SpeechContext >&
      speech_contexts() const;
  // map<string, string> custom_configuration = 24;
  int custom_configuration_size() const;
  private:
  int _internal_custom_configuration_size() const;

  public:
  void clear_custom_configuration() ;
  const ::google::protobuf::Map<std::string, std::string>& custom_configuration() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_custom_configuration();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_custom_configuration() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_custom_configuration();

  public:
  // string language_code = 3;
  void clear_language_code() ;
  const std::string& language_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_language_code(Arg_&& arg, Args_... args);
  std::string* mutable_language_code();
  PROTOBUF_NODISCARD std::string* release_language_code();
  void set_allocated_language_code(std::string* value);

  private:
  const std::string& _internal_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_code(
      const std::string& value);
  std::string* _internal_mutable_language_code();

  public:
  // string model = 13;
  void clear_model() ;
  const std::string& model() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model(Arg_&& arg, Args_... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* value);

  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(
      const std::string& value);
  std::string* _internal_mutable_model();

  public:
  // .nvidia.riva.asr.SpeakerDiarizationConfig diarization_config = 19;
  bool has_diarization_config() const;
  void clear_diarization_config() ;
  const ::nvidia::riva::asr::SpeakerDiarizationConfig& diarization_config() const;
  PROTOBUF_NODISCARD ::nvidia::riva::asr::SpeakerDiarizationConfig* release_diarization_config();
  ::nvidia::riva::asr::SpeakerDiarizationConfig* mutable_diarization_config();
  void set_allocated_diarization_config(::nvidia::riva::asr::SpeakerDiarizationConfig* value);
  void unsafe_arena_set_allocated_diarization_config(::nvidia::riva::asr::SpeakerDiarizationConfig* value);
  ::nvidia::riva::asr::SpeakerDiarizationConfig* unsafe_arena_release_diarization_config();

  private:
  const ::nvidia::riva::asr::SpeakerDiarizationConfig& _internal_diarization_config() const;
  ::nvidia::riva::asr::SpeakerDiarizationConfig* _internal_mutable_diarization_config();

  public:
  // optional .nvidia.riva.asr.EndpointingConfig endpointing_config = 25;
  bool has_endpointing_config() const;
  void clear_endpointing_config() ;
  const ::nvidia::riva::asr::EndpointingConfig& endpointing_config() const;
  PROTOBUF_NODISCARD ::nvidia::riva::asr::EndpointingConfig* release_endpointing_config();
  ::nvidia::riva::asr::EndpointingConfig* mutable_endpointing_config();
  void set_allocated_endpointing_config(::nvidia::riva::asr::EndpointingConfig* value);
  void unsafe_arena_set_allocated_endpointing_config(::nvidia::riva::asr::EndpointingConfig* value);
  ::nvidia::riva::asr::EndpointingConfig* unsafe_arena_release_endpointing_config();

  private:
  const ::nvidia::riva::asr::EndpointingConfig& _internal_endpointing_config() const;
  ::nvidia::riva::asr::EndpointingConfig* _internal_mutable_endpointing_config();

  public:
  // .nvidia.riva.AudioEncoding encoding = 1;
  void clear_encoding() ;
  ::nvidia::riva::AudioEncoding encoding() const;
  void set_encoding(::nvidia::riva::AudioEncoding value);

  private:
  ::nvidia::riva::AudioEncoding _internal_encoding() const;
  void _internal_set_encoding(::nvidia::riva::AudioEncoding value);

  public:
  // int32 sample_rate_hertz = 2;
  void clear_sample_rate_hertz() ;
  ::int32_t sample_rate_hertz() const;
  void set_sample_rate_hertz(::int32_t value);

  private:
  ::int32_t _internal_sample_rate_hertz() const;
  void _internal_set_sample_rate_hertz(::int32_t value);

  public:
  // int32 max_alternatives = 4;
  void clear_max_alternatives() ;
  ::int32_t max_alternatives() const;
  void set_max_alternatives(::int32_t value);

  private:
  ::int32_t _internal_max_alternatives() const;
  void _internal_set_max_alternatives(::int32_t value);

  public:
  // int32 audio_channel_count = 7;
  void clear_audio_channel_count() ;
  ::int32_t audio_channel_count() const;
  void set_audio_channel_count(::int32_t value);

  private:
  ::int32_t _internal_audio_channel_count() const;
  void _internal_set_audio_channel_count(::int32_t value);

  public:
  // bool profanity_filter = 5;
  void clear_profanity_filter() ;
  bool profanity_filter() const;
  void set_profanity_filter(bool value);

  private:
  bool _internal_profanity_filter() const;
  void _internal_set_profanity_filter(bool value);

  public:
  // bool enable_word_time_offsets = 8;
  void clear_enable_word_time_offsets() ;
  bool enable_word_time_offsets() const;
  void set_enable_word_time_offsets(bool value);

  private:
  bool _internal_enable_word_time_offsets() const;
  void _internal_set_enable_word_time_offsets(bool value);

  public:
  // bool enable_automatic_punctuation = 11;
  void clear_enable_automatic_punctuation() ;
  bool enable_automatic_punctuation() const;
  void set_enable_automatic_punctuation(bool value);

  private:
  bool _internal_enable_automatic_punctuation() const;
  void _internal_set_enable_automatic_punctuation(bool value);

  public:
  // bool enable_separate_recognition_per_channel = 12;
  void clear_enable_separate_recognition_per_channel() ;
  bool enable_separate_recognition_per_channel() const;
  void set_enable_separate_recognition_per_channel(bool value);

  private:
  bool _internal_enable_separate_recognition_per_channel() const;
  void _internal_set_enable_separate_recognition_per_channel(bool value);

  public:
  // bool verbatim_transcripts = 14;
  void clear_verbatim_transcripts() ;
  bool verbatim_transcripts() const;
  void set_verbatim_transcripts(bool value);

  private:
  bool _internal_verbatim_transcripts() const;
  void _internal_set_verbatim_transcripts(bool value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.RecognitionConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 15, 4,
      88, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::SpeechContext > speech_contexts_;
    ::google::protobuf::internal::MapField<RecognitionConfig_CustomConfigurationEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        custom_configuration_;
    ::google::protobuf::internal::ArenaStringPtr language_code_;
    ::google::protobuf::internal::ArenaStringPtr model_;
    ::nvidia::riva::asr::SpeakerDiarizationConfig* diarization_config_;
    ::nvidia::riva::asr::EndpointingConfig* endpointing_config_;
    int encoding_;
    ::int32_t sample_rate_hertz_;
    ::int32_t max_alternatives_;
    ::int32_t audio_channel_count_;
    bool profanity_filter_;
    bool enable_word_time_offsets_;
    bool enable_automatic_punctuation_;
    bool enable_separate_recognition_per_channel_;
    bool verbatim_transcripts_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class StreamingRecognitionResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.StreamingRecognitionResult) */ {
 public:
  inline StreamingRecognitionResult() : StreamingRecognitionResult(nullptr) {}
  ~StreamingRecognitionResult() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamingRecognitionResult(::google::protobuf::internal::ConstantInitialized);

  inline StreamingRecognitionResult(const StreamingRecognitionResult& from)
      : StreamingRecognitionResult(nullptr, from) {}
  StreamingRecognitionResult(StreamingRecognitionResult&& from) noexcept
    : StreamingRecognitionResult() {
    *this = ::std::move(from);
  }

  inline StreamingRecognitionResult& operator=(const StreamingRecognitionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamingRecognitionResult& operator=(StreamingRecognitionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamingRecognitionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamingRecognitionResult* internal_default_instance() {
    return reinterpret_cast<const StreamingRecognitionResult*>(
               &_StreamingRecognitionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(StreamingRecognitionResult& a, StreamingRecognitionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamingRecognitionResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamingRecognitionResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamingRecognitionResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamingRecognitionResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamingRecognitionResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StreamingRecognitionResult& from) {
    StreamingRecognitionResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreamingRecognitionResult* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.StreamingRecognitionResult";
  }
  protected:
  explicit StreamingRecognitionResult(::google::protobuf::Arena* arena);
  StreamingRecognitionResult(::google::protobuf::Arena* arena, const StreamingRecognitionResult& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlternativesFieldNumber = 1,
    kPipelineStatesFieldNumber = 7,
    kIsFinalFieldNumber = 2,
    kStabilityFieldNumber = 3,
    kChannelTagFieldNumber = 5,
    kAudioProcessedFieldNumber = 6,
  };
  // repeated .nvidia.riva.asr.SpeechRecognitionAlternative alternatives = 1;
  int alternatives_size() const;
  private:
  int _internal_alternatives_size() const;

  public:
  void clear_alternatives() ;
  ::nvidia::riva::asr::SpeechRecognitionAlternative* mutable_alternatives(int index);
  ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::SpeechRecognitionAlternative >*
      mutable_alternatives();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionAlternative>& _internal_alternatives() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionAlternative>* _internal_mutable_alternatives();
  public:
  const ::nvidia::riva::asr::SpeechRecognitionAlternative& alternatives(int index) const;
  ::nvidia::riva::asr::SpeechRecognitionAlternative* add_alternatives();
  const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::SpeechRecognitionAlternative >&
      alternatives() const;
  // optional .nvidia.riva.asr.PipelineStates pipeline_states = 7;
  bool has_pipeline_states() const;
  void clear_pipeline_states() ;
  const ::nvidia::riva::asr::PipelineStates& pipeline_states() const;
  PROTOBUF_NODISCARD ::nvidia::riva::asr::PipelineStates* release_pipeline_states();
  ::nvidia::riva::asr::PipelineStates* mutable_pipeline_states();
  void set_allocated_pipeline_states(::nvidia::riva::asr::PipelineStates* value);
  void unsafe_arena_set_allocated_pipeline_states(::nvidia::riva::asr::PipelineStates* value);
  ::nvidia::riva::asr::PipelineStates* unsafe_arena_release_pipeline_states();

  private:
  const ::nvidia::riva::asr::PipelineStates& _internal_pipeline_states() const;
  ::nvidia::riva::asr::PipelineStates* _internal_mutable_pipeline_states();

  public:
  // bool is_final = 2;
  void clear_is_final() ;
  bool is_final() const;
  void set_is_final(bool value);

  private:
  bool _internal_is_final() const;
  void _internal_set_is_final(bool value);

  public:
  // float stability = 3;
  void clear_stability() ;
  float stability() const;
  void set_stability(float value);

  private:
  float _internal_stability() const;
  void _internal_set_stability(float value);

  public:
  // int32 channel_tag = 5;
  void clear_channel_tag() ;
  ::int32_t channel_tag() const;
  void set_channel_tag(::int32_t value);

  private:
  ::int32_t _internal_channel_tag() const;
  void _internal_set_channel_tag(::int32_t value);

  public:
  // float audio_processed = 6;
  void clear_audio_processed() ;
  float audio_processed() const;
  void set_audio_processed(float value);

  private:
  float _internal_audio_processed() const;
  void _internal_set_audio_processed(float value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.StreamingRecognitionResult)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::SpeechRecognitionAlternative > alternatives_;
    ::nvidia::riva::asr::PipelineStates* pipeline_states_;
    bool is_final_;
    float stability_;
    ::int32_t channel_tag_;
    float audio_processed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class StreamingRecognitionConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.StreamingRecognitionConfig) */ {
 public:
  inline StreamingRecognitionConfig() : StreamingRecognitionConfig(nullptr) {}
  ~StreamingRecognitionConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamingRecognitionConfig(::google::protobuf::internal::ConstantInitialized);

  inline StreamingRecognitionConfig(const StreamingRecognitionConfig& from)
      : StreamingRecognitionConfig(nullptr, from) {}
  StreamingRecognitionConfig(StreamingRecognitionConfig&& from) noexcept
    : StreamingRecognitionConfig() {
    *this = ::std::move(from);
  }

  inline StreamingRecognitionConfig& operator=(const StreamingRecognitionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamingRecognitionConfig& operator=(StreamingRecognitionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamingRecognitionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamingRecognitionConfig* internal_default_instance() {
    return reinterpret_cast<const StreamingRecognitionConfig*>(
               &_StreamingRecognitionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StreamingRecognitionConfig& a, StreamingRecognitionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamingRecognitionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamingRecognitionConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamingRecognitionConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamingRecognitionConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamingRecognitionConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StreamingRecognitionConfig& from) {
    StreamingRecognitionConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreamingRecognitionConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.StreamingRecognitionConfig";
  }
  protected:
  explicit StreamingRecognitionConfig(::google::protobuf::Arena* arena);
  StreamingRecognitionConfig(::google::protobuf::Arena* arena, const StreamingRecognitionConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kInterimResultsFieldNumber = 2,
  };
  // .nvidia.riva.asr.RecognitionConfig config = 1;
  bool has_config() const;
  void clear_config() ;
  const ::nvidia::riva::asr::RecognitionConfig& config() const;
  PROTOBUF_NODISCARD ::nvidia::riva::asr::RecognitionConfig* release_config();
  ::nvidia::riva::asr::RecognitionConfig* mutable_config();
  void set_allocated_config(::nvidia::riva::asr::RecognitionConfig* value);
  void unsafe_arena_set_allocated_config(::nvidia::riva::asr::RecognitionConfig* value);
  ::nvidia::riva::asr::RecognitionConfig* unsafe_arena_release_config();

  private:
  const ::nvidia::riva::asr::RecognitionConfig& _internal_config() const;
  ::nvidia::riva::asr::RecognitionConfig* _internal_mutable_config();

  public:
  // bool interim_results = 2;
  void clear_interim_results() ;
  bool interim_results() const;
  void set_interim_results(bool value);

  private:
  bool _internal_interim_results() const;
  void _internal_set_interim_results(bool value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.StreamingRecognitionConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::nvidia::riva::asr::RecognitionConfig* config_;
    bool interim_results_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class SpeechRecognitionResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.SpeechRecognitionResult) */ {
 public:
  inline SpeechRecognitionResult() : SpeechRecognitionResult(nullptr) {}
  ~SpeechRecognitionResult() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpeechRecognitionResult(::google::protobuf::internal::ConstantInitialized);

  inline SpeechRecognitionResult(const SpeechRecognitionResult& from)
      : SpeechRecognitionResult(nullptr, from) {}
  SpeechRecognitionResult(SpeechRecognitionResult&& from) noexcept
    : SpeechRecognitionResult() {
    *this = ::std::move(from);
  }

  inline SpeechRecognitionResult& operator=(const SpeechRecognitionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeechRecognitionResult& operator=(SpeechRecognitionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeechRecognitionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpeechRecognitionResult* internal_default_instance() {
    return reinterpret_cast<const SpeechRecognitionResult*>(
               &_SpeechRecognitionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SpeechRecognitionResult& a, SpeechRecognitionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeechRecognitionResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeechRecognitionResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeechRecognitionResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpeechRecognitionResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SpeechRecognitionResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SpeechRecognitionResult& from) {
    SpeechRecognitionResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SpeechRecognitionResult* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.SpeechRecognitionResult";
  }
  protected:
  explicit SpeechRecognitionResult(::google::protobuf::Arena* arena);
  SpeechRecognitionResult(::google::protobuf::Arena* arena, const SpeechRecognitionResult& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlternativesFieldNumber = 1,
    kChannelTagFieldNumber = 2,
    kAudioProcessedFieldNumber = 3,
  };
  // repeated .nvidia.riva.asr.SpeechRecognitionAlternative alternatives = 1;
  int alternatives_size() const;
  private:
  int _internal_alternatives_size() const;

  public:
  void clear_alternatives() ;
  ::nvidia::riva::asr::SpeechRecognitionAlternative* mutable_alternatives(int index);
  ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::SpeechRecognitionAlternative >*
      mutable_alternatives();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionAlternative>& _internal_alternatives() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionAlternative>* _internal_mutable_alternatives();
  public:
  const ::nvidia::riva::asr::SpeechRecognitionAlternative& alternatives(int index) const;
  ::nvidia::riva::asr::SpeechRecognitionAlternative* add_alternatives();
  const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::SpeechRecognitionAlternative >&
      alternatives() const;
  // int32 channel_tag = 2;
  void clear_channel_tag() ;
  ::int32_t channel_tag() const;
  void set_channel_tag(::int32_t value);

  private:
  ::int32_t _internal_channel_tag() const;
  void _internal_set_channel_tag(::int32_t value);

  public:
  // float audio_processed = 3;
  void clear_audio_processed() ;
  float audio_processed() const;
  void set_audio_processed(float value);

  private:
  float _internal_audio_processed() const;
  void _internal_set_audio_processed(float value);

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.SpeechRecognitionResult)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::SpeechRecognitionAlternative > alternatives_;
    ::int32_t channel_tag_;
    float audio_processed_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class RivaSpeechRecognitionConfigResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse) */ {
 public:
  inline RivaSpeechRecognitionConfigResponse() : RivaSpeechRecognitionConfigResponse(nullptr) {}
  ~RivaSpeechRecognitionConfigResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RivaSpeechRecognitionConfigResponse(::google::protobuf::internal::ConstantInitialized);

  inline RivaSpeechRecognitionConfigResponse(const RivaSpeechRecognitionConfigResponse& from)
      : RivaSpeechRecognitionConfigResponse(nullptr, from) {}
  RivaSpeechRecognitionConfigResponse(RivaSpeechRecognitionConfigResponse&& from) noexcept
    : RivaSpeechRecognitionConfigResponse() {
    *this = ::std::move(from);
  }

  inline RivaSpeechRecognitionConfigResponse& operator=(const RivaSpeechRecognitionConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RivaSpeechRecognitionConfigResponse& operator=(RivaSpeechRecognitionConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RivaSpeechRecognitionConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RivaSpeechRecognitionConfigResponse* internal_default_instance() {
    return reinterpret_cast<const RivaSpeechRecognitionConfigResponse*>(
               &_RivaSpeechRecognitionConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RivaSpeechRecognitionConfigResponse& a, RivaSpeechRecognitionConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RivaSpeechRecognitionConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RivaSpeechRecognitionConfigResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RivaSpeechRecognitionConfigResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RivaSpeechRecognitionConfigResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RivaSpeechRecognitionConfigResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RivaSpeechRecognitionConfigResponse& from) {
    RivaSpeechRecognitionConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RivaSpeechRecognitionConfigResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.RivaSpeechRecognitionConfigResponse";
  }
  protected:
  explicit RivaSpeechRecognitionConfigResponse(::google::protobuf::Arena* arena);
  RivaSpeechRecognitionConfigResponse(::google::protobuf::Arena* arena, const RivaSpeechRecognitionConfigResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Config = RivaSpeechRecognitionConfigResponse_Config;

  // accessors -------------------------------------------------------

  enum : int {
    kModelConfigFieldNumber = 1,
  };
  // repeated .nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config model_config = 1;
  int model_config_size() const;
  private:
  int _internal_model_config_size() const;

  public:
  void clear_model_config() ;
  ::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config* mutable_model_config(int index);
  ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config >*
      mutable_model_config();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config>& _internal_model_config() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config>* _internal_mutable_model_config();
  public:
  const ::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config& model_config(int index) const;
  ::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config* add_model_config();
  const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config >&
      model_config() const;
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config > model_config_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class RecognizeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.RecognizeRequest) */ {
 public:
  inline RecognizeRequest() : RecognizeRequest(nullptr) {}
  ~RecognizeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecognizeRequest(::google::protobuf::internal::ConstantInitialized);

  inline RecognizeRequest(const RecognizeRequest& from)
      : RecognizeRequest(nullptr, from) {}
  RecognizeRequest(RecognizeRequest&& from) noexcept
    : RecognizeRequest() {
    *this = ::std::move(from);
  }

  inline RecognizeRequest& operator=(const RecognizeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecognizeRequest& operator=(RecognizeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecognizeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecognizeRequest* internal_default_instance() {
    return reinterpret_cast<const RecognizeRequest*>(
               &_RecognizeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RecognizeRequest& a, RecognizeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecognizeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecognizeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecognizeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecognizeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecognizeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecognizeRequest& from) {
    RecognizeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecognizeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.RecognizeRequest";
  }
  protected:
  explicit RecognizeRequest(::google::protobuf::Arena* arena);
  RecognizeRequest(::google::protobuf::Arena* arena, const RecognizeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioFieldNumber = 2,
    kConfigFieldNumber = 1,
    kIdFieldNumber = 100,
  };
  // bytes audio = 2;
  void clear_audio() ;
  const std::string& audio() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_audio(Arg_&& arg, Args_... args);
  std::string* mutable_audio();
  PROTOBUF_NODISCARD std::string* release_audio();
  void set_allocated_audio(std::string* value);

  private:
  const std::string& _internal_audio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio(
      const std::string& value);
  std::string* _internal_mutable_audio();

  public:
  // .nvidia.riva.asr.RecognitionConfig config = 1;
  bool has_config() const;
  void clear_config() ;
  const ::nvidia::riva::asr::RecognitionConfig& config() const;
  PROTOBUF_NODISCARD ::nvidia::riva::asr::RecognitionConfig* release_config();
  ::nvidia::riva::asr::RecognitionConfig* mutable_config();
  void set_allocated_config(::nvidia::riva::asr::RecognitionConfig* value);
  void unsafe_arena_set_allocated_config(::nvidia::riva::asr::RecognitionConfig* value);
  ::nvidia::riva::asr::RecognitionConfig* unsafe_arena_release_config();

  private:
  const ::nvidia::riva::asr::RecognitionConfig& _internal_config() const;
  ::nvidia::riva::asr::RecognitionConfig* _internal_mutable_config();

  public:
  // .nvidia.riva.RequestId id = 100;
  bool has_id() const;
  void clear_id() ;
  const ::nvidia::riva::RequestId& id() const;
  PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  ::nvidia::riva::RequestId* mutable_id();
  void set_allocated_id(::nvidia::riva::RequestId* value);
  void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.RecognizeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr audio_;
    ::nvidia::riva::asr::RecognitionConfig* config_;
    ::nvidia::riva::RequestId* id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class StreamingRecognizeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.StreamingRecognizeResponse) */ {
 public:
  inline StreamingRecognizeResponse() : StreamingRecognizeResponse(nullptr) {}
  ~StreamingRecognizeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamingRecognizeResponse(::google::protobuf::internal::ConstantInitialized);

  inline StreamingRecognizeResponse(const StreamingRecognizeResponse& from)
      : StreamingRecognizeResponse(nullptr, from) {}
  StreamingRecognizeResponse(StreamingRecognizeResponse&& from) noexcept
    : StreamingRecognizeResponse() {
    *this = ::std::move(from);
  }

  inline StreamingRecognizeResponse& operator=(const StreamingRecognizeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamingRecognizeResponse& operator=(StreamingRecognizeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamingRecognizeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamingRecognizeResponse* internal_default_instance() {
    return reinterpret_cast<const StreamingRecognizeResponse*>(
               &_StreamingRecognizeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(StreamingRecognizeResponse& a, StreamingRecognizeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamingRecognizeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamingRecognizeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamingRecognizeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamingRecognizeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamingRecognizeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StreamingRecognizeResponse& from) {
    StreamingRecognizeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreamingRecognizeResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.StreamingRecognizeResponse";
  }
  protected:
  explicit StreamingRecognizeResponse(::google::protobuf::Arena* arena);
  StreamingRecognizeResponse(::google::protobuf::Arena* arena, const StreamingRecognizeResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
    kIdFieldNumber = 100,
  };
  // repeated .nvidia.riva.asr.StreamingRecognitionResult results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;

  public:
  void clear_results() ;
  ::nvidia::riva::asr::StreamingRecognitionResult* mutable_results(int index);
  ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::StreamingRecognitionResult >*
      mutable_results();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::StreamingRecognitionResult>& _internal_results() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::StreamingRecognitionResult>* _internal_mutable_results();
  public:
  const ::nvidia::riva::asr::StreamingRecognitionResult& results(int index) const;
  ::nvidia::riva::asr::StreamingRecognitionResult* add_results();
  const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::StreamingRecognitionResult >&
      results() const;
  // .nvidia.riva.RequestId id = 100;
  bool has_id() const;
  void clear_id() ;
  const ::nvidia::riva::RequestId& id() const;
  PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  ::nvidia::riva::RequestId* mutable_id();
  void set_allocated_id(::nvidia::riva::RequestId* value);
  void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.StreamingRecognizeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::StreamingRecognitionResult > results_;
    ::nvidia::riva::RequestId* id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class StreamingRecognizeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.StreamingRecognizeRequest) */ {
 public:
  inline StreamingRecognizeRequest() : StreamingRecognizeRequest(nullptr) {}
  ~StreamingRecognizeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamingRecognizeRequest(::google::protobuf::internal::ConstantInitialized);

  inline StreamingRecognizeRequest(const StreamingRecognizeRequest& from)
      : StreamingRecognizeRequest(nullptr, from) {}
  StreamingRecognizeRequest(StreamingRecognizeRequest&& from) noexcept
    : StreamingRecognizeRequest() {
    *this = ::std::move(from);
  }

  inline StreamingRecognizeRequest& operator=(const StreamingRecognizeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamingRecognizeRequest& operator=(StreamingRecognizeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamingRecognizeRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StreamingRequestCase {
    kStreamingConfig = 1,
    kAudioContent = 2,
    STREAMING_REQUEST_NOT_SET = 0,
  };

  static inline const StreamingRecognizeRequest* internal_default_instance() {
    return reinterpret_cast<const StreamingRecognizeRequest*>(
               &_StreamingRecognizeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StreamingRecognizeRequest& a, StreamingRecognizeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamingRecognizeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamingRecognizeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamingRecognizeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamingRecognizeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamingRecognizeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StreamingRecognizeRequest& from) {
    StreamingRecognizeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreamingRecognizeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.StreamingRecognizeRequest";
  }
  protected:
  explicit StreamingRecognizeRequest(::google::protobuf::Arena* arena);
  StreamingRecognizeRequest(::google::protobuf::Arena* arena, const StreamingRecognizeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 100,
    kStreamingConfigFieldNumber = 1,
    kAudioContentFieldNumber = 2,
  };
  // .nvidia.riva.RequestId id = 100;
  bool has_id() const;
  void clear_id() ;
  const ::nvidia::riva::RequestId& id() const;
  PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  ::nvidia::riva::RequestId* mutable_id();
  void set_allocated_id(::nvidia::riva::RequestId* value);
  void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // .nvidia.riva.asr.StreamingRecognitionConfig streaming_config = 1;
  bool has_streaming_config() const;
  private:
  bool _internal_has_streaming_config() const;

  public:
  void clear_streaming_config() ;
  const ::nvidia::riva::asr::StreamingRecognitionConfig& streaming_config() const;
  PROTOBUF_NODISCARD ::nvidia::riva::asr::StreamingRecognitionConfig* release_streaming_config();
  ::nvidia::riva::asr::StreamingRecognitionConfig* mutable_streaming_config();
  void set_allocated_streaming_config(::nvidia::riva::asr::StreamingRecognitionConfig* value);
  void unsafe_arena_set_allocated_streaming_config(::nvidia::riva::asr::StreamingRecognitionConfig* value);
  ::nvidia::riva::asr::StreamingRecognitionConfig* unsafe_arena_release_streaming_config();

  private:
  const ::nvidia::riva::asr::StreamingRecognitionConfig& _internal_streaming_config() const;
  ::nvidia::riva::asr::StreamingRecognitionConfig* _internal_mutable_streaming_config();

  public:
  // bytes audio_content = 2;
  bool has_audio_content() const;
  void clear_audio_content() ;
  const std::string& audio_content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_audio_content(Arg_&& arg, Args_... args);
  std::string* mutable_audio_content();
  PROTOBUF_NODISCARD std::string* release_audio_content();
  void set_allocated_audio_content(std::string* value);

  private:
  const std::string& _internal_audio_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_content(
      const std::string& value);
  std::string* _internal_mutable_audio_content();

  public:
  void clear_streaming_request();
  StreamingRequestCase streaming_request_case() const;
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.StreamingRecognizeRequest)
 private:
  class _Internal;
  void set_has_streaming_config();
  void set_has_audio_content();

  inline bool has_streaming_request() const;
  inline void clear_has_streaming_request();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 2,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::nvidia::riva::RequestId* id_;
    union StreamingRequestUnion {
      constexpr StreamingRequestUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::nvidia::riva::asr::StreamingRecognitionConfig* streaming_config_;
      ::google::protobuf::internal::ArenaStringPtr audio_content_;
    } streaming_request_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};// -------------------------------------------------------------------

class RecognizeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nvidia.riva.asr.RecognizeResponse) */ {
 public:
  inline RecognizeResponse() : RecognizeResponse(nullptr) {}
  ~RecognizeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecognizeResponse(::google::protobuf::internal::ConstantInitialized);

  inline RecognizeResponse(const RecognizeResponse& from)
      : RecognizeResponse(nullptr, from) {}
  RecognizeResponse(RecognizeResponse&& from) noexcept
    : RecognizeResponse() {
    *this = ::std::move(from);
  }

  inline RecognizeResponse& operator=(const RecognizeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecognizeResponse& operator=(RecognizeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecognizeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecognizeResponse* internal_default_instance() {
    return reinterpret_cast<const RecognizeResponse*>(
               &_RecognizeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RecognizeResponse& a, RecognizeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RecognizeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecognizeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecognizeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecognizeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecognizeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecognizeResponse& from) {
    RecognizeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecognizeResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nvidia.riva.asr.RecognizeResponse";
  }
  protected:
  explicit RecognizeResponse(::google::protobuf::Arena* arena);
  RecognizeResponse(::google::protobuf::Arena* arena, const RecognizeResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
    kIdFieldNumber = 100,
  };
  // repeated .nvidia.riva.asr.SpeechRecognitionResult results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;

  public:
  void clear_results() ;
  ::nvidia::riva::asr::SpeechRecognitionResult* mutable_results(int index);
  ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::SpeechRecognitionResult >*
      mutable_results();
  private:
  const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionResult>& _internal_results() const;
  ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionResult>* _internal_mutable_results();
  public:
  const ::nvidia::riva::asr::SpeechRecognitionResult& results(int index) const;
  ::nvidia::riva::asr::SpeechRecognitionResult* add_results();
  const ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::SpeechRecognitionResult >&
      results() const;
  // .nvidia.riva.RequestId id = 100;
  bool has_id() const;
  void clear_id() ;
  const ::nvidia::riva::RequestId& id() const;
  PROTOBUF_NODISCARD ::nvidia::riva::RequestId* release_id();
  ::nvidia::riva::RequestId* mutable_id();
  void set_allocated_id(::nvidia::riva::RequestId* value);
  void unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value);
  ::nvidia::riva::RequestId* unsafe_arena_release_id();

  private:
  const ::nvidia::riva::RequestId& _internal_id() const;
  ::nvidia::riva::RequestId* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:nvidia.riva.asr.RecognizeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::nvidia::riva::asr::SpeechRecognitionResult > results_;
    ::nvidia::riva::RequestId* id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_riva_2fproto_2friva_5fasr_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RivaSpeechRecognitionConfigRequest

// string model_name = 1;
inline void RivaSpeechRecognitionConfigRequest::clear_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& RivaSpeechRecognitionConfigRequest::model_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RivaSpeechRecognitionConfigRequest.model_name)
  return _internal_model_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RivaSpeechRecognitionConfigRequest::set_model_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.RivaSpeechRecognitionConfigRequest.model_name)
}
inline std::string* RivaSpeechRecognitionConfigRequest::mutable_model_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.RivaSpeechRecognitionConfigRequest.model_name)
  return _s;
}
inline const std::string& RivaSpeechRecognitionConfigRequest::_internal_model_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.model_name_.Get();
}
inline void RivaSpeechRecognitionConfigRequest::_internal_set_model_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_name_.Set(value, GetArena());
}
inline std::string* RivaSpeechRecognitionConfigRequest::_internal_mutable_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.model_name_.Mutable( GetArena());
}
inline std::string* RivaSpeechRecognitionConfigRequest::release_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.RivaSpeechRecognitionConfigRequest.model_name)
  return _impl_.model_name_.Release();
}
inline void RivaSpeechRecognitionConfigRequest::set_allocated_model_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.model_name_.IsDefault()) {
          _impl_.model_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.RivaSpeechRecognitionConfigRequest.model_name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RivaSpeechRecognitionConfigResponse_Config

// string model_name = 1;
inline void RivaSpeechRecognitionConfigResponse_Config::clear_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& RivaSpeechRecognitionConfigResponse_Config::model_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config.model_name)
  return _internal_model_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RivaSpeechRecognitionConfigResponse_Config::set_model_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config.model_name)
}
inline std::string* RivaSpeechRecognitionConfigResponse_Config::mutable_model_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config.model_name)
  return _s;
}
inline const std::string& RivaSpeechRecognitionConfigResponse_Config::_internal_model_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.model_name_.Get();
}
inline void RivaSpeechRecognitionConfigResponse_Config::_internal_set_model_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_name_.Set(value, GetArena());
}
inline std::string* RivaSpeechRecognitionConfigResponse_Config::_internal_mutable_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.model_name_.Mutable( GetArena());
}
inline std::string* RivaSpeechRecognitionConfigResponse_Config::release_model_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config.model_name)
  return _impl_.model_name_.Release();
}
inline void RivaSpeechRecognitionConfigResponse_Config::set_allocated_model_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.model_name_.IsDefault()) {
          _impl_.model_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config.model_name)
}

// map<string, string> parameters = 2;
inline int RivaSpeechRecognitionConfigResponse_Config::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int RivaSpeechRecognitionConfigResponse_Config::parameters_size() const {
  return _internal_parameters_size();
}
inline void RivaSpeechRecognitionConfigResponse_Config::clear_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& RivaSpeechRecognitionConfigResponse_Config::_internal_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& RivaSpeechRecognitionConfigResponse_Config::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* RivaSpeechRecognitionConfigResponse_Config::_internal_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* RivaSpeechRecognitionConfigResponse_Config::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// RivaSpeechRecognitionConfigResponse

// repeated .nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config model_config = 1;
inline int RivaSpeechRecognitionConfigResponse::_internal_model_config_size() const {
  return _internal_model_config().size();
}
inline int RivaSpeechRecognitionConfigResponse::model_config_size() const {
  return _internal_model_config_size();
}
inline void RivaSpeechRecognitionConfigResponse::clear_model_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_config_.Clear();
}
inline ::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config* RivaSpeechRecognitionConfigResponse::mutable_model_config(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.model_config)
  return _internal_mutable_model_config()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config>* RivaSpeechRecognitionConfigResponse::mutable_model_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.model_config)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_model_config();
}
inline const ::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config& RivaSpeechRecognitionConfigResponse::model_config(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.model_config)
  return _internal_model_config().Get(index);
}
inline ::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config* RivaSpeechRecognitionConfigResponse::add_model_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config* _add = _internal_mutable_model_config()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.model_config)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config>& RivaSpeechRecognitionConfigResponse::model_config() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.model_config)
  return _internal_model_config();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config>&
RivaSpeechRecognitionConfigResponse::_internal_model_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.model_config_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::RivaSpeechRecognitionConfigResponse_Config>*
RivaSpeechRecognitionConfigResponse::_internal_mutable_model_config() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.model_config_;
}

// -------------------------------------------------------------------

// RecognizeRequest

// .nvidia.riva.asr.RecognitionConfig config = 1;
inline bool RecognizeRequest::has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.config_ != nullptr);
  return value;
}
inline void RecognizeRequest::clear_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.config_ != nullptr) _impl_.config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nvidia::riva::asr::RecognitionConfig& RecognizeRequest::_internal_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::asr::RecognitionConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::asr::RecognitionConfig&>(::nvidia::riva::asr::_RecognitionConfig_default_instance_);
}
inline const ::nvidia::riva::asr::RecognitionConfig& RecognizeRequest::config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognizeRequest.config)
  return _internal_config();
}
inline void RecognizeRequest::unsafe_arena_set_allocated_config(::nvidia::riva::asr::RecognitionConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = reinterpret_cast<::nvidia::riva::asr::RecognitionConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.asr.RecognizeRequest.config)
}
inline ::nvidia::riva::asr::RecognitionConfig* RecognizeRequest::release_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::asr::RecognitionConfig* released = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::asr::RecognitionConfig* RecognizeRequest::unsafe_arena_release_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.RecognizeRequest.config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::asr::RecognitionConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::nvidia::riva::asr::RecognitionConfig* RecognizeRequest::_internal_mutable_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::asr::RecognitionConfig>(GetArena());
    _impl_.config_ = reinterpret_cast<::nvidia::riva::asr::RecognitionConfig*>(p);
  }
  return _impl_.config_;
}
inline ::nvidia::riva::asr::RecognitionConfig* RecognizeRequest::mutable_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::asr::RecognitionConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.RecognizeRequest.config)
  return _msg;
}
inline void RecognizeRequest::set_allocated_config(::nvidia::riva::asr::RecognitionConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::nvidia::riva::asr::RecognitionConfig*>(_impl_.config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::nvidia::riva::asr::RecognitionConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.config_ = reinterpret_cast<::nvidia::riva::asr::RecognitionConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.RecognizeRequest.config)
}

// bytes audio = 2;
inline void RecognizeRequest::clear_audio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_.ClearToEmpty();
}
inline const std::string& RecognizeRequest::audio() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognizeRequest.audio)
  return _internal_audio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecognizeRequest::set_audio(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.audio_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.RecognizeRequest.audio)
}
inline std::string* RecognizeRequest::mutable_audio() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.RecognizeRequest.audio)
  return _s;
}
inline const std::string& RecognizeRequest::_internal_audio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_.Get();
}
inline void RecognizeRequest::_internal_set_audio(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.audio_.Set(value, GetArena());
}
inline std::string* RecognizeRequest::_internal_mutable_audio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.audio_.Mutable( GetArena());
}
inline std::string* RecognizeRequest::release_audio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.RecognizeRequest.audio)
  return _impl_.audio_.Release();
}
inline void RecognizeRequest::set_allocated_audio(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.audio_.IsDefault()) {
          _impl_.audio_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.RecognizeRequest.audio)
}

// .nvidia.riva.RequestId id = 100;
inline bool RecognizeRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& RecognizeRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& RecognizeRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognizeRequest.id)
  return _internal_id();
}
inline void RecognizeRequest::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.asr.RecognizeRequest.id)
}
inline ::nvidia::riva::RequestId* RecognizeRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* RecognizeRequest::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.RecognizeRequest.id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* RecognizeRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* RecognizeRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.RecognizeRequest.id)
  return _msg;
}
inline void RecognizeRequest::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.RecognizeRequest.id)
}

// -------------------------------------------------------------------

// StreamingRecognizeRequest

// .nvidia.riva.asr.StreamingRecognitionConfig streaming_config = 1;
inline bool StreamingRecognizeRequest::has_streaming_config() const {
  return streaming_request_case() == kStreamingConfig;
}
inline bool StreamingRecognizeRequest::_internal_has_streaming_config() const {
  return streaming_request_case() == kStreamingConfig;
}
inline void StreamingRecognizeRequest::set_has_streaming_config() {
  _impl_._oneof_case_[0] = kStreamingConfig;
}
inline void StreamingRecognizeRequest::clear_streaming_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (streaming_request_case() == kStreamingConfig) {
    if (GetArena() == nullptr) {
      delete _impl_.streaming_request_.streaming_config_;
    }
    clear_has_streaming_request();
  }
}
inline ::nvidia::riva::asr::StreamingRecognitionConfig* StreamingRecognizeRequest::release_streaming_config() {
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.StreamingRecognizeRequest.streaming_config)
  if (streaming_request_case() == kStreamingConfig) {
    clear_has_streaming_request();
    auto* temp = _impl_.streaming_request_.streaming_config_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.streaming_request_.streaming_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::nvidia::riva::asr::StreamingRecognitionConfig& StreamingRecognizeRequest::_internal_streaming_config() const {
  return streaming_request_case() == kStreamingConfig ? *_impl_.streaming_request_.streaming_config_ : reinterpret_cast<::nvidia::riva::asr::StreamingRecognitionConfig&>(::nvidia::riva::asr::_StreamingRecognitionConfig_default_instance_);
}
inline const ::nvidia::riva::asr::StreamingRecognitionConfig& StreamingRecognizeRequest::streaming_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.StreamingRecognizeRequest.streaming_config)
  return _internal_streaming_config();
}
inline ::nvidia::riva::asr::StreamingRecognitionConfig* StreamingRecognizeRequest::unsafe_arena_release_streaming_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:nvidia.riva.asr.StreamingRecognizeRequest.streaming_config)
  if (streaming_request_case() == kStreamingConfig) {
    clear_has_streaming_request();
    auto* temp = _impl_.streaming_request_.streaming_config_;
    _impl_.streaming_request_.streaming_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamingRecognizeRequest::unsafe_arena_set_allocated_streaming_config(::nvidia::riva::asr::StreamingRecognitionConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_streaming_request();
  if (value) {
    set_has_streaming_config();
    _impl_.streaming_request_.streaming_config_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.asr.StreamingRecognizeRequest.streaming_config)
}
inline ::nvidia::riva::asr::StreamingRecognitionConfig* StreamingRecognizeRequest::_internal_mutable_streaming_config() {
  if (streaming_request_case() != kStreamingConfig) {
    clear_streaming_request();
    set_has_streaming_config();
    _impl_.streaming_request_.streaming_config_ = CreateMaybeMessage<::nvidia::riva::asr::StreamingRecognitionConfig>(GetArena());
  }
  return _impl_.streaming_request_.streaming_config_;
}
inline ::nvidia::riva::asr::StreamingRecognitionConfig* StreamingRecognizeRequest::mutable_streaming_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::asr::StreamingRecognitionConfig* _msg = _internal_mutable_streaming_config();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.StreamingRecognizeRequest.streaming_config)
  return _msg;
}

// bytes audio_content = 2;
inline bool StreamingRecognizeRequest::has_audio_content() const {
  return streaming_request_case() == kAudioContent;
}
inline void StreamingRecognizeRequest::set_has_audio_content() {
  _impl_._oneof_case_[0] = kAudioContent;
}
inline void StreamingRecognizeRequest::clear_audio_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (streaming_request_case() == kAudioContent) {
    _impl_.streaming_request_.audio_content_.Destroy();
    clear_has_streaming_request();
  }
}
inline const std::string& StreamingRecognizeRequest::audio_content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.StreamingRecognizeRequest.audio_content)
  return _internal_audio_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamingRecognizeRequest::set_audio_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (streaming_request_case() != kAudioContent) {
    clear_streaming_request();

    set_has_audio_content();
    _impl_.streaming_request_.audio_content_.InitDefault();
  }
  _impl_.streaming_request_.audio_content_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.StreamingRecognizeRequest.audio_content)
}
inline std::string* StreamingRecognizeRequest::mutable_audio_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_audio_content();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.StreamingRecognizeRequest.audio_content)
  return _s;
}
inline const std::string& StreamingRecognizeRequest::_internal_audio_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (streaming_request_case() != kAudioContent) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.streaming_request_.audio_content_.Get();
}
inline void StreamingRecognizeRequest::_internal_set_audio_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (streaming_request_case() != kAudioContent) {
    clear_streaming_request();

    set_has_audio_content();
    _impl_.streaming_request_.audio_content_.InitDefault();
  }
  _impl_.streaming_request_.audio_content_.Set(value, GetArena());
}
inline std::string* StreamingRecognizeRequest::_internal_mutable_audio_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (streaming_request_case() != kAudioContent) {
    clear_streaming_request();

    set_has_audio_content();
    _impl_.streaming_request_.audio_content_.InitDefault();
  }
  return _impl_.streaming_request_.audio_content_.Mutable( GetArena());
}
inline std::string* StreamingRecognizeRequest::release_audio_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.StreamingRecognizeRequest.audio_content)
  if (streaming_request_case() != kAudioContent) {
    return nullptr;
  }
  clear_has_streaming_request();
  return _impl_.streaming_request_.audio_content_.Release();
}
inline void StreamingRecognizeRequest::set_allocated_audio_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_streaming_request()) {
    clear_streaming_request();
  }
  if (value != nullptr) {
    set_has_audio_content();
    _impl_.streaming_request_.audio_content_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.StreamingRecognizeRequest.audio_content)
}

// .nvidia.riva.RequestId id = 100;
inline bool StreamingRecognizeRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& StreamingRecognizeRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& StreamingRecognizeRequest::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.StreamingRecognizeRequest.id)
  return _internal_id();
}
inline void StreamingRecognizeRequest::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.asr.StreamingRecognizeRequest.id)
}
inline ::nvidia::riva::RequestId* StreamingRecognizeRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* StreamingRecognizeRequest::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.StreamingRecognizeRequest.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* StreamingRecognizeRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* StreamingRecognizeRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.StreamingRecognizeRequest.id)
  return _msg;
}
inline void StreamingRecognizeRequest::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.StreamingRecognizeRequest.id)
}

inline bool StreamingRecognizeRequest::has_streaming_request() const {
  return streaming_request_case() != STREAMING_REQUEST_NOT_SET;
}
inline void StreamingRecognizeRequest::clear_has_streaming_request() {
  _impl_._oneof_case_[0] = STREAMING_REQUEST_NOT_SET;
}
inline StreamingRecognizeRequest::StreamingRequestCase StreamingRecognizeRequest::streaming_request_case() const {
  return StreamingRecognizeRequest::StreamingRequestCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EndpointingConfig

// optional int32 start_history = 1;
inline bool EndpointingConfig::has_start_history() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EndpointingConfig::clear_start_history() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_history_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t EndpointingConfig::start_history() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.EndpointingConfig.start_history)
  return _internal_start_history();
}
inline void EndpointingConfig::set_start_history(::int32_t value) {
  _internal_set_start_history(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.EndpointingConfig.start_history)
}
inline ::int32_t EndpointingConfig::_internal_start_history() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_history_;
}
inline void EndpointingConfig::_internal_set_start_history(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.start_history_ = value;
}

// optional float start_threshold = 2;
inline bool EndpointingConfig::has_start_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EndpointingConfig::clear_start_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_threshold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float EndpointingConfig::start_threshold() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.EndpointingConfig.start_threshold)
  return _internal_start_threshold();
}
inline void EndpointingConfig::set_start_threshold(float value) {
  _internal_set_start_threshold(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.EndpointingConfig.start_threshold)
}
inline float EndpointingConfig::_internal_start_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_threshold_;
}
inline void EndpointingConfig::_internal_set_start_threshold(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.start_threshold_ = value;
}

// optional int32 stop_history = 3;
inline bool EndpointingConfig::has_stop_history() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void EndpointingConfig::clear_stop_history() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stop_history_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t EndpointingConfig::stop_history() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.EndpointingConfig.stop_history)
  return _internal_stop_history();
}
inline void EndpointingConfig::set_stop_history(::int32_t value) {
  _internal_set_stop_history(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.EndpointingConfig.stop_history)
}
inline ::int32_t EndpointingConfig::_internal_stop_history() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stop_history_;
}
inline void EndpointingConfig::_internal_set_stop_history(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stop_history_ = value;
}

// optional float stop_threshold = 4;
inline bool EndpointingConfig::has_stop_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void EndpointingConfig::clear_stop_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stop_threshold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float EndpointingConfig::stop_threshold() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.EndpointingConfig.stop_threshold)
  return _internal_stop_threshold();
}
inline void EndpointingConfig::set_stop_threshold(float value) {
  _internal_set_stop_threshold(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.EndpointingConfig.stop_threshold)
}
inline float EndpointingConfig::_internal_stop_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stop_threshold_;
}
inline void EndpointingConfig::_internal_set_stop_threshold(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.stop_threshold_ = value;
}

// optional int32 stop_history_eou = 5;
inline bool EndpointingConfig::has_stop_history_eou() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void EndpointingConfig::clear_stop_history_eou() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stop_history_eou_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t EndpointingConfig::stop_history_eou() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.EndpointingConfig.stop_history_eou)
  return _internal_stop_history_eou();
}
inline void EndpointingConfig::set_stop_history_eou(::int32_t value) {
  _internal_set_stop_history_eou(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.EndpointingConfig.stop_history_eou)
}
inline ::int32_t EndpointingConfig::_internal_stop_history_eou() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stop_history_eou_;
}
inline void EndpointingConfig::_internal_set_stop_history_eou(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.stop_history_eou_ = value;
}

// optional float stop_threshold_eou = 6;
inline bool EndpointingConfig::has_stop_threshold_eou() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void EndpointingConfig::clear_stop_threshold_eou() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stop_threshold_eou_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float EndpointingConfig::stop_threshold_eou() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.EndpointingConfig.stop_threshold_eou)
  return _internal_stop_threshold_eou();
}
inline void EndpointingConfig::set_stop_threshold_eou(float value) {
  _internal_set_stop_threshold_eou(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.EndpointingConfig.stop_threshold_eou)
}
inline float EndpointingConfig::_internal_stop_threshold_eou() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stop_threshold_eou_;
}
inline void EndpointingConfig::_internal_set_stop_threshold_eou(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.stop_threshold_eou_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RecognitionConfig

// .nvidia.riva.AudioEncoding encoding = 1;
inline void RecognitionConfig::clear_encoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encoding_ = 0;
}
inline ::nvidia::riva::AudioEncoding RecognitionConfig::encoding() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognitionConfig.encoding)
  return _internal_encoding();
}
inline void RecognitionConfig::set_encoding(::nvidia::riva::AudioEncoding value) {
  _internal_set_encoding(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.RecognitionConfig.encoding)
}
inline ::nvidia::riva::AudioEncoding RecognitionConfig::_internal_encoding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::nvidia::riva::AudioEncoding>(_impl_.encoding_);
}
inline void RecognitionConfig::_internal_set_encoding(::nvidia::riva::AudioEncoding value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.encoding_ = value;
}

// int32 sample_rate_hertz = 2;
inline void RecognitionConfig::clear_sample_rate_hertz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_rate_hertz_ = 0;
}
inline ::int32_t RecognitionConfig::sample_rate_hertz() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognitionConfig.sample_rate_hertz)
  return _internal_sample_rate_hertz();
}
inline void RecognitionConfig::set_sample_rate_hertz(::int32_t value) {
  _internal_set_sample_rate_hertz(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.RecognitionConfig.sample_rate_hertz)
}
inline ::int32_t RecognitionConfig::_internal_sample_rate_hertz() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sample_rate_hertz_;
}
inline void RecognitionConfig::_internal_set_sample_rate_hertz(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sample_rate_hertz_ = value;
}

// string language_code = 3;
inline void RecognitionConfig::clear_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_code_.ClearToEmpty();
}
inline const std::string& RecognitionConfig::language_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognitionConfig.language_code)
  return _internal_language_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecognitionConfig::set_language_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.RecognitionConfig.language_code)
}
inline std::string* RecognitionConfig::mutable_language_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_language_code();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.RecognitionConfig.language_code)
  return _s;
}
inline const std::string& RecognitionConfig::_internal_language_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.language_code_.Get();
}
inline void RecognitionConfig::_internal_set_language_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_code_.Set(value, GetArena());
}
inline std::string* RecognitionConfig::_internal_mutable_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.language_code_.Mutable( GetArena());
}
inline std::string* RecognitionConfig::release_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.RecognitionConfig.language_code)
  return _impl_.language_code_.Release();
}
inline void RecognitionConfig::set_allocated_language_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.language_code_.IsDefault()) {
          _impl_.language_code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.RecognitionConfig.language_code)
}

// int32 max_alternatives = 4;
inline void RecognitionConfig::clear_max_alternatives() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_alternatives_ = 0;
}
inline ::int32_t RecognitionConfig::max_alternatives() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognitionConfig.max_alternatives)
  return _internal_max_alternatives();
}
inline void RecognitionConfig::set_max_alternatives(::int32_t value) {
  _internal_set_max_alternatives(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.RecognitionConfig.max_alternatives)
}
inline ::int32_t RecognitionConfig::_internal_max_alternatives() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_alternatives_;
}
inline void RecognitionConfig::_internal_set_max_alternatives(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_alternatives_ = value;
}

// bool profanity_filter = 5;
inline void RecognitionConfig::clear_profanity_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.profanity_filter_ = false;
}
inline bool RecognitionConfig::profanity_filter() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognitionConfig.profanity_filter)
  return _internal_profanity_filter();
}
inline void RecognitionConfig::set_profanity_filter(bool value) {
  _internal_set_profanity_filter(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.RecognitionConfig.profanity_filter)
}
inline bool RecognitionConfig::_internal_profanity_filter() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.profanity_filter_;
}
inline void RecognitionConfig::_internal_set_profanity_filter(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.profanity_filter_ = value;
}

// repeated .nvidia.riva.asr.SpeechContext speech_contexts = 6;
inline int RecognitionConfig::_internal_speech_contexts_size() const {
  return _internal_speech_contexts().size();
}
inline int RecognitionConfig::speech_contexts_size() const {
  return _internal_speech_contexts_size();
}
inline void RecognitionConfig::clear_speech_contexts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speech_contexts_.Clear();
}
inline ::nvidia::riva::asr::SpeechContext* RecognitionConfig::mutable_speech_contexts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.RecognitionConfig.speech_contexts)
  return _internal_mutable_speech_contexts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechContext>* RecognitionConfig::mutable_speech_contexts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.asr.RecognitionConfig.speech_contexts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_speech_contexts();
}
inline const ::nvidia::riva::asr::SpeechContext& RecognitionConfig::speech_contexts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognitionConfig.speech_contexts)
  return _internal_speech_contexts().Get(index);
}
inline ::nvidia::riva::asr::SpeechContext* RecognitionConfig::add_speech_contexts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::asr::SpeechContext* _add = _internal_mutable_speech_contexts()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.asr.RecognitionConfig.speech_contexts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechContext>& RecognitionConfig::speech_contexts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.asr.RecognitionConfig.speech_contexts)
  return _internal_speech_contexts();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechContext>&
RecognitionConfig::_internal_speech_contexts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speech_contexts_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechContext>*
RecognitionConfig::_internal_mutable_speech_contexts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.speech_contexts_;
}

// int32 audio_channel_count = 7;
inline void RecognitionConfig::clear_audio_channel_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_channel_count_ = 0;
}
inline ::int32_t RecognitionConfig::audio_channel_count() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognitionConfig.audio_channel_count)
  return _internal_audio_channel_count();
}
inline void RecognitionConfig::set_audio_channel_count(::int32_t value) {
  _internal_set_audio_channel_count(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.RecognitionConfig.audio_channel_count)
}
inline ::int32_t RecognitionConfig::_internal_audio_channel_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_channel_count_;
}
inline void RecognitionConfig::_internal_set_audio_channel_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.audio_channel_count_ = value;
}

// bool enable_word_time_offsets = 8;
inline void RecognitionConfig::clear_enable_word_time_offsets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_word_time_offsets_ = false;
}
inline bool RecognitionConfig::enable_word_time_offsets() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognitionConfig.enable_word_time_offsets)
  return _internal_enable_word_time_offsets();
}
inline void RecognitionConfig::set_enable_word_time_offsets(bool value) {
  _internal_set_enable_word_time_offsets(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.RecognitionConfig.enable_word_time_offsets)
}
inline bool RecognitionConfig::_internal_enable_word_time_offsets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_word_time_offsets_;
}
inline void RecognitionConfig::_internal_set_enable_word_time_offsets(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_word_time_offsets_ = value;
}

// bool enable_automatic_punctuation = 11;
inline void RecognitionConfig::clear_enable_automatic_punctuation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_automatic_punctuation_ = false;
}
inline bool RecognitionConfig::enable_automatic_punctuation() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognitionConfig.enable_automatic_punctuation)
  return _internal_enable_automatic_punctuation();
}
inline void RecognitionConfig::set_enable_automatic_punctuation(bool value) {
  _internal_set_enable_automatic_punctuation(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.RecognitionConfig.enable_automatic_punctuation)
}
inline bool RecognitionConfig::_internal_enable_automatic_punctuation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_automatic_punctuation_;
}
inline void RecognitionConfig::_internal_set_enable_automatic_punctuation(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_automatic_punctuation_ = value;
}

// bool enable_separate_recognition_per_channel = 12;
inline void RecognitionConfig::clear_enable_separate_recognition_per_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_separate_recognition_per_channel_ = false;
}
inline bool RecognitionConfig::enable_separate_recognition_per_channel() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognitionConfig.enable_separate_recognition_per_channel)
  return _internal_enable_separate_recognition_per_channel();
}
inline void RecognitionConfig::set_enable_separate_recognition_per_channel(bool value) {
  _internal_set_enable_separate_recognition_per_channel(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.RecognitionConfig.enable_separate_recognition_per_channel)
}
inline bool RecognitionConfig::_internal_enable_separate_recognition_per_channel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_separate_recognition_per_channel_;
}
inline void RecognitionConfig::_internal_set_enable_separate_recognition_per_channel(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_separate_recognition_per_channel_ = value;
}

// string model = 13;
inline void RecognitionConfig::clear_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_.ClearToEmpty();
}
inline const std::string& RecognitionConfig::model() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognitionConfig.model)
  return _internal_model();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecognitionConfig::set_model(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.RecognitionConfig.model)
}
inline std::string* RecognitionConfig::mutable_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.RecognitionConfig.model)
  return _s;
}
inline const std::string& RecognitionConfig::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.model_.Get();
}
inline void RecognitionConfig::_internal_set_model(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_.Set(value, GetArena());
}
inline std::string* RecognitionConfig::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.model_.Mutable( GetArena());
}
inline std::string* RecognitionConfig::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.RecognitionConfig.model)
  return _impl_.model_.Release();
}
inline void RecognitionConfig::set_allocated_model(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.model_.IsDefault()) {
          _impl_.model_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.RecognitionConfig.model)
}

// bool verbatim_transcripts = 14;
inline void RecognitionConfig::clear_verbatim_transcripts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbatim_transcripts_ = false;
}
inline bool RecognitionConfig::verbatim_transcripts() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognitionConfig.verbatim_transcripts)
  return _internal_verbatim_transcripts();
}
inline void RecognitionConfig::set_verbatim_transcripts(bool value) {
  _internal_set_verbatim_transcripts(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.RecognitionConfig.verbatim_transcripts)
}
inline bool RecognitionConfig::_internal_verbatim_transcripts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.verbatim_transcripts_;
}
inline void RecognitionConfig::_internal_set_verbatim_transcripts(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.verbatim_transcripts_ = value;
}

// .nvidia.riva.asr.SpeakerDiarizationConfig diarization_config = 19;
inline bool RecognitionConfig::has_diarization_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.diarization_config_ != nullptr);
  return value;
}
inline void RecognitionConfig::clear_diarization_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.diarization_config_ != nullptr) _impl_.diarization_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nvidia::riva::asr::SpeakerDiarizationConfig& RecognitionConfig::_internal_diarization_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::asr::SpeakerDiarizationConfig* p = _impl_.diarization_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::asr::SpeakerDiarizationConfig&>(::nvidia::riva::asr::_SpeakerDiarizationConfig_default_instance_);
}
inline const ::nvidia::riva::asr::SpeakerDiarizationConfig& RecognitionConfig::diarization_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognitionConfig.diarization_config)
  return _internal_diarization_config();
}
inline void RecognitionConfig::unsafe_arena_set_allocated_diarization_config(::nvidia::riva::asr::SpeakerDiarizationConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.diarization_config_);
  }
  _impl_.diarization_config_ = reinterpret_cast<::nvidia::riva::asr::SpeakerDiarizationConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.asr.RecognitionConfig.diarization_config)
}
inline ::nvidia::riva::asr::SpeakerDiarizationConfig* RecognitionConfig::release_diarization_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::asr::SpeakerDiarizationConfig* released = _impl_.diarization_config_;
  _impl_.diarization_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::asr::SpeakerDiarizationConfig* RecognitionConfig::unsafe_arena_release_diarization_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.RecognitionConfig.diarization_config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::asr::SpeakerDiarizationConfig* temp = _impl_.diarization_config_;
  _impl_.diarization_config_ = nullptr;
  return temp;
}
inline ::nvidia::riva::asr::SpeakerDiarizationConfig* RecognitionConfig::_internal_mutable_diarization_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.diarization_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::asr::SpeakerDiarizationConfig>(GetArena());
    _impl_.diarization_config_ = reinterpret_cast<::nvidia::riva::asr::SpeakerDiarizationConfig*>(p);
  }
  return _impl_.diarization_config_;
}
inline ::nvidia::riva::asr::SpeakerDiarizationConfig* RecognitionConfig::mutable_diarization_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::asr::SpeakerDiarizationConfig* _msg = _internal_mutable_diarization_config();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.RecognitionConfig.diarization_config)
  return _msg;
}
inline void RecognitionConfig::set_allocated_diarization_config(::nvidia::riva::asr::SpeakerDiarizationConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::nvidia::riva::asr::SpeakerDiarizationConfig*>(_impl_.diarization_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::nvidia::riva::asr::SpeakerDiarizationConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.diarization_config_ = reinterpret_cast<::nvidia::riva::asr::SpeakerDiarizationConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.RecognitionConfig.diarization_config)
}

// map<string, string> custom_configuration = 24;
inline int RecognitionConfig::_internal_custom_configuration_size() const {
  return _internal_custom_configuration().size();
}
inline int RecognitionConfig::custom_configuration_size() const {
  return _internal_custom_configuration_size();
}
inline void RecognitionConfig::clear_custom_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.custom_configuration_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& RecognitionConfig::_internal_custom_configuration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.custom_configuration_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& RecognitionConfig::custom_configuration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:nvidia.riva.asr.RecognitionConfig.custom_configuration)
  return _internal_custom_configuration();
}
inline ::google::protobuf::Map<std::string, std::string>* RecognitionConfig::_internal_mutable_custom_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.custom_configuration_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* RecognitionConfig::mutable_custom_configuration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:nvidia.riva.asr.RecognitionConfig.custom_configuration)
  return _internal_mutable_custom_configuration();
}

// optional .nvidia.riva.asr.EndpointingConfig endpointing_config = 25;
inline bool RecognitionConfig::has_endpointing_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endpointing_config_ != nullptr);
  return value;
}
inline void RecognitionConfig::clear_endpointing_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.endpointing_config_ != nullptr) _impl_.endpointing_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::nvidia::riva::asr::EndpointingConfig& RecognitionConfig::_internal_endpointing_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::asr::EndpointingConfig* p = _impl_.endpointing_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::asr::EndpointingConfig&>(::nvidia::riva::asr::_EndpointingConfig_default_instance_);
}
inline const ::nvidia::riva::asr::EndpointingConfig& RecognitionConfig::endpointing_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognitionConfig.endpointing_config)
  return _internal_endpointing_config();
}
inline void RecognitionConfig::unsafe_arena_set_allocated_endpointing_config(::nvidia::riva::asr::EndpointingConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endpointing_config_);
  }
  _impl_.endpointing_config_ = reinterpret_cast<::nvidia::riva::asr::EndpointingConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.asr.RecognitionConfig.endpointing_config)
}
inline ::nvidia::riva::asr::EndpointingConfig* RecognitionConfig::release_endpointing_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::asr::EndpointingConfig* released = _impl_.endpointing_config_;
  _impl_.endpointing_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::asr::EndpointingConfig* RecognitionConfig::unsafe_arena_release_endpointing_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.RecognitionConfig.endpointing_config)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nvidia::riva::asr::EndpointingConfig* temp = _impl_.endpointing_config_;
  _impl_.endpointing_config_ = nullptr;
  return temp;
}
inline ::nvidia::riva::asr::EndpointingConfig* RecognitionConfig::_internal_mutable_endpointing_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.endpointing_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::asr::EndpointingConfig>(GetArena());
    _impl_.endpointing_config_ = reinterpret_cast<::nvidia::riva::asr::EndpointingConfig*>(p);
  }
  return _impl_.endpointing_config_;
}
inline ::nvidia::riva::asr::EndpointingConfig* RecognitionConfig::mutable_endpointing_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::asr::EndpointingConfig* _msg = _internal_mutable_endpointing_config();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.RecognitionConfig.endpointing_config)
  return _msg;
}
inline void RecognitionConfig::set_allocated_endpointing_config(::nvidia::riva::asr::EndpointingConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::nvidia::riva::asr::EndpointingConfig*>(_impl_.endpointing_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::nvidia::riva::asr::EndpointingConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.endpointing_config_ = reinterpret_cast<::nvidia::riva::asr::EndpointingConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.RecognitionConfig.endpointing_config)
}

// -------------------------------------------------------------------

// StreamingRecognitionConfig

// .nvidia.riva.asr.RecognitionConfig config = 1;
inline bool StreamingRecognitionConfig::has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.config_ != nullptr);
  return value;
}
inline void StreamingRecognitionConfig::clear_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.config_ != nullptr) _impl_.config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nvidia::riva::asr::RecognitionConfig& StreamingRecognitionConfig::_internal_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::asr::RecognitionConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::asr::RecognitionConfig&>(::nvidia::riva::asr::_RecognitionConfig_default_instance_);
}
inline const ::nvidia::riva::asr::RecognitionConfig& StreamingRecognitionConfig::config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.StreamingRecognitionConfig.config)
  return _internal_config();
}
inline void StreamingRecognitionConfig::unsafe_arena_set_allocated_config(::nvidia::riva::asr::RecognitionConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = reinterpret_cast<::nvidia::riva::asr::RecognitionConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.asr.StreamingRecognitionConfig.config)
}
inline ::nvidia::riva::asr::RecognitionConfig* StreamingRecognitionConfig::release_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::asr::RecognitionConfig* released = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::asr::RecognitionConfig* StreamingRecognitionConfig::unsafe_arena_release_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.StreamingRecognitionConfig.config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::asr::RecognitionConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::nvidia::riva::asr::RecognitionConfig* StreamingRecognitionConfig::_internal_mutable_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::asr::RecognitionConfig>(GetArena());
    _impl_.config_ = reinterpret_cast<::nvidia::riva::asr::RecognitionConfig*>(p);
  }
  return _impl_.config_;
}
inline ::nvidia::riva::asr::RecognitionConfig* StreamingRecognitionConfig::mutable_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::asr::RecognitionConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.StreamingRecognitionConfig.config)
  return _msg;
}
inline void StreamingRecognitionConfig::set_allocated_config(::nvidia::riva::asr::RecognitionConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::nvidia::riva::asr::RecognitionConfig*>(_impl_.config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::nvidia::riva::asr::RecognitionConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.config_ = reinterpret_cast<::nvidia::riva::asr::RecognitionConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.StreamingRecognitionConfig.config)
}

// bool interim_results = 2;
inline void StreamingRecognitionConfig::clear_interim_results() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interim_results_ = false;
}
inline bool StreamingRecognitionConfig::interim_results() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.StreamingRecognitionConfig.interim_results)
  return _internal_interim_results();
}
inline void StreamingRecognitionConfig::set_interim_results(bool value) {
  _internal_set_interim_results(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.StreamingRecognitionConfig.interim_results)
}
inline bool StreamingRecognitionConfig::_internal_interim_results() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interim_results_;
}
inline void StreamingRecognitionConfig::_internal_set_interim_results(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interim_results_ = value;
}

// -------------------------------------------------------------------

// SpeakerDiarizationConfig

// bool enable_speaker_diarization = 1;
inline void SpeakerDiarizationConfig::clear_enable_speaker_diarization() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_speaker_diarization_ = false;
}
inline bool SpeakerDiarizationConfig::enable_speaker_diarization() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.SpeakerDiarizationConfig.enable_speaker_diarization)
  return _internal_enable_speaker_diarization();
}
inline void SpeakerDiarizationConfig::set_enable_speaker_diarization(bool value) {
  _internal_set_enable_speaker_diarization(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.SpeakerDiarizationConfig.enable_speaker_diarization)
}
inline bool SpeakerDiarizationConfig::_internal_enable_speaker_diarization() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_speaker_diarization_;
}
inline void SpeakerDiarizationConfig::_internal_set_enable_speaker_diarization(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_speaker_diarization_ = value;
}

// int32 max_speaker_count = 2;
inline void SpeakerDiarizationConfig::clear_max_speaker_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_speaker_count_ = 0;
}
inline ::int32_t SpeakerDiarizationConfig::max_speaker_count() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.SpeakerDiarizationConfig.max_speaker_count)
  return _internal_max_speaker_count();
}
inline void SpeakerDiarizationConfig::set_max_speaker_count(::int32_t value) {
  _internal_set_max_speaker_count(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.SpeakerDiarizationConfig.max_speaker_count)
}
inline ::int32_t SpeakerDiarizationConfig::_internal_max_speaker_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_speaker_count_;
}
inline void SpeakerDiarizationConfig::_internal_set_max_speaker_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_speaker_count_ = value;
}

// -------------------------------------------------------------------

// SpeechContext

// repeated string phrases = 1;
inline int SpeechContext::_internal_phrases_size() const {
  return _internal_phrases().size();
}
inline int SpeechContext::phrases_size() const {
  return _internal_phrases_size();
}
inline void SpeechContext::clear_phrases() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.phrases_.Clear();
}
inline std::string* SpeechContext::add_phrases()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_phrases()->Add();
  // @@protoc_insertion_point(field_add_mutable:nvidia.riva.asr.SpeechContext.phrases)
  return _s;
}
inline const std::string& SpeechContext::phrases(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.SpeechContext.phrases)
  return _internal_phrases().Get(index);
}
inline std::string* SpeechContext::mutable_phrases(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.SpeechContext.phrases)
  return _internal_mutable_phrases()->Mutable(index);
}
inline void SpeechContext::set_phrases(int index, const std::string& value) {
  _internal_mutable_phrases()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.SpeechContext.phrases)
}
inline void SpeechContext::set_phrases(int index, std::string&& value) {
  _internal_mutable_phrases()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.SpeechContext.phrases)
}
inline void SpeechContext::set_phrases(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_phrases()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nvidia.riva.asr.SpeechContext.phrases)
}
inline void SpeechContext::set_phrases(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_phrases()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nvidia.riva.asr.SpeechContext.phrases)
}
inline void SpeechContext::set_phrases(int index, absl::string_view value) {
  _internal_mutable_phrases()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:nvidia.riva.asr.SpeechContext.phrases)
}
inline void SpeechContext::add_phrases(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_phrases()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:nvidia.riva.asr.SpeechContext.phrases)
}
inline void SpeechContext::add_phrases(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_phrases()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:nvidia.riva.asr.SpeechContext.phrases)
}
inline void SpeechContext::add_phrases(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_phrases()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nvidia.riva.asr.SpeechContext.phrases)
}
inline void SpeechContext::add_phrases(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_phrases()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nvidia.riva.asr.SpeechContext.phrases)
}
inline void SpeechContext::add_phrases(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_phrases()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:nvidia.riva.asr.SpeechContext.phrases)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SpeechContext::phrases() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.asr.SpeechContext.phrases)
  return _internal_phrases();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SpeechContext::mutable_phrases() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.asr.SpeechContext.phrases)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_phrases();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SpeechContext::_internal_phrases() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.phrases_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SpeechContext::_internal_mutable_phrases() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.phrases_;
}

// float boost = 4;
inline void SpeechContext::clear_boost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.boost_ = 0;
}
inline float SpeechContext::boost() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.SpeechContext.boost)
  return _internal_boost();
}
inline void SpeechContext::set_boost(float value) {
  _internal_set_boost(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.SpeechContext.boost)
}
inline float SpeechContext::_internal_boost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.boost_;
}
inline void SpeechContext::_internal_set_boost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.boost_ = value;
}

// -------------------------------------------------------------------

// RecognizeResponse

// repeated .nvidia.riva.asr.SpeechRecognitionResult results = 1;
inline int RecognizeResponse::_internal_results_size() const {
  return _internal_results().size();
}
inline int RecognizeResponse::results_size() const {
  return _internal_results_size();
}
inline void RecognizeResponse::clear_results() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.results_.Clear();
}
inline ::nvidia::riva::asr::SpeechRecognitionResult* RecognizeResponse::mutable_results(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.RecognizeResponse.results)
  return _internal_mutable_results()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionResult>* RecognizeResponse::mutable_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.asr.RecognizeResponse.results)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_results();
}
inline const ::nvidia::riva::asr::SpeechRecognitionResult& RecognizeResponse::results(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognizeResponse.results)
  return _internal_results().Get(index);
}
inline ::nvidia::riva::asr::SpeechRecognitionResult* RecognizeResponse::add_results() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::asr::SpeechRecognitionResult* _add = _internal_mutable_results()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.asr.RecognizeResponse.results)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionResult>& RecognizeResponse::results() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.asr.RecognizeResponse.results)
  return _internal_results();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionResult>&
RecognizeResponse::_internal_results() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.results_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionResult>*
RecognizeResponse::_internal_mutable_results() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.results_;
}

// .nvidia.riva.RequestId id = 100;
inline bool RecognizeResponse::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& RecognizeResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& RecognizeResponse::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.RecognizeResponse.id)
  return _internal_id();
}
inline void RecognizeResponse::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.asr.RecognizeResponse.id)
}
inline ::nvidia::riva::RequestId* RecognizeResponse::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* RecognizeResponse::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.RecognizeResponse.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* RecognizeResponse::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* RecognizeResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.RecognizeResponse.id)
  return _msg;
}
inline void RecognizeResponse::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.RecognizeResponse.id)
}

// -------------------------------------------------------------------

// SpeechRecognitionResult

// repeated .nvidia.riva.asr.SpeechRecognitionAlternative alternatives = 1;
inline int SpeechRecognitionResult::_internal_alternatives_size() const {
  return _internal_alternatives().size();
}
inline int SpeechRecognitionResult::alternatives_size() const {
  return _internal_alternatives_size();
}
inline void SpeechRecognitionResult::clear_alternatives() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alternatives_.Clear();
}
inline ::nvidia::riva::asr::SpeechRecognitionAlternative* SpeechRecognitionResult::mutable_alternatives(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.SpeechRecognitionResult.alternatives)
  return _internal_mutable_alternatives()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionAlternative>* SpeechRecognitionResult::mutable_alternatives()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.asr.SpeechRecognitionResult.alternatives)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_alternatives();
}
inline const ::nvidia::riva::asr::SpeechRecognitionAlternative& SpeechRecognitionResult::alternatives(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.SpeechRecognitionResult.alternatives)
  return _internal_alternatives().Get(index);
}
inline ::nvidia::riva::asr::SpeechRecognitionAlternative* SpeechRecognitionResult::add_alternatives() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::asr::SpeechRecognitionAlternative* _add = _internal_mutable_alternatives()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.asr.SpeechRecognitionResult.alternatives)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionAlternative>& SpeechRecognitionResult::alternatives() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.asr.SpeechRecognitionResult.alternatives)
  return _internal_alternatives();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionAlternative>&
SpeechRecognitionResult::_internal_alternatives() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alternatives_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionAlternative>*
SpeechRecognitionResult::_internal_mutable_alternatives() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.alternatives_;
}

// int32 channel_tag = 2;
inline void SpeechRecognitionResult::clear_channel_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_tag_ = 0;
}
inline ::int32_t SpeechRecognitionResult::channel_tag() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.SpeechRecognitionResult.channel_tag)
  return _internal_channel_tag();
}
inline void SpeechRecognitionResult::set_channel_tag(::int32_t value) {
  _internal_set_channel_tag(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.SpeechRecognitionResult.channel_tag)
}
inline ::int32_t SpeechRecognitionResult::_internal_channel_tag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_tag_;
}
inline void SpeechRecognitionResult::_internal_set_channel_tag(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_tag_ = value;
}

// float audio_processed = 3;
inline void SpeechRecognitionResult::clear_audio_processed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_processed_ = 0;
}
inline float SpeechRecognitionResult::audio_processed() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.SpeechRecognitionResult.audio_processed)
  return _internal_audio_processed();
}
inline void SpeechRecognitionResult::set_audio_processed(float value) {
  _internal_set_audio_processed(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.SpeechRecognitionResult.audio_processed)
}
inline float SpeechRecognitionResult::_internal_audio_processed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_processed_;
}
inline void SpeechRecognitionResult::_internal_set_audio_processed(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.audio_processed_ = value;
}

// -------------------------------------------------------------------

// SpeechRecognitionAlternative

// string transcript = 1;
inline void SpeechRecognitionAlternative::clear_transcript() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transcript_.ClearToEmpty();
}
inline const std::string& SpeechRecognitionAlternative::transcript() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.SpeechRecognitionAlternative.transcript)
  return _internal_transcript();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpeechRecognitionAlternative::set_transcript(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.transcript_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.SpeechRecognitionAlternative.transcript)
}
inline std::string* SpeechRecognitionAlternative::mutable_transcript() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transcript();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.SpeechRecognitionAlternative.transcript)
  return _s;
}
inline const std::string& SpeechRecognitionAlternative::_internal_transcript() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transcript_.Get();
}
inline void SpeechRecognitionAlternative::_internal_set_transcript(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.transcript_.Set(value, GetArena());
}
inline std::string* SpeechRecognitionAlternative::_internal_mutable_transcript() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.transcript_.Mutable( GetArena());
}
inline std::string* SpeechRecognitionAlternative::release_transcript() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.SpeechRecognitionAlternative.transcript)
  return _impl_.transcript_.Release();
}
inline void SpeechRecognitionAlternative::set_allocated_transcript(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transcript_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transcript_.IsDefault()) {
          _impl_.transcript_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.SpeechRecognitionAlternative.transcript)
}

// float confidence = 2;
inline void SpeechRecognitionAlternative::clear_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.confidence_ = 0;
}
inline float SpeechRecognitionAlternative::confidence() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.SpeechRecognitionAlternative.confidence)
  return _internal_confidence();
}
inline void SpeechRecognitionAlternative::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.SpeechRecognitionAlternative.confidence)
}
inline float SpeechRecognitionAlternative::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.confidence_;
}
inline void SpeechRecognitionAlternative::_internal_set_confidence(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.confidence_ = value;
}

// repeated .nvidia.riva.asr.WordInfo words = 3;
inline int SpeechRecognitionAlternative::_internal_words_size() const {
  return _internal_words().size();
}
inline int SpeechRecognitionAlternative::words_size() const {
  return _internal_words_size();
}
inline void SpeechRecognitionAlternative::clear_words() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.words_.Clear();
}
inline ::nvidia::riva::asr::WordInfo* SpeechRecognitionAlternative::mutable_words(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.SpeechRecognitionAlternative.words)
  return _internal_mutable_words()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::WordInfo>* SpeechRecognitionAlternative::mutable_words()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.asr.SpeechRecognitionAlternative.words)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_words();
}
inline const ::nvidia::riva::asr::WordInfo& SpeechRecognitionAlternative::words(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.SpeechRecognitionAlternative.words)
  return _internal_words().Get(index);
}
inline ::nvidia::riva::asr::WordInfo* SpeechRecognitionAlternative::add_words() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::asr::WordInfo* _add = _internal_mutable_words()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.asr.SpeechRecognitionAlternative.words)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::WordInfo>& SpeechRecognitionAlternative::words() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.asr.SpeechRecognitionAlternative.words)
  return _internal_words();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::WordInfo>&
SpeechRecognitionAlternative::_internal_words() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.words_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::WordInfo>*
SpeechRecognitionAlternative::_internal_mutable_words() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.words_;
}

// repeated string language_code = 4;
inline int SpeechRecognitionAlternative::_internal_language_code_size() const {
  return _internal_language_code().size();
}
inline int SpeechRecognitionAlternative::language_code_size() const {
  return _internal_language_code_size();
}
inline void SpeechRecognitionAlternative::clear_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_code_.Clear();
}
inline std::string* SpeechRecognitionAlternative::add_language_code()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_language_code()->Add();
  // @@protoc_insertion_point(field_add_mutable:nvidia.riva.asr.SpeechRecognitionAlternative.language_code)
  return _s;
}
inline const std::string& SpeechRecognitionAlternative::language_code(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.SpeechRecognitionAlternative.language_code)
  return _internal_language_code().Get(index);
}
inline std::string* SpeechRecognitionAlternative::mutable_language_code(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.SpeechRecognitionAlternative.language_code)
  return _internal_mutable_language_code()->Mutable(index);
}
inline void SpeechRecognitionAlternative::set_language_code(int index, const std::string& value) {
  _internal_mutable_language_code()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.SpeechRecognitionAlternative.language_code)
}
inline void SpeechRecognitionAlternative::set_language_code(int index, std::string&& value) {
  _internal_mutable_language_code()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.SpeechRecognitionAlternative.language_code)
}
inline void SpeechRecognitionAlternative::set_language_code(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_language_code()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nvidia.riva.asr.SpeechRecognitionAlternative.language_code)
}
inline void SpeechRecognitionAlternative::set_language_code(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_language_code()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nvidia.riva.asr.SpeechRecognitionAlternative.language_code)
}
inline void SpeechRecognitionAlternative::set_language_code(int index, absl::string_view value) {
  _internal_mutable_language_code()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:nvidia.riva.asr.SpeechRecognitionAlternative.language_code)
}
inline void SpeechRecognitionAlternative::add_language_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_language_code()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:nvidia.riva.asr.SpeechRecognitionAlternative.language_code)
}
inline void SpeechRecognitionAlternative::add_language_code(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_language_code()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:nvidia.riva.asr.SpeechRecognitionAlternative.language_code)
}
inline void SpeechRecognitionAlternative::add_language_code(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_language_code()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nvidia.riva.asr.SpeechRecognitionAlternative.language_code)
}
inline void SpeechRecognitionAlternative::add_language_code(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_language_code()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nvidia.riva.asr.SpeechRecognitionAlternative.language_code)
}
inline void SpeechRecognitionAlternative::add_language_code(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_language_code()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:nvidia.riva.asr.SpeechRecognitionAlternative.language_code)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SpeechRecognitionAlternative::language_code() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.asr.SpeechRecognitionAlternative.language_code)
  return _internal_language_code();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SpeechRecognitionAlternative::mutable_language_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.asr.SpeechRecognitionAlternative.language_code)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_language_code();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SpeechRecognitionAlternative::_internal_language_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.language_code_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SpeechRecognitionAlternative::_internal_mutable_language_code() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.language_code_;
}

// -------------------------------------------------------------------

// WordInfo

// int32 start_time = 1;
inline void WordInfo::clear_start_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_time_ = 0;
}
inline ::int32_t WordInfo::start_time() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.WordInfo.start_time)
  return _internal_start_time();
}
inline void WordInfo::set_start_time(::int32_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.WordInfo.start_time)
}
inline ::int32_t WordInfo::_internal_start_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_time_;
}
inline void WordInfo::_internal_set_start_time(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_time_ = value;
}

// int32 end_time = 2;
inline void WordInfo::clear_end_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_time_ = 0;
}
inline ::int32_t WordInfo::end_time() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.WordInfo.end_time)
  return _internal_end_time();
}
inline void WordInfo::set_end_time(::int32_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.WordInfo.end_time)
}
inline ::int32_t WordInfo::_internal_end_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_time_;
}
inline void WordInfo::_internal_set_end_time(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_time_ = value;
}

// string word = 3;
inline void WordInfo::clear_word() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.word_.ClearToEmpty();
}
inline const std::string& WordInfo::word() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.WordInfo.word)
  return _internal_word();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WordInfo::set_word(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.word_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.WordInfo.word)
}
inline std::string* WordInfo::mutable_word() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_word();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.WordInfo.word)
  return _s;
}
inline const std::string& WordInfo::_internal_word() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.word_.Get();
}
inline void WordInfo::_internal_set_word(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.word_.Set(value, GetArena());
}
inline std::string* WordInfo::_internal_mutable_word() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.word_.Mutable( GetArena());
}
inline std::string* WordInfo::release_word() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.WordInfo.word)
  return _impl_.word_.Release();
}
inline void WordInfo::set_allocated_word(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.word_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.word_.IsDefault()) {
          _impl_.word_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.WordInfo.word)
}

// float confidence = 4;
inline void WordInfo::clear_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.confidence_ = 0;
}
inline float WordInfo::confidence() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.WordInfo.confidence)
  return _internal_confidence();
}
inline void WordInfo::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.WordInfo.confidence)
}
inline float WordInfo::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.confidence_;
}
inline void WordInfo::_internal_set_confidence(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.confidence_ = value;
}

// int32 speaker_tag = 5;
inline void WordInfo::clear_speaker_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speaker_tag_ = 0;
}
inline ::int32_t WordInfo::speaker_tag() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.WordInfo.speaker_tag)
  return _internal_speaker_tag();
}
inline void WordInfo::set_speaker_tag(::int32_t value) {
  _internal_set_speaker_tag(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.WordInfo.speaker_tag)
}
inline ::int32_t WordInfo::_internal_speaker_tag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speaker_tag_;
}
inline void WordInfo::_internal_set_speaker_tag(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.speaker_tag_ = value;
}

// string language_code = 6;
inline void WordInfo::clear_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_code_.ClearToEmpty();
}
inline const std::string& WordInfo::language_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.WordInfo.language_code)
  return _internal_language_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WordInfo::set_language_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.WordInfo.language_code)
}
inline std::string* WordInfo::mutable_language_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_language_code();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.WordInfo.language_code)
  return _s;
}
inline const std::string& WordInfo::_internal_language_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.language_code_.Get();
}
inline void WordInfo::_internal_set_language_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_code_.Set(value, GetArena());
}
inline std::string* WordInfo::_internal_mutable_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.language_code_.Mutable( GetArena());
}
inline std::string* WordInfo::release_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.WordInfo.language_code)
  return _impl_.language_code_.Release();
}
inline void WordInfo::set_allocated_language_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.language_code_.IsDefault()) {
          _impl_.language_code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.WordInfo.language_code)
}

// -------------------------------------------------------------------

// StreamingRecognizeResponse

// repeated .nvidia.riva.asr.StreamingRecognitionResult results = 1;
inline int StreamingRecognizeResponse::_internal_results_size() const {
  return _internal_results().size();
}
inline int StreamingRecognizeResponse::results_size() const {
  return _internal_results_size();
}
inline void StreamingRecognizeResponse::clear_results() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.results_.Clear();
}
inline ::nvidia::riva::asr::StreamingRecognitionResult* StreamingRecognizeResponse::mutable_results(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.StreamingRecognizeResponse.results)
  return _internal_mutable_results()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::StreamingRecognitionResult>* StreamingRecognizeResponse::mutable_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.asr.StreamingRecognizeResponse.results)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_results();
}
inline const ::nvidia::riva::asr::StreamingRecognitionResult& StreamingRecognizeResponse::results(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.StreamingRecognizeResponse.results)
  return _internal_results().Get(index);
}
inline ::nvidia::riva::asr::StreamingRecognitionResult* StreamingRecognizeResponse::add_results() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::asr::StreamingRecognitionResult* _add = _internal_mutable_results()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.asr.StreamingRecognizeResponse.results)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::StreamingRecognitionResult>& StreamingRecognizeResponse::results() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.asr.StreamingRecognizeResponse.results)
  return _internal_results();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::StreamingRecognitionResult>&
StreamingRecognizeResponse::_internal_results() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.results_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::StreamingRecognitionResult>*
StreamingRecognizeResponse::_internal_mutable_results() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.results_;
}

// .nvidia.riva.RequestId id = 100;
inline bool StreamingRecognizeResponse::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::nvidia::riva::RequestId& StreamingRecognizeResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::RequestId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::RequestId&>(::nvidia::riva::_RequestId_default_instance_);
}
inline const ::nvidia::riva::RequestId& StreamingRecognizeResponse::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.StreamingRecognizeResponse.id)
  return _internal_id();
}
inline void StreamingRecognizeResponse::unsafe_arena_set_allocated_id(::nvidia::riva::RequestId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.asr.StreamingRecognizeResponse.id)
}
inline ::nvidia::riva::RequestId* StreamingRecognizeResponse::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::RequestId* StreamingRecognizeResponse::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.StreamingRecognizeResponse.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::RequestId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::nvidia::riva::RequestId* StreamingRecognizeResponse::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::RequestId>(GetArena());
    _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(p);
  }
  return _impl_.id_;
}
inline ::nvidia::riva::RequestId* StreamingRecognizeResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::RequestId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.StreamingRecognizeResponse.id)
  return _msg;
}
inline void StreamingRecognizeResponse::set_allocated_id(::nvidia::riva::RequestId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::nvidia::riva::RequestId*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.StreamingRecognizeResponse.id)
}

// -------------------------------------------------------------------

// PipelineStates

// repeated float vad_probabilities = 1;
inline int PipelineStates::_internal_vad_probabilities_size() const {
  return _internal_vad_probabilities().size();
}
inline int PipelineStates::vad_probabilities_size() const {
  return _internal_vad_probabilities_size();
}
inline void PipelineStates::clear_vad_probabilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vad_probabilities_.Clear();
}
inline float PipelineStates::vad_probabilities(int index) const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.PipelineStates.vad_probabilities)
  return _internal_vad_probabilities().Get(index);
}
inline void PipelineStates::set_vad_probabilities(int index, float value) {
  _internal_mutable_vad_probabilities()->Set(index, value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.PipelineStates.vad_probabilities)
}
inline void PipelineStates::add_vad_probabilities(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_vad_probabilities()->Add(value);
  // @@protoc_insertion_point(field_add:nvidia.riva.asr.PipelineStates.vad_probabilities)
}
inline const ::google::protobuf::RepeatedField<float>& PipelineStates::vad_probabilities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.asr.PipelineStates.vad_probabilities)
  return _internal_vad_probabilities();
}
inline ::google::protobuf::RepeatedField<float>* PipelineStates::mutable_vad_probabilities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.asr.PipelineStates.vad_probabilities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vad_probabilities();
}
inline const ::google::protobuf::RepeatedField<float>& PipelineStates::_internal_vad_probabilities()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vad_probabilities_;
}
inline ::google::protobuf::RepeatedField<float>* PipelineStates::_internal_mutable_vad_probabilities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vad_probabilities_;
}

// -------------------------------------------------------------------

// StreamingRecognitionResult

// repeated .nvidia.riva.asr.SpeechRecognitionAlternative alternatives = 1;
inline int StreamingRecognitionResult::_internal_alternatives_size() const {
  return _internal_alternatives().size();
}
inline int StreamingRecognitionResult::alternatives_size() const {
  return _internal_alternatives_size();
}
inline void StreamingRecognitionResult::clear_alternatives() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alternatives_.Clear();
}
inline ::nvidia::riva::asr::SpeechRecognitionAlternative* StreamingRecognitionResult::mutable_alternatives(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.StreamingRecognitionResult.alternatives)
  return _internal_mutable_alternatives()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionAlternative>* StreamingRecognitionResult::mutable_alternatives()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:nvidia.riva.asr.StreamingRecognitionResult.alternatives)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_alternatives();
}
inline const ::nvidia::riva::asr::SpeechRecognitionAlternative& StreamingRecognitionResult::alternatives(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.StreamingRecognitionResult.alternatives)
  return _internal_alternatives().Get(index);
}
inline ::nvidia::riva::asr::SpeechRecognitionAlternative* StreamingRecognitionResult::add_alternatives() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::nvidia::riva::asr::SpeechRecognitionAlternative* _add = _internal_mutable_alternatives()->Add();
  // @@protoc_insertion_point(field_add:nvidia.riva.asr.StreamingRecognitionResult.alternatives)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionAlternative>& StreamingRecognitionResult::alternatives() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:nvidia.riva.asr.StreamingRecognitionResult.alternatives)
  return _internal_alternatives();
}
inline const ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionAlternative>&
StreamingRecognitionResult::_internal_alternatives() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alternatives_;
}
inline ::google::protobuf::RepeatedPtrField<::nvidia::riva::asr::SpeechRecognitionAlternative>*
StreamingRecognitionResult::_internal_mutable_alternatives() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.alternatives_;
}

// bool is_final = 2;
inline void StreamingRecognitionResult::clear_is_final() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_final_ = false;
}
inline bool StreamingRecognitionResult::is_final() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.StreamingRecognitionResult.is_final)
  return _internal_is_final();
}
inline void StreamingRecognitionResult::set_is_final(bool value) {
  _internal_set_is_final(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.StreamingRecognitionResult.is_final)
}
inline bool StreamingRecognitionResult::_internal_is_final() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_final_;
}
inline void StreamingRecognitionResult::_internal_set_is_final(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_final_ = value;
}

// float stability = 3;
inline void StreamingRecognitionResult::clear_stability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stability_ = 0;
}
inline float StreamingRecognitionResult::stability() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.StreamingRecognitionResult.stability)
  return _internal_stability();
}
inline void StreamingRecognitionResult::set_stability(float value) {
  _internal_set_stability(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.StreamingRecognitionResult.stability)
}
inline float StreamingRecognitionResult::_internal_stability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stability_;
}
inline void StreamingRecognitionResult::_internal_set_stability(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stability_ = value;
}

// int32 channel_tag = 5;
inline void StreamingRecognitionResult::clear_channel_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_tag_ = 0;
}
inline ::int32_t StreamingRecognitionResult::channel_tag() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.StreamingRecognitionResult.channel_tag)
  return _internal_channel_tag();
}
inline void StreamingRecognitionResult::set_channel_tag(::int32_t value) {
  _internal_set_channel_tag(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.StreamingRecognitionResult.channel_tag)
}
inline ::int32_t StreamingRecognitionResult::_internal_channel_tag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_tag_;
}
inline void StreamingRecognitionResult::_internal_set_channel_tag(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_tag_ = value;
}

// float audio_processed = 6;
inline void StreamingRecognitionResult::clear_audio_processed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_processed_ = 0;
}
inline float StreamingRecognitionResult::audio_processed() const {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.StreamingRecognitionResult.audio_processed)
  return _internal_audio_processed();
}
inline void StreamingRecognitionResult::set_audio_processed(float value) {
  _internal_set_audio_processed(value);
  // @@protoc_insertion_point(field_set:nvidia.riva.asr.StreamingRecognitionResult.audio_processed)
}
inline float StreamingRecognitionResult::_internal_audio_processed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_processed_;
}
inline void StreamingRecognitionResult::_internal_set_audio_processed(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.audio_processed_ = value;
}

// optional .nvidia.riva.asr.PipelineStates pipeline_states = 7;
inline bool StreamingRecognitionResult::has_pipeline_states() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pipeline_states_ != nullptr);
  return value;
}
inline void StreamingRecognitionResult::clear_pipeline_states() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pipeline_states_ != nullptr) _impl_.pipeline_states_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nvidia::riva::asr::PipelineStates& StreamingRecognitionResult::_internal_pipeline_states() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::nvidia::riva::asr::PipelineStates* p = _impl_.pipeline_states_;
  return p != nullptr ? *p : reinterpret_cast<const ::nvidia::riva::asr::PipelineStates&>(::nvidia::riva::asr::_PipelineStates_default_instance_);
}
inline const ::nvidia::riva::asr::PipelineStates& StreamingRecognitionResult::pipeline_states() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:nvidia.riva.asr.StreamingRecognitionResult.pipeline_states)
  return _internal_pipeline_states();
}
inline void StreamingRecognitionResult::unsafe_arena_set_allocated_pipeline_states(::nvidia::riva::asr::PipelineStates* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pipeline_states_);
  }
  _impl_.pipeline_states_ = reinterpret_cast<::nvidia::riva::asr::PipelineStates*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nvidia.riva.asr.StreamingRecognitionResult.pipeline_states)
}
inline ::nvidia::riva::asr::PipelineStates* StreamingRecognitionResult::release_pipeline_states() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::asr::PipelineStates* released = _impl_.pipeline_states_;
  _impl_.pipeline_states_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::nvidia::riva::asr::PipelineStates* StreamingRecognitionResult::unsafe_arena_release_pipeline_states() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:nvidia.riva.asr.StreamingRecognitionResult.pipeline_states)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nvidia::riva::asr::PipelineStates* temp = _impl_.pipeline_states_;
  _impl_.pipeline_states_ = nullptr;
  return temp;
}
inline ::nvidia::riva::asr::PipelineStates* StreamingRecognitionResult::_internal_mutable_pipeline_states() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pipeline_states_ == nullptr) {
    auto* p = CreateMaybeMessage<::nvidia::riva::asr::PipelineStates>(GetArena());
    _impl_.pipeline_states_ = reinterpret_cast<::nvidia::riva::asr::PipelineStates*>(p);
  }
  return _impl_.pipeline_states_;
}
inline ::nvidia::riva::asr::PipelineStates* StreamingRecognitionResult::mutable_pipeline_states() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::nvidia::riva::asr::PipelineStates* _msg = _internal_mutable_pipeline_states();
  // @@protoc_insertion_point(field_mutable:nvidia.riva.asr.StreamingRecognitionResult.pipeline_states)
  return _msg;
}
inline void StreamingRecognitionResult::set_allocated_pipeline_states(::nvidia::riva::asr::PipelineStates* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::nvidia::riva::asr::PipelineStates*>(_impl_.pipeline_states_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::nvidia::riva::asr::PipelineStates*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pipeline_states_ = reinterpret_cast<::nvidia::riva::asr::PipelineStates*>(value);
  // @@protoc_insertion_point(field_set_allocated:nvidia.riva.asr.StreamingRecognitionResult.pipeline_states)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace asr
}  // namespace riva
}  // namespace nvidia


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_riva_2fproto_2friva_5fasr_2eproto_2epb_2eh
